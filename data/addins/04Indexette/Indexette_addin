# Indexette (Index-et)

#
# Author: Rob Reed
# Contact: rob@ode-is-simple.com

# Project: Ode
# Project website: ode-is-simple.com/


# -----
# License
# -----

# Creative Commons Attribution-Share Alike 3.0 United States

# For more information refer to:
# http://creativecommons.org/licenses/by-sa/3.0/us/

# Note: Be aware that continued use of this license is something that
# I am still considering.

# Future versions may be released under some other license.

# I do expect that any future license will be for the most part compatible
# with this one.


# ----------
# Message
# ----------

# Welcome to Indexette release 1.0.


# If you have any questions about Indexette or should you run into
# any trouble using the addin, please don't hesitate
# visit the Ode's community forum!

# http://ode-is-simple.com/vanilla2_forum/


# -----
# Important:
# -----

# 1. Indexette 1.0 requires version 1.2.3 of Ode or later.

# Indexette's replace_discover_posts routine
# takes advantage of two of ode.cgi's subroutines for
# managing it's index-date tag.

# These routines either
# did not exist or were reworked in version 1.2.3.

# As a result, Indexette 1.0 is incompatible with earlier versions of ode.


# 2. Before you attempt to use Indexette, read through the installation
# instructions (just below).

# Be aware that Indexette will modify your post files. This means it is
# more important than ever (and it's always important)
# that you have a backup of your post files before experimenting with
# Indexette.

# Though Indexette should be safe, I make no guarentees.

# Use Indexette at your own risk!

# ----------


# ----------
# Version Information
# ----------

# Version: 1.0
# build: 2009_0501_00_00_01
# About this version: -

# Previous Version: -
# About previous version: -
# Version: -
# build: -


# ----------
# Installation instructions
# ----------

# Installing Indexette is a simple 2.5 step process.


# -----
# | Step 1
# -----

# You must manually create the addin's state directory.


# When you installed Ode, you copied a directory titled 'state' somewhere,
# and you spcified the location of this directory
# as the value of the
# config setting - $addin_state_dir.

# (By default, state is a subdirectory of your 'addins' folder.)


# Addins that store data of one sort or another (i.e. state),
# such as Indexette's indexes, 
# should save that data to one or more files in a subdirectory
# under the state.


# Indexette must manage two index files as part of its operation
# (specified in the config section below):

# 1. A primary index
# 2. An auxiliary index


# !You must manually create Indexette's state directory!

# You should create a new folder as a subdirectory of 'state' and
# this directory _must_ be be titled 'Indexette'.

# So the path to the Indexette state dir should be

# '.../state/Indexette/'

# If 'state' is a subdirectory of the addins folder, as it is by default,
# then the directory structure, after you add
# Indexette's state dir, will look something like:

# addins/
#     00Markdown
#     ... (Other addins)
#     state/
#         Indexette/


# The Indexette state directory should be left empty.

# (Indexette will take care of creating and managing these files on it's
# own.)


# Important

# The CGI user _must_ have read and write access to the Indexette state
# directory.


# -----
# | Step 2
# -----

# Copy the Indexette addin bundle, titled

# '02Indexette',

# to your addins directory.

# The bundle contains a single file,

# 'Indexette_addin',

# which is the addin itself.


# Note you can change the leading bundle number prefix value if you like.

# For example any of the following are
# valid bundle titles:

# '00Indexette'
# '99Indexette'
# '10Indexette'


# For more info about these bundle numbers see
# the documentation for Ode at:

# ode-is-simple.com


# -----
# | Step 2.5
# -----

#
# If you reload your site
# after installing the Indexette addin, you will find that all of your posts
# seem to have disappeared.

# (This assumes you've installed the addin properly.)


# This is because when the Indexette addin is installed
# Ode reads Indexette's index files
# rather than looking for the post files directly,
# and currently the Indexes don't exist
# or are empty.

# You need to populate the primary index file.

# How?


# Let's say that you access your site at:

# 'http://sample.net/cgi-bin/ode.cgi'


# To create the primary index you would include Indexette's
# reindex parameter
# as part of the request for your site.

# 'http://sample.net/cgi-bin/ode.cgi?reindex=y'


# Your posts should now appear.

# (Remove the reindex parameter and request the site again and
# confirm that all of your posts still appear.)

# Everytime you include the reindex parameter with a request,
# Ode and Indexette will rebuild the primary index
# file.

# There is also an add_post parameter which allows you to add new posts
# one at a time, without rebuilding the
# entire index.

# (See usage instructions for more info.)


# Important
# --------------------

# In addition to adding an entry to the primary index file for the
# posts on your site, Indexette will also
# add an index-date tag to each of your post files.


# Intitially this 'index-date' is based on the post file's
# modification timestamp.

# The addin consults this tag to determine
# the post dates to record to its indexes, only reverting to the use of
# file modification times
# when the index-date tag is missing.


# There are two benefits to this:

# 1. It allows us to preserve post dates
# so that they will not change unintentionally (like file
# modification times can).

# Instead of updating automatically every time a post is edited,
# the post date must be explicitly modified
# by updating the value of the tag.

# 2. A site maintainer can conveniently update
# the post date by changing the value of the human readable
# index-date tag.

# This means that posts can easily be assigned arbitrary post dates.


# The really important part
# --------------------

# Yes, this does mean that Indexette will rewrite your post files.

# This is done safely.

# Posts are not edited in place,
# rather a new temporary file is created that is identical to the original
# (except for the inclusion of the new tag).
# The original post is deleted only after the new file
# has been created successfully.

# However, I do recommend that you

# _back up your post files first before experimenting with Indexette_

# for the first time.


# (Of course, you should always back up your site - and any other
# data that you don't want to lose.)


# Though Indexette should be safe, I make no guarentees.

# Use Indexette at your own risk!


# At the very least, please do make a backup of your post files before
# using Indexette for the first time.

# Backing up your posts with Ode is as easy as making
# a copy of Ode's document directory - specified in the configuration file
# as the value of the setting:

# $document_root



# ----------
# Usage instructions
# ----------

# For complete usage instructions refer to the readme file included with the
# release zip archive.


# With Indexette installed
# (read the installation instructions above for more info),
# interacting with Indexette involves
# working with just

# 3 simple mechanisms:

# 1. The reindex parameter
# 2. The add_post parameter
# 3. The index-date tag

# Once you understand how these work,
# you know all you need to know all you need to know
# about how to use Indexette.


# For complete usage instructions refer to the readme file included with the
# release zip archive.



# ----------
# Upgrade info
# ----------


# General instructions
# --------------------

# Updating should be as straight forward as replacing
# this file with the updated version from the new release and setting
# the few options in the configuration section (below)
# to values appropriate for your installation.

# (Note that the is no separate configuration file.)

# Please make note of any configuration setting before deleting the current
# version of the addin.


# Version specific update instructions:
# --------------------

# None.


# ----------
# Notes
# ----------

# If you are installing or upgrading this addin you should jump down to
# the short configuration section below.

# ----------

# The addin includes two interface routines:

# a. inventory_ping_response
# b. replace_discover_posts

# ----------

# The Indexette addin does three things:

# a. It traverses the site's content directory starting at the document root,
# bulding an index which includes
# an entry for every post file found.

# b. It reads the index rather than traversing the content directory to
# discover posts.

# The advantage in terms of performance is that although
# the content directory must be read to build the index, this only happens
# once, whereas without Indexette this happens
# for every request.

# c. Indexette helps preserve post dates by
# adding a tag to each post with the original modification time 
# when the file is created.

# Post dates can be updated by manually changing the date and time
# recorded in the tag or by deleting the tag altogether
# (which causes Indexette to add a new tag
# corresponding to the current modification time - which will most
# likely be now).


# THE CONFIG SECTION IS JUST BELOW


# ^ Info
# --------------
# v Beginning of source code


package Indexette_addin;

use Time::Local;

use strict;


our (
    $version,
);


my (
    $pri_index_file_name_f, $aux_index_file_name_f, $sync_mtime_with_tag_f, 
    $new_post_file_title_f, $new_post_file_body_f,
    $index_date_tag_f, $state_dir_name_f, $ffp_to_pri_file_f,
    $ffp_to_aux_file_f,
);


$version = "1.0";



# CONFIGURATION SECTION -----------------------------------------------------



# -------------
# New (Indexette created) post file title, $new_post_file_title_f
# -------------

# When the add_post parameter is used in combination with a request
# for a post that does not yet exist,
# Indexette will create a new post file at
# the specified path.

# For example

# If the request to create a new post is:

# 'http://sample.net/cgi-bin/ode.cgi/what/if/many/ \
#     levels/deep/and/then/some/new_post?add_post=y'

# and there is no corresponding post file at:

# $config::document_root/what/if/many/levels/deep/and/then/some/ \
# new_post.txt

# Indexette will attempt to create 'new_post.txt'.

# The value of this setting will be used as
# the title of that new post.

# If you would prefer that your new posts are initially empty,
# set the value of this variable to
# the empty string ""

# Keep in mind that if you do create empty posts, Ode will still behave
# as if the post exists (because it does exist).
# This means that your empty post could be returned along with
# other posts on the page returned to the client
# (assuming the post fits the request).

# This may not be what you want.


# For example

# Let's say that today you create a new entry for a post
# using the add_post parameter
# (before creating the post file itself).

# Furthermore, assume that this is
# the only post created today.


# In that case, the site will display:

# 1. A date line for the current day, because there is a post today
# (though it is empty).

# 2. A date line for the next day for which there is at least one post.

# 3. That days's posts.

# 4. A date line for the next day for which there is at least one post.

# 5., 6., 7., ... and so on ...

# Note that there appears to be no posts for the current day
# (1. in the list above). Why?

# Well, there is a post, but if that post is empty,
# so there is nothing to display.

# Also, you may see a the posts portion of the page._ theme
# file seemingly floating in space after that first date
# line. This doesn't indicate some problem with Ode or Indexette,
# it's just evidence of the empty post.

# To avoid this sort of ugliness, I recommend that you
# specify a placeholder title here.

# Important:

# The title of a post should be a single line at the start of the post
# file.

# The string you use here should be only
# a single line of text, and something that would be suitable
# as the title of a post.

# The title should not include an end of line character.
# Indexette will take care of adding the newline at the end of the
# title for you.

# (If you do include an end of line character, it will be removed.)


# Finally, if you use the empty string here,
# you will probably want to use the empty string as the value of
# $new_post_file_body_f (below) as well.

# If you leave this value blank but include a non-empty value
# for the next setting, the body,
# then the first line of $new_post_file_body_f
# will be the first line of the post file, and so it will become
# the title of your post (like it or not).


# You can avoid the issue of blank posts altogether simply by
# creating your post file first,
# before adding the post to the index
# using the add_post parameter.


# Default value:
# "New post in progress"

# Recommended value:
# n/a

# Example:
# $new_post_file_title_f = "New post in progress";
# $new_post_file_title_f = "";
# -------------

$new_post_file_title_f = "New post in progress";

# -------------


# -------------
# New (Indexette created) post file body, $new_post_file_body_f
# -------------

# When the add_post parameter is used in combination with a request
# for a post that does not yet exist,
# Indexette will create a new post file at
# the specified path.

# For example

# If the request to create a new post is:

# 'http://sample.net/cgi-bin/ode.cgi/what/if/many/ \
#     levels/deep/and/then/some/new_post?add_post=y'

# and there is no corresponding post file at:

# $config::document_root/what/if/many/levels/deep/and/then/some/ \
# new_post.txt

# Indexette will attempt to create 'new_post.txt'.


# The value of this setting will be used as
# the body of that new post.


# If you would prefer that your new posts are initially empty,
# set the value of this variable to
# the empty string ""

# Keep in mind that if you do create empty posts, Ode will still behave
# as if the post exists (because it does exist).
# This means that your empty post could be returned along with
# other posts on the page returned to the client
# (assuming the post fits the request).

# This may not be what you want.


# For example

# Let's say that today you create a new entry for a post
# using the add_post parameter
# (before creating the post file itself).

# Furthermore, assume that this is
# the only post created today.


# In that case, the site will display:

# 1. A date line for the current day, because there is a post today
# (though it is empty).

# 2. A date line for the next day for which there is at least one post.

# 3. That days's posts.

# 4. A date line for the next day for which there is at least one post.

# 5., 6., 7., ... and so on ...

# Note that there appears to be no posts for the current day
# (1. in the list above). Why?

# Well, there is a post, but if that post is empty,
# so there is nothing to display.

# Also, you may see a the posts portion of the page._ theme
# file seemingly floating in space after that first date
# line. This doesn't indicate some problem with Ode or Indexette,
# it's just evidence of the empty post.


# To avoid this sort of ugliness, I recommend that you
# specify a placeholder body here.

# Important:

# The body of a post is the content of a post after the first line.
# (The first line is the title).

# You can use any string you like. Just keep in mind that you will
# be replacing this placeholder content
# with the actual body of your post shortly (so you probably
# don't need to worry about this too much).

# You should _not_ include end of line characters at
# the start or end of the value you specify here.

# Indexette will take care of adding those for you.

# (If you do include an end of line characters at the start and end
# of the string, they will be removed.)


# Of course, unlike the title, the body of your post
# may consist of more than one line of text. You will need to
# add your own internal newline characters,
# if your body text consists of more than a single line.


# You can avoid the issue of blank posts altogether simply by
# creating your post file first,
# before adding the post to the index
# using the add_post parameter.


# Note I'm explicitly including a a break tag (<br />) in
# the default value.

# Why?

# To demonstrate that the included end of line character \n
# does position the text following it on the
# next line in the post file itself, but has no affect
# on how the text is displayed in a web browser.

# After all, HTML is a markup language right?
# We must tell it how to structure the content, using paragraph
# and break tags for example.

# Also, with the markdown addin installed I could have used two
# spaces before the newline sequence
# rather than <br /> and the affect would have been the
# same. Markdown interprets two spaces
# at the end of any line as a break, and handles the conversion.

# (But this would break when the Markdown addin is
# not installed.)


# Default value:
# "I'm working on it now.<br />\nCheck back soon."

# Recommended value:
# n/a

# Example:
# $new_post_file_body_f = "I'm working on it now.<br />\nCheck back soon.";
# $new_post_file_body_f = "";
# -------------

$new_post_file_body_f = "I'm working on it now.<br />\nCheck back soon.";

# -------------


# -------------
# Primary index file, $pri_index_file_name_f
# -------------

# After reindexing, the primary index file will contain an entry for
# every post on the site.

# Specify the name of the primary index file here.

# (Do not include path information.)

# Feel free to include a file extension if that will make things
# easier for you.

# For example appending the suffix '.txt',
# may make it easier to inspect and edit the index using a
# GUI text editor under Windows.


# Default value:
# 'primary_index_file'

# Recommended value:
# 'primary_index_file'

# Example:
# $pri_index_file_name_f = 'primary_index_file';

# -------------

$pri_index_file_name_f = 'primary_index_file';

# -------------


# -------------
# Auxiliary index file, $aux_index_file_name_f
# -------------

# New posts are added to the auxiliary index file to avoid the overhead of
# rebuilding the full index.

# (See the comments for $pri_index_file_name_f above.)

# Additionally, changes to post dates can be recorded to the
# aux index file
# for the same reason.

# When working through the index files to build the site
# in response to a visitor request, the auxiliary index is processed
# after the primary index.

# This ensures the latest (most recent) post dates are always
# included in response to the request.

# (Entries processed later override earlier entries.)


# For example, if the index-date is updated on
# an existing post, an entry for that post will already be included
# in the primary index.

# A new entry with the updated post date is recorded in the auxiliary
# index.

# When building the list of posts in response to a visitor request,
# first the primary index file is read
# and the original (out-of-date) post date is
# associated with the post.

# Next, an entry for the same post is encountered
# in the auxiliary index,
# and the new date replaces the old.

# The correct (up-to-date) post date is reported in the output.


# Specify the name of the auxiliary index file.

# (Do not include path information here.)

# Feel free to include a file extension if that will make things
# easier for you.

# For example appending the suffix '.txt'
# may make it easier to inspect and edit the index using a
# GUI text editor under Windows.


# Default value:
# 'aux_index_file'

# Recommended value:
# 'aux_index_file'

# Example:
# $aux_index_file_name_f = 'aux_index_file';

# -------------

$aux_index_file_name_f = 'aux_index_file';

# -------------


# -------------
# Sync file modification time with tag, $sync_mtime_with_tag_f (Boolean)
# -------------

# Indexette has two jobs:

# First, it creates an index (really two indexes, a primary and auxiliary),
# and redefines Ode's built-in discover_posts routine
# so that the script consults the index rather than traversing
# the filesystem to find a site's post files.


# Secondly, it tries to ensure post dates do not change unexpectedly.

# The idea is that the post date is the date (and time)
# when a post was first created.

# A post date is associated with each post file,
# and these dates determine the order in which posts are displayed on
# the page returned in
# response to client requests.

# Post dates are crucially important to how Ode operates.
# They should not change unintentionally, e.g. as
# a side effect of some minor edit.

# Of course it must be possible to change the post dates, but
# just as importantly,
# they should not change unexpectedly.


# Initially post dates are set to the modfication times of the post files.

# This should make sense, after all when the files are created,
# the modification time is the creation time, and
# that is the value we want. Unfortunately, these timestamps are updated
# whenever the file is modified
# (and that's almost certainly not what we want).

# To address this issue, Indexette
# not only maintains it's index(es), it also creates a tag
# for each post file with a value that
# serves as the post date.

# Intitially this 'index-date' is set to the post file's original
# modification time
# (i.e. the creation date).


# The addin consults this tag to determine
# the post dates to record to its indexes, only reverting to the use of
# file modification times
# when the index-date tag is missing.


# There are two benefits to this:

# 1. As already mentioned, post dates do not change every time
# a post file is modified. Instead, the post date
# must be explicitly modified by updating the value of the tag.

# 2. A site maintainer can conveniently update
# the post date by changing the value of the human readable
# index-date tag.

# This means that posts can easily be assigned
# arbitrary post dates.


# The $sync_mtime_with_tag_f option which allows the site maintainer
# to instruct Indexette to keep
# file modification timestamps in sync with
# the tag values.

# For example

# If the tag value is updated to an arbitrary date and time
# (something other than now) the modification timestamp
# of the file will be set to the date and time when the change was made
# because that was the time of the most recent modification.

# If the $sync_mtime_with_tag_f setting is true, the file's modification
# timestamp will be reset
# to once again agree with the tag value.


# Why is this useful?

# It means that if something happens to the tag (for example,
# if the tag is accidentally deleted), or if the
# site maintainer opts not to continue using Indexette,
# Ode will continue to behave normally, in the sense that posts will
# maintain their post dates.

# If this Boolean value of $sync_mtime_with_tag_f is false,
# the modification times on the files
# may drift considerably in relation to
# index-date values.

# Should the post date (i.e. the tag)
# suddenly become unavailable, the post dates may unexpectedly change
# (to seemingly incorrect dates).


# IMPORTANT

# The CGI user must own the post files in order
# to be able to change
# the file modification times.

# !Make sure you understand this point!

# Because of this restriction, the default value is false.


# This option is interpreted as a Boolean:

# 1 - (true),  The addin will attempt to synchronize post file modification
#              timestamps with Indexette's index-date
#              tag values.

# 0 - (false), The addin will not attempt to reset post file
#              modification timestamps.


# Default value:
# 0

# Recommended value:
# 1

# Example:
# $sync_mtime_with_tag_f = 0;

# -------------

$sync_mtime_with_tag_f = 0;

# -------------



# END CONFIGURATION SECTION -------------------------------------------------



# As is detailed in the project documentation, any addin that must
# save information related to its operation
# should write that data to a 'state' directory which is a subdirectory of
# $config::addin_state_dir

# Furthermore the addin state directory should be named after the
# addin itself.

# The idea here is to make it easy for users
# to identify which subdirectories of state are associated with what addins.

# The name of this addin file is:
# 'Indexette_addin'.

# This file is part of the 'Indexette' addin bundle.

# We want to save all of the Indexette files to the same state directory
# titled simply:

# 'Indexette'


# To accomplish this, we match
# everything preceding the underscore nearest to
# the beginning of the package name, e.g.

# (Indexette)_addin

# and store this at $state_dir_name_f.


# If the addin bundle happened to contain more than one addin file,
# we could use this same technique
# to set the name of the state directory
# for every addin file

# (Note: This assumes we begin each addin file name with
# a common base name, like 'Indexette'.)

($state_dir_name_f) = __PACKAGE__ =~ m/^([^_]+)/;


# Now that we have determined the Indexette bundle state directory
# and named the primary and auxiliary files
# (see the configurable variables section of this file),
# we can put together absolute paths to the
# primary and auxiliary index files.

# These files are each at:

# $config::addin_state_dir$state_dir_name_f

# We concatenate these paths, along with the file names for each
# of the indexes:

# $pri_index_file_name_f
# $aux_index_file_name_f


# Set the (f)ull (f)ilesystem (p)ath to the primary index file
# using File::Spec's catfile method:

# Refer to the Perl documentation for more information about
# 'File::Spec'
# http://perldoc.perl.org/File/Spec.html


# The purpose of the undef assignment is to
# make it clear that we will be setting the value of
# the variable for the first time now.

# The value of the variable should not be used,
# before this point in the execution of the script.

$ffp_to_pri_file_f = undef;

$ffp_to_pri_file_f =
    File::Spec->catfile($config::addin_state_dir, $state_dir_name_f, $pri_index_file_name_f);


# Set the (f)ull (f)ilesystem (p)ath to the auxiliary index file
# using File::Spec's catfile method:

# Refer to the Perl documentation for more information about
# 'File::Spec'
# http://perldoc.perl.org/File/Spec.html


# The purpose of the undef assignment is to
# make it clear that we will be setting the value of
# the variable for the first time now.

# The value of the variable should not be used,
# before this point in the execution of the script.

$ffp_to_aux_file_f = undef;

$ffp_to_aux_file_f =
    File::Spec->catfile($config::addin_state_dir, $state_dir_name_f, $aux_index_file_name_f);



# When installed and active, the Indexette addin should
# run for every request,
# because it has a job to do for every request.


# There are 4 cases we need to consider:

# 1. Only the 'reindex' parameter is included with request.
# 2. Only the 'add_post' parameter is included.
# 3. Both parameters are included.
# 4. Neither parameter is included.


# We've said that Indexette has a job to do in each of these cases.
# What specifically is Indexette's role for each?


# 1. Only the 'reindex' parameter is included with request.
# --------------------

# In this case, we want Indexette to discover posts in the usual way,
# by traversing the filesystem hierarchy.

# Why not just use Ode's default discover_posts routine?

# We could do this by have Indexette's inventory_ping_response() routine
# return 0 (false) in this case,
# essentially deactivating the addin.

# However, there are two reasons why we must use Indexette in this case.


# A. We need to consider that posts may include 'index-date' tags.

# Whenever a post includes one of these tags
# we want its post date to reflect the tag value, not the post file
# modification timestamp.

# So we can't just blindly read the file modification times, as would happen
# in the absence of the Indexette addin.


# B. For posts do not contain an 'index-date' tag, though we do
# want to read the file modification timestamp,
# we must convert the timestamp value to a human readable
# index-date and add an index-date tag to the post.


# Additionally, if the setting $sync_mtime_with_tag_f is true,
# the addin must update the post file modification
# timestamps whenever the reindex parameter is included with the request
# and the post contains an index-date tag with
# a value that differs from the post file timestamp value.


# When the reindex parameter is included with the request, the addin
# mimics Ode's own discover_posts routine
# in the sense that it too must traverse the filesystem hierarchy
# to discover post files,

# but the addin must do more than Ode's discover_posts routine, and so
# we can't simply use Ode's version
# (despite the overlap in functionality).


# We have a choice.

# A. We could use Ode's own discover post routine to
# find all posts with preliminary post dates that reflect the modification
# times of post files, and then
# open each file looking for the index date tag
# (and then continue on from there).

# OR

# B. We could find each post by traversing the directory Ode's
# content directories, duplicating much of
# the behavior of Ode's discover_posts routine.

# (It would be a big head start to copy ode::discover_posts
# rather than starting from scratch.)

# Rather than read the modification timestamps from the post files
# in every case, as Ode's discover_posts does, Indexette's
# replacement routine would read each file first,
# looking for index-date tags as it goes,
# and then use either the index-date value, if the tag exists,
# OR resort to the file modification timestamp.


# There are advantages and disadvantages with each option.


# Option A

# Advantages

# Using Ode's discover_posts routine has the significant advantage
# that changes to the built-in routine will automatically
# be picked up by Indexette.

# It's also easier to code (with less chance for error).


# Disadvantages

# It is less efficient than the other option.

# Ode's discover_posts routine involves a relatively costly,
# in terms of performance, stat request in order
# to retrieve the modification time for every post on the site,
# even though it's reasonable to assume that
# the vast manjority of these posts (as many as all of them),
# already have a index-date,
# making those system calls unnecessary.

# It's important to keep in mind that this only applies
# when we are reindexing the site. We do not do this for the
# more typical visitor requests which
# will not include the reindex parameter.


# Option B

# These advantages and disadvantages are just the opposite
# of what they were with option A.

# If we reimplment Ode's discover_posts routine here, so that
# we do not get the file modification
# timestamps unless we need to, the routine should be
# more efficient.

# However, it will take longer to write, and more importantly, improvements
# made to Ode's discover_posts
# will not automatically carry over.

# We will need to update Indexette every time Ode's own discover_posts
# routine is updated.

# (This assumes the changes are beneficial, but why else would we update the
# routine in ode.cgi?)


# Either way we want to delete the primary and aux index files and
# rewrite them based on the hash of all posts.

# We don't actually read the indexes when the reindex parameter is requested, 
# because the goal is to rebuild the index
# based on current post date values (not the previously determined
# values represented in the indexes.)

# Also, in either case, if I don't find an 'index-date' tag we
# need to write one out to the file.

# This should mean that a tag is written the first time a post is added
# to the index, which will be right after the post is created,
# (after all the post won't appear on the site until the post is added to the index).

# Considering the limited amount of time between when the post is
# written and when it is first indexed,
# the file modification time should prove to be suitable
# to use as starting post date.


# 2. Only the 'add_post' parameter is included.
# --------------------

# This parameter only makes sense to use for post type requests.

# If this is a post type request, the addin assumes that the post
# corresponding to the requested page is
# the one being added to the index (or updated if
# the page already exists in the index).

# An entry for that post file is added to the end of the aux index file.


# The addin needs to look for a index-date tag, just as is done
# when the reindex parameter is used.

# If there is an index-date tag, Indexette must convert
# the human readable index-date tag value to
# a modification timestamp type date value, and write that date
# to the aux index file.


# If there isn't a index date-tag, then the addin must
# read the file modification timestamp,
# and record that value to the auxiliary index.

# It also needs to write an index date tag to the file based on the
# modification timestamp.

# Again, this is the same thing that happens when the reindex parameter
# is included, except that with add_post
# we are only processing a single post file,
# not all of the posts on the site
# (which is what happens with reindex).


# If this is not a post type request, there is no way for Indexette to know
# which post it is supposed to act on.

# So, the addin spits out an error message notifying the user
# of the issue and then ignores the parameter,
# treating this like a request that does not include either parameter
# (case 4).


# Note: If a request is made for a post that does not yet exist,
# Indexette will attempt to create a new post file at the path corresponding
# to the requested page.

# Assuming the Indexette is able to create this post file successfully,
# the addin treats the request like any other
# add_post request.


# More about how this case works...

# We add an entry to the auxiliary index for the post being added,
# and then run the discover_posts routine
# as we normally would with the Indexette addin when neither
# the add_post nor the reindex parameter is included
# (case 4).

# Because we add the updated value first, the discover_posts routine
# will find an entry for the new post
# waiting in the aux file,
# along with entries for every other post.


# Technically we can probably get away with ignoring other posts entirely
# for case 2.

# Since this must be a request for a single post,
# the resulting page will display only this one post, and all of the
# others are irrelevant (and so excluded).

# However, in practice that seems like a sloppy (and dishonest)
# way to do things, and it may cause problems
# at some point in the future. If for example we want to add a post while,
# at the same time, taking some other action.


# 3. Both parameters are included.
# --------------------

# When both parameters are included, the add_post parameter is redundant.

# Reindexing affects all posts, including the post targeted
# by the add_post parameter.

# The add_post parameter can be ignored and this case
# can be treated just like case 1.


# 4. Neither parameter is included.
# --------------------

# In this case the replace_discover_posts routine
# reads the primary and auxiliary
# index files to populate the hash of all posts.

# We don't need to look for index date tags because
# the tag values are already reflected
# in the post dates stored in the indexes.

# This is the easiest and most efficient case,
# which is a good thing because it should also be by far
# the most common case.

# This is a 'normal' visitor request.

# All of the other cases are
# something more like 'control' or 'command' type requests.



# ----------
# ADDIN INTERFACE: inventory_ping_response
# ----------

# Each addin file must include an inventory_ping_response routine.

# (inventory_ping_response is the only required routine)


# Parameters: 0
# ---------

# none


# Return values: 1
# ---------

# 1. A Boolean true or false value.

# true : An addin's inventory_ping_response routine
# returns true when the addin should be
# considered active.

# !All of it's other routines given the opportunity to run!


# false : A return value of false indicates that the addin should be 
# considered inactive.

# !All of its other addin routines will be skipped!


# Precisely how and for what reason it is determined that
# an addin's inventory_ping_response routine
# returns true or false is entirely dependent on the unique nature
# of the addin itself.


# An addin which should always be run whenever it is installed,
# regardless of request, may include
# a very simple inventory_ping_response routine
# which always returns true.

# For example, the following is a
# perfectly valid inventory_ping_response() routine
# for an addin which should
# always run without exception.


# sub inventory_ping_response {
#   1;
# }


# Other inventory_ping_response routines may be
# quite a bit
# more complicated.


sub inventory_ping_response
{

    # As has already been discussed in the comments above
    # we want Indexette run for every request.
    
    # This means that Indexette's inventory_ping_response routine
    # should always return true
    # (just like the simple example used above).

    # This means that as long as Indexette is installed
    # and not disabled
    
    # (removed from the addins directory or disabled
    # in place be appending an underscore
    # to the end of the addin bundle or addin file's title),

    # the addin will be active affect the behavior of
    #the script.

    return 1;
}


# ----------
# ADDIN INTERFACE: replace_discover_posts
# ----------

# As the name suggests, a replace_discover_posts routine
# takes the place of the discover_posts routine
# built into the cgi itself. 

# Because of this,

# !a replace_discover_posts routine's interface
# must be _identical_ to that of
# ode::discover_posts!


# There can only be one discover_posts routine defined at any one time,
# i.e. for any single execution of the program.
# If there is more than one addin installed implementing a
# replace_discover_posts type routine,
# the first encountered replaces the built-in routine,
# and all of the other replace_discover_posts routines are ignored.

# (The order the routines are encountered is
# determined by addin bundle prefixes
# and the sort order established by the addins_sort subroutine).


# Parameters: 0
# ---------

# none


# Return values: 1
# ---------

# The return value is a reference to a hash of all posts such that
# each _key_ in the hash is the absolute path
# from the root of the filesystem to a single post file,
# and the corresponding _value_ is a post date in
# timestamp format.


# Remember that the built-in discover_posts() routine
# traverses the file system hierarchy startng at the site's document root
# looking for post files.


# Generally speaking, Indexette's replace_discover_posts routine
# reads the primary and auxiliary index files
# generated by the addin to create the same hash of ALL posts.

# Of course there is more to it than that
# because the addin must also

# - generate the indexes,
# - create and then monitor its 'index-date' tag,
# - and more.


sub replace_discover_posts
{
    my (
        $ffp_to_post_unixtime_hrs, %ffp_to_post_unixtime_hs,
        $post_date_prelim_s, $post_date_finalized_s, $ffp_to_added_post_s,
        $added_post_mod_time_s,
    );


    # In the description of the operation of the addin that preceded
    # the inventory_ping_response routine (above)

    # I discussed 4 separate cases the addin must address.

    # ----------
    # 1. Only the 'reindex' parameter is included with request.
    # ----------
    # 2. Only the 'add_post' parameter is included.
    # ----------
    # 3. Both parameters are included.
    # ----------
    # 4. Neither parameter is included.
    # ----------

    # In order to do what we need to do efficiently we won't go through
    # these cases in the order listed above.

    # Also, as we will see, there is some otherlap related to
    # each of these.

    # With this in mind, before we can get started on case 1,
    # we have preparatory work to do
    # related to the add_post parameter.


    # Whenever the add_post parameter is included as part of
    # an appropriate request (e.g. the request must name
    # a specific post), we must check to see if the requested post
    # file already exists.

    # a. If it does, an entry for that post is added to the auxiliary index
    # file.

    # b. If the post file does not exist,
    # the routine creates a new placeholder post, and then
    # an entry is added to the auxiliary index.


    # When both the reindex and add_post parameters are included (case 3),
    # we want an entry for the added_post to exist
    # before we come across the code that is responsible for
    # the reindex behavior.
    
    # This way, reindex can treat
    # the added post file like all of the post
    # files on the site.

    # This requires that we act on the add_post parameter first.

    # Think of this conditional clause as
    # something like 1/2 of
    # the behavior that defines
    # case 2.


    if ( $ode::req_query_string_components_final{add_post} )
    {

        my (
            @ffp_to_dirs_created_l,
        );


        # In order for the add_post mechanism to work,
        # the submitted URL must include the name of the post being
        # added to the index.

        # So, in this case the script starts by looking at the
        # $ode::req_filename variable
        # which should contain the name of the post requested,
        # assuming that this is indeed a request for a specific post and
        # not a category (or index) request.


        # For example, if an author just created a post with the name
        # 'new_post' in the directory 'some_category'
        # at the root of the weblog:

        # That URL might look something like:

        # http://sample.net/cgi-bin/ode.cgi/some_category/new_post.html


        # To add the post to the index using the add_post parameter
        # (i.e. w/o completely reindexing)
        # the requested URL must be something like:

        # http://sample.net/weblog/some_category/new_post?add_post

        # The addin depends on the variable:

        # $ode::req_filename

        # to determine what post to add and where.


        # By the way, given the request above, the values of these variables
        # would be:

        # $ode::req_filename == 'new_post'
        # $ode::req_fs_path_wo_file ==
        #    '/Library/WebServer/Documents/ode_site/some_category/'

        # (This assumes the Ode document root
        # $config::document_root
        # is: '/Library/WebServer/Documents/ode_site')


        # Again, in order to add a post with add_post this way,
        # $ode::req_filename must not be undefined,
        # (i.e. ?add_post must accompany a request for a post,
        # not a category, or index request).

        if( $ode::req_filename )
        {

            # Assuming this is a request for a single post -something that
            # can be 'added' to the index- the addin builds up
            # a full path to the file corresponding to the post and checks
            # for a file at that path.

            # The parameter accomplishes two (2) different but related
            # tasks.

            # 1. If the post does not exist at all,
            # Indexette will create
            # an empty post file, and add an entry for the new post
            # to the auxiliary index file.

            # 2. If the post already exists, Indexette will
            # re-examine the post date,
            # first looking for an index-date tag before resorting to
            # using the post file modification time.

            # It will also add a new entry to the auxiliary index
            # with whatever is determined to be
            # the correct post date.


            # First we check to see if there is already a file at
            # the requested path.


            # If there isn't, Indexette will attempt to create it.

            # On the other hand, if there is a file matching the request,
            # we skip this step.


            # The upcoming conditional asks the question:

            # Does anything exist, i.e. any directory
            # entry whatsoever,

            # with the same name, and
            # at the same path as to the post file

            # we have been asked to add.

            # (The directory entry may not be a plain text file.)

            # !(-e (($ffp_to_added_post_s ...


            # (Note that we are handling the assignment of the value to
            # $ffp_to_added_post_s and the file test
            # in the same expression, which is perfectly OK to do.

            # The assignment happens first so that the
            # variable will have the intended value, and then
            # that value is passed to the -f test.)


            # Whereas -f would test whether or not that named directory
            # entry is a plain file,
            # -e tests for the existance of a directory
            # entry (any directory entry)
            # matching the filename specified.


            # Refer to the Perl documentation for more info about
            # these file tests
            # http://perldoc.perl.org/functions/-X.html


            # Inside of this conditional block, the routine
            # attempts to create a new post file
            # at the specified path, $ffp_to_added_post_s.


            # If there is _anything_ at the requested path
            # we do not want to make that attempt.


            # If that something is a file (something we
            # do not check for here) then the post we are adding
            # would already exist, and
            # the add_post parameter may have been used
            # to update the post date

            # (or if the post date has not changed then this may be
            # a pointless request).


            # If that something is not a file then we won't know
            # what it is or what, if any,
            # purpose it serves. The only safe thing we can do
            # is leave it alone, (which means that
            # we won't be able to add the requested post.)


            # Regardless of whether the directory entry is a plain
            # file or something else,
            # we'll deal with that issue elsewhere
            # (in the else clause).


            # Here we are only concerned about whether
            # there is _anything_ with the name of the post file
            # we have been asked to add,
            # and at the same path.

            # If there is not, the conditional expression will evaluate
            # as true, and execution will proceed into
            # the if block, where, as has already been said,
            # we will attempt to create a new post file.

            # Otherwise, the block will be skipped.



            if ( !(-e (($ffp_to_added_post_s = "$config::document_root$ode::req_fs_path_wo_file$ode::req_filename.$config::post_file_ext"))) )
            {

                my (
                    $working_path_l, $created_first_new_dir_l,
                    $ffp_path_to_post_wo_file_l,
                    $filename_l, $found_path_to_post_intact_l,
                    $path_from_doc_root_to_post_l, @path_components_l,
                    $problem_creating_path_or_post_l,
                );


                # $created_first_new_dir_l is a Boolean
                # variable the value of which starts out false and
                # is true only after we successfully create
                # the first directory in the path leading to the
                # new post file.

                # Because it makes sense conceptually to do so,
                # we explicitly set the value of
                # $created_first_new_dir_l
                # to false.

                # We haven't created the first new
                # directory in the path leading to the new post file
                # before we have started.

                $created_first_new_dir_l = 0;


                # $problem_creating_path_or_post_l is a Boolean which
                # starts out false and is assigned
                # a true value only if we run into some sort of
                # problem which prevents us from creating a new post file
                # (when asked to add a post that does not yet exist
                # e.g. if we are unable to create
                # the complete path to the post, or the
                # post itself).


                # Again, we explicitly set an initial value here
                # because it makes conceptual sense.

                # We haven't failed to create a post file before we try.
                
                $problem_creating_path_or_post_l = 0;


                # If there is no file (and also
                # no other directory entry - whatever may be)
                # corresponding to the name and path
                # provided, we attempt to create
                # a new post file, by opening
                # a new file at $ffp_to_added_post_s
                # attached to the filehandle NEW_POST.


                # OK?

                # BUT Before we do that, there is another bit of business
                # we need to take care of.


                # Though open will create the file
                # if it does not exist,

                # !it will not create the path leading to the file!

                # We need to take care of that explicitly
                # before we attempt to write the new post file,
                # or else the attempt will fail
                # whenever the complete path does not
                # already exist.


                # $ffp_to_added_post_s is the full file system path
                # leading to the new post file.

                # (We already know that either the file does not
                # exist or some portion of the path
                # leading to the file and the file does
                # not exist.)

                # Using a pattern match we separate the string
                # at $ffp_to_added_post_s
                # into two parts:

                # 1. The path leading to the file
                # 2. The file itself

                # For example, if the request to create a new post file
                # is:

                # 'http://sample.net/cgi-bin/ode.cgi/what/if/many/ \
                #     levels/deep/and/then/some/new_post?add_post=y'


                # And the path from the root of the filesystem to
                # Ode's document root is:

                # '/Library/WebServer/Documents/ode_site'


                # The path leading to the file will be:

                # '/Library/WebServer/Documents/ode_site \ 
                #     /what/if/many/levels/deep/and/then/some/'

                # and the file itself:

                # 'new_post.txt'

                # This example assumes the post file extension
                # (set in Ode's config file) is
                # the default value, 'txt'.


                # The purpose of the undef assignment is to
                # make it clear that we will be
                # setting the value of the variable
                # for the first time now.

                # The value of the variable should not be used,
                # before this point
                # in the execution of the script.

                $ffp_path_to_post_wo_file_l = $filename_l = undef;

                ($ffp_path_to_post_wo_file_l, $filename_l) = $ffp_to_added_post_s =~ m!^(.*/)([^/]*)$!;


                # Now that we have the path, we check to see if the
                # leading to the post exists.

                # (We have already determined that the post we have
                # been asked to add does not exist,
                # but the path to the post may be there.)

                # First we'll check to see if there is any directory entry
                # at the target path.

                # Whereas -d would test whether or not the specified
                # entry is a directory, -e tests for
                # the existance of a filesystem directory entry
                # (any entry) matching the string at
                # $ffp_path_to_post_wo_file_l.


                # Refer to the Perl documentation for more info about
                # these file tests
                # http://perldoc.perl.org/functions/-X.html

                if (-e $ffp_path_to_post_wo_file_l)
                {

                    # Having determined that there is something at
                    # $ffp_path_to_post_wo_file_l, we use
                    # the -d test to confirm that the something is
                    # a directory (or not).

                    # Note the use of Perl's special _ symbol, which
                    # reuses the stat structure
                    # returned from the most recent system call
                    # (-d just above).

                    if (-d _)
                    {
                        # The the path leading to the post is already
                        # complete, we don't need to worry
                        # about creating the path to the post, and
                        # we can move on to dealing with
                        # the post file itself.

                        $found_path_to_post_intact_l = 1;
                    }

                    else
                    {
                        # If there is something at the path to the
                        # post, but that something is
                        # not a directory, it will not be possible
                        # to create the post we have been
                        # asked to add.

                        # In this case, we notify the user of the issue
                        # and abandon our attempt
                        # to add the post.


                        # $warn_level_l, and $resp_level_l are
                        # used to name the warning level
                        # and response level values that are passed to the
                        # handle_warning_and_response() routine.

                        # The purpose is to highlight these values, and
                        # make it more obvious what's happening in
                        # the call to the routine.

                        # The values are compared to the user configurable
                        # $config::warning_threshold.

                        # Whenever the level passed to the routine
                        # meets or exceeds the threshold
                        # value, the corresponding warning and response is
                        # generated.

                        # Typically warnings are output to the server logs
                        # and responses are included as
                        # part of the page
                        # returned to the visitor.

                        # (Refer to the handle_warning_and_response subroutine
                        # definition for more information.)

                        { # Naked block

                            my ($warn_level_l, $resp_level_l,);

                            $warn_level_l = $ode::min_error_level +1;
                            $resp_level_l = $ode::min_error_level +1;

                            &ode::handle_warning_and_response (
                                "Indexette : replace_discover_posts",

                                "Cannot add post file at:\n" .
                                "$ffp_to_added_post_s\n" .
                                "There is a conflict at: ",
                                    "$ffp_path_to_post_wo_file_l.\n" .
                                "This issue must be resolved " .
                                    "before the post can be added.\n",

                                "Attempt to add post failed. " .
                                    "(See error log for details.)\n",

                                $warn_level_l, $resp_level_l
                            );

                        } # End, Naked block


                        # $problem_creating_path_or_post_l is a Boolean
                        # which starts out false and is assigned
                        # a true value only if we run into some sort of
                        # problem which prevents us from creating
                        # a new post file (when asked to add a post
                        # which does not yet exist e.g. if we are unable
                        # to create the complete path to the post,
                        # or the post itself).

                        # Here, the problem is that we have found something
                        # at the path leading to the post we have been
                        # asked to add, but that something is
                        # not a directory.

                        # For now we'll just make note of the issue.
                        # Elsewhere we can use the value of
                        # the Boolean as to determine if there is
                        # a problem and act accordingly.

                        $problem_creating_path_or_post_l = 1;

                    } # End, else

                } # End, if (-e $ffp_path_to_post_wo_file_l)


                # @ffp_to_dirs_created_l is an array in which
                # we squirrel away the list of
                # directories we have successfully created
                # in our attempt to build a path
                # to the new post file.

                # If we run into some sort of problem
                # which prevents us from creating the new post
                # successfully we can use this list
                # to 'unwind' the directory structure.


                # The purpose of the empty assignment is to
                # make it clear that we will be
                # setting the value of the variable
                # for the first time now.

                # The value of the variable should not be used,
                # before this point
                # in the execution of the script.

                @ffp_to_dirs_created_l = ();


                if (!$found_path_to_post_intact_l and !$problem_creating_path_or_post_l)
                {

                    # In this block we attempt to construct
                    # the path to the post
                    # we have been asked to add.

                    # If we found the complete path to the post
                    # intact:
                    
                    # $found_path_to_post_intact_l,

                    # OR
                    
                    # we have determined that there is some problem
                    # with the path:
                    
                    # $problem_creating_path_or_post_l,

                    # We skip this block - because there is no point
                    # in attempting to build the path to
                    # the post if the path already exists, or we
                    # have already determined that
                    # we will be unsuccessful.

                    # The conditional expression insists that both
                    # conditions are not true.

                    # Assuming that is the case,
                    # or we would not be here (i.e. execution would have
                    # skipped this block),
                    # we need to work through the path
                    # to the post.


                    # Continuing with the same example,
                    # notice that the first four components of the path
                    # are not categories, but instead are
                    # collectively the path to Ode's
                    # document root.

                    # '/Library/WebServer/Documents/ode_site'


                    # There is no question that this part of the path
                    # exists.

                    # (If the document root doesn't exist,
                    # it's Ode's problem
                    # to deal with, not Indexette's.)

                    # We can avoid some needless work
                    # if we focus on the other elements of the request.

                    # To do that we'll extract the string consisting
                    # of just the subpath starting
                    # at the document root,
                    # and store this value at:

                    # $path_from_doc_root_to_post_l.


                    # We can accomplish this with Perl's substr operator.

                    # Using substr we skip length
                    # $config::document_root number of characters at
                    # the start of $ffp_path_to_post_wo_file_l,
                    # assigning the rest to the variable to
                    # $path_from_doc_root_to_post_l


                    # substr EXPR,OFFSET,LENGTH

                    # Refer to the Perl documentation for more info about
                    # 'substr'
                    # http://perldoc.perl.org/functions/substr.html


                    # The purpose of the undef assignment is to
                    # make it clear that we will be
                    # setting the value of the variable
                    # for the first time now.

                    # The value of the variable should not be used,
                    # before this point
                    # in the execution of the script.

                    $path_from_doc_root_to_post_l = undef;

                    $path_from_doc_root_to_post_l = substr( 
                           $ffp_path_to_post_wo_file_l,
                           length $config::document_root );


                    # It's not enough to create the entire path at once.

                    # Returning to the same example
                    # used above, if the complete path to the
                    # post file we're adding is:

                    # '/Library/WebServer/Documents/ode_site \ 
                    #     /what/if/many/levels/deep/and/then/some/'


                    # and the 'what' subdirectory at the site's document
                    # root does not exist
                    # (which of course means subdirectories of 'what'
                    # cannot exist), we can't create
                    # the directory:

                    # # '/Library/WebServer/Documents/ode_site \ 
                    #     /what/if/many/levels/deep/and/then/some/'

                    # Because the parent of the directory 'some',
                    # the last directory, does not exist.
                    # Also, the parent of the parent of 'some', which is
                    # 'and' in our example, does not exist,
                    # and so on.


                    # We must build up the path one level at a time,
                    # starting with the first directory
                    # that does not exist, closest to the root,
                    # and then adding them as we go,
                    # until we've completed the path leading to
                    # new_post (or until we run into
                    # some problem that prevents us from proceeding
                    # further.)

                    # In order to do this, we'll first split
                    # the string representing the path starting at Ode's
                    # document root (just assigned to
                    # $path_from_doc_root_to_post_l), into a list
                    # of it's component elements using
                    # Perl's split function.

                    # We assign the resulting list to @path_components_l.


                    # The purpose of the empty assignment is to
                    # make it clear that we will be
                    # setting the value of the variable
                    # for the first time now.

                    # The value of the variable should not be used,
                    # before this point
                    # in the execution of the script.

                    @path_components_l = ();

                    @path_components_l = split(/\//, $path_from_doc_root_to_post_l);


                    # Note that the value at $path_from_doc_root_to_post_l
                    # will include _both_
                    # a leading and trailing forward slash, '/'.

                    # Consider for example, the path:

                    # '/dir1/dir2/dir3/'

                    # Splitting on the leading slash,

                    # '' / 'dir1'
                    # '' split 'dir1'

                    # results in the pair:

                    # (1) ''
                    # (2) 'dir1'


                    # Splitting on the trailing slash,

                    # 'dir3' / ''
                    # 'dir3' split ''

                    # results in two values:

                    # (1) 'dir3'
                    # (2) ''

                    # The default behavior of split is to return leading
                    # empty members of the list resulting from split
                    # but omit trailing empty values.

                    # Continuing with the example from above:

                    # '/dir1/dir2/dir3/'

                    # results in the following list:

                    # ('', 'dir1', 'dir2', 'dir3')

                    # We need to shift off the first empty value
                    # to get the list of directories we want:

                    # The conditional, guarantees that
                    # we do not unintentionally shift away the first
                    # legitimate directory in our path.

                    # (This test is probably unnecessary,
                    # because the path should always start with a leading
                    # path delimiter, but
                    # better safe than sorry.)

                    shift @path_components_l
                        if @path_components_l[0] eq '';


                    # Next we'll construct a path to each directory
                    # in turn, starting closest to the root,
                    # attempting to create each of the intermediate
                    # directories, building up the path to
                    # the new file level-by-level.

                    # To do this, we need to create a working path
                    # beginning with
                    # $config::document_root.


                    # Using a foreach loop we'll:

                    # - Append the next element of the path,
                    # - Create that next directory,
                    # - Repeat.


                    # There is one other thing we need to consider.


                    # Let's say the path is 25 levels deep and 24 levels
                    # in we run into some sort of issue which
                    # prevents us from finishing, or maybe after we
                    # construct the full path successfully
                    # we find that we're unable to create the post file
                    # at the end of the process.

                    # It would be sloppy to leave those empty directories
                    # resulting from failed attempts to
                    # create a post file that does not exist.

                    # (Over time this could add up to
                    # any number of unused, empty directories.
                    # At best this would be confusing, and it may even
                    # cause problems at some point.)


                    # To avoid this situation, we want to remove
                    # any directories we created in
                    # the process of attempting to add the new post file,
                    # whenever we are unable to successfully
                    # create the post.

                    # The question is, how can we do this (easily)?


                    # We'll save the string representing the path
                    # to each directory in a list
                    # as we go.

                    # If, at any point before the new post has
                    # been created, we cannot continue,
                    # we clean up after ourselves by removing
                    # (i.e. deleting) the directories in the list,
                    # one at a time.

                    # Undoing the changes made in the failed attempt
                    # to add the new post file is a simple
                    # matter of looping through the list
                    # in order and deleting each of the directories
                    # in turn.

                    # (There are any number of other ways to handle it.
                    # I don't believe any of them are
                    # more efficient.)


                    # $working_path_l is always the path to the directory
                    # we are attempting to create now,
                    # in the process of building out the path
                    # to the new file.

                    # $working_path_l begins with $config::document_root,
                    # and each time through the upcoming loop
                    # we append the next element of the path to the
                    # requested new file.


                    # The purpose of the undef assignment is to
                    # make it clear that we will be
                    # setting the value of the variable
                    # for the first time now.

                    # The value of the variable should not be used,
                    # before this point
                    # in the execution of the script.

                    $working_path_l = undef;


                    # The working path starts with $config::document_root,
                    # which as the name suggests,
                    # gives us the path to Ode's document root.

                    $working_path_l = $config::document_root;


                    # The value of $config::document_root
                    # will not include a trailing path
                    # delimiter, so we tack one on before
                    # continuing.

                    $working_path_l .= '/';


                    foreach my $component_l (@path_components_l)
                    {

                        # As has already been discussed, each time through
                        # the loop we append the next element
                        # of the path.

                        # Keep in mind that the elements in
                        # @path_components_l
                        # are the names of path components only - without
                        # path info.


                        # Because we've created this collection by
                        # splitting the original path
                        # to the new file at the path delimiter,
                        # we know that these names
                        # will not include the delimiters.

                        # So, we add a trailing delimiter to
                        # each working path in preparation for the
                        # next itration of the loop.


                        # Returning to the example we've been working with
                        # (from above), if the original path
                        # to the request new file is:

                        # '/Library/WebServer/Documents/ode_site \ 
                        #     /what/if/many/levels/deep/and/then/some/'

                        # The first time through the loop
                        # $working_path_l will be:

                        # '/Library/WebServer/Documents/ode_site/what/'

                        # The second time through the loop,
                        # the path will be:

                        # '/Library/WebServer/Documents/ode_site/what/if/'

                        # and so on.

                        $working_path_l .= "$component_l/";


                        # Using the -d file test, we check to see if the
                        # this portion of the path
                        # leading to the new post file
                        # already exists.

                        # If it does, we just want to run the loop again,
                        # appending the next directory
                        # and repeating our check.


                        # $created_first_new_dir_l is a Boolean
                        # variable the value of which starts out false and
                        # is true only after we successfully create
                        # the first directory (previously missing)
                        # in the path leading to the
                        # new post file.

                        # We use it to avoid the overhead of file
                        # tests like -d, which require
                        # a relatively costly system call

                        # (costly in terms of resources and performance).


                        # After we create the first directory in the path
                        # we know that directory,
                        # and any others we might need
                        # along the same path, will be empty.

                        # (It cannot contain anything,
                        # because it did not exist until we just created
                        # it - and a nonexistent directory
                        # must be empty.)

                        # This means that we can forgo
                        # the -d test, and other file tests
                        # like this, for every directory
                        # after the first.


                        # _or_ is a short-circuited logical operator.

                        # The value of an expression containing
                        # two subexpressions joined with an
                        # _or_ operator is true whenever one, the other,
                        # or both parts of the expression are true.

                        # So, if the first subexpression is true,
                        # the 2nd does not need to be evaluated at all.

                        # Because $created_first_new_dir_l
                        # appears first, it is considered
                        # before the other part of the compound
                        # expression, and if true,
                        # the 2nd expression is skipped.

                        # If we have already created the first new
                        # directory, we don't check to see
                        # if the directory represented by the current
                        # working path already exists.

                        if( $created_first_new_dir_l or !(-d $working_path_l) )
                        {

                            # If the directory _does not_ exist,
                            # we'll try to create it.

                            # Before we do, for safety's sake, we'll check
                            # to make sure that there is not
                            # something else, whatever it might be,
                            # at that path.

                            # If there isn't any filesystem directory
                            # entry at the working path
                            # we'll attempt to create this part of
                            # the path.

                            # If there is something else already there
                            # we stop what we're doing
                            # to avoid overwriting something we should not
                            # or causing any other problems.


                            # As we did above we check
                            # the value of $created_first_new_dir_l
                            # first.

                            # To be clear, here we're not
                            # trying to determine if the value of
                            # $created_first_new_dir_l
                            # if true.

                            # The value will not have changed from
                            # what it was just above.


                            # Instead we're shielding the second
                            # subexpression from being
                            # evaluated when $created_first_new_dir_l
                            # was used to short-circuit
                            # the evaluation of the compound conditional
                            # expression above.

                            # !This is critical given the use of
                            # the special filehandle _!


                            # Note the use of Perl's special _ symbol,
                            # which reuses the stat structure
                            # returned from the most recent system call
                            # (-d just above).


                            # The trick is understanding that
                            # when $created_first_new_dir_l is true
                            # only the first part of
                            # the conditional expression is evaluated.

                            # Because !(-d $working_path_l) is not
                            # evaluated, the last stat structure will not
                            # be related to $working_path_l,
                            # or at least not the current value of
                            # that variable.

                            # If we used the underscore symbole (_) below
                            # without protecting it with
                            # $created_first_new_dir_l,
                            # we don't know what -e _ would be testing.

                            # (That test would tell us if something
                            # exists, but we wouldn't know with certainty
                            # what that something is.)


                            # Whereas the use of the Boolean above
                            # had to do with efficiency,
                            # it is used here out of necessity..


                            # $created_first_new_dir_l is a Boolean
                            # variable the value of which starts out
                            # false and is true only after we
                            # successfully create the first directory
                            # in the path leading to the new
                            # post file.

                            # (For more info, see the comments
                            # preceding the conditional
                            # just above.)

                            if ( $created_first_new_dir_l or !(-e _) )
                            {

                                # If there isn't any filesystem directory
                                # entry at the working path
                                # we attempt to create
                                # this part of the path.

                                # (i.e. we attempt to create
                                # a directory at
                                # $working_path_l.)


                                # Ode allows the site maintainer to
                                # override the the default mask
                                # that would normally be applied when
                                # determining the permissions
                                # for this directory.

                                # Perl's mkdir function allows us to
                                # use a custom mask value.


                                # We check the Boolean $config::set_umask.

                                # A true value indicates that
                                # the site maintainer prefers to use
                                # the custom mask value
                                # specified in $config::umask.


                                # We use Perl's ternary operator to choose
                                # between two different invocations
                                # of mkdir.

                                # If true, the call is

                                # mkdir( $working_path_l, $config::umask)

                                # which includes the custom mask
                                # $config::umask

                                # If false, we omit the custom mask
                                # and the call is:

                                # mkdir($working_path_l).

                                # which excludes the custom mask.


                                # If you're unfamiliar with the
                                # ternary operator, this ex
                                # from the perlop documentation may
                                # help you to understand how
                                # the operator works.

                                # $a = $ok ? $b : $c;

                                # If $ok is true then $b (and not $c)
                                # is evaluated with the
                                # result of $b returned to $a.

                                # Otherwise, if $ok is false,
                                # then $c (and not $b) is evaluated
                                # with the result of $c
                                # returned to $a.

                                if( $config::set_umask ? mkdir($working_path_l, $config::umask) : mkdir($working_path_l) )
                                {

                                    # If we were able to make the 
                                    # directory for this part
                                    # of the path leading to the new file,
                                    # we need to add the string 
                                    # representing this path to the list
                                    # we're accumulating
                                    # at @ffp_to_dirs_created_l.

                                    # If we are eventually unable to
                                    # complete the path to
                                    # the new file, or if we can't create
                                    # the file itself, we'll use
                                    # this list to cleanup
                                    # by removing the directories we
                                    # created before we failed.

                                    @ffp_to_dirs_created_l =
                                        $working_path_l;


                                    # Also, the first time we successfully
                                    # create a new directory
                                    # along the path leading to the
                                    # new post, we want to
                                    # assign the Boolean
                                    # $created_first_new_dir_l
                                    # a true value.

                                    # We use this variable to skip
                                    # the relatively expensive file tests
                                    # (e.g. -d, -e) elsewhere.

                                    # Once we know that we are creating
                                    # the path  as we go,
                                    # we know its not possible for
                                    # there to be any conflicting
                                    # directory entries (because each new
                                    # directory will be empty
                                    # before we it.)


                                    # We use a conditional expression
                                    # to set this value only
                                    # one time.

                                    # As soon as the value is true,
                                    # it will never be false again, and
                                    # there is no reason to
                                    # repeatedly assign the same value
                                    # each time through the loop.

                                    $created_first_new_dir_l = 1
                                        if ! $created_first_new_dir_l;

                                } # End, if( $config::set_umask ? mkdir ...

                                else
                                {
                                    # If we are unable to create the
                                    # directory, then we need to
                                    # deal with the issue.

                                    # For now we'll just note that
                                    # we were not able to
                                    # successfully create the path,
                                    # and then deal with
                                    # the resulting issues
                                    # elsewhere in the routine.

                                    # $problem_creating_path_or_post_l
                                    # is a Boolean which starts out
                                    # false and is assigned
                                    # a true value only if we run into
                                    # some sort of problem
                                    # which prevents us from creating a 
                                    # new post file when asked
                                    # to add a post that does not yet
                                    # exist. (e.g. if we are
                                    # unable to create the complete
                                    # path to the post,
                                    # or the post itself).

                                    $problem_creating_path_or_post_l = 1;

                                } # End, else

                            } # End, if ( $created_first_new_dir_l or ...

                            else
                            {
                                # If the directory we are attempting to
                                # add cannot be created because
                                # there is already something else
                                # (not a directory) at the path,
                                # we report the issue and do nothing.

                                # We cannot create a path that includes
                                # an intermediate component
                                # which is something other than a 
                                # directory, so we abandon the attempt to
                                # add the new post.


                                # $warn_level_l, and $resp_level_l are
                                # used  to name the warning level
                                # and response level values
                                # that are passed to the
                                # handle_warning_and_response()
                                # routine.

                                # The purpose is to highlight these
                                # values, and make it more
                                # obvious what's happening in the
                                # call to the routine.

                                # The values are compared to the user 
                                # configurable
                                # $config::warning_threshold.

                                # Whenever the level passed to the
                                # routine meets or exceeds the threshold
                                # value, the corresponding warning
                                # and response is generated.

                                # Typically warnings are output to
                                # the server logs and responses
                                # are included as part of the page
                                # returned to the visitor.

                                # (Refer to the
                                # handle_warning_and_response
                                # subroutine definition
                                # for more info.)

                                { # Naked block

                                    my ($warn_level_l, $resp_level_l,);

                                    $warn_level_l =
                                        $ode::min_error_level +1;

                                    $resp_level_l =
                                        $ode::min_error_level +1;

                                    &ode::handle_warning_and_response (

                                        "Indexette : replace_discover_posts",

                                        "Cannot create directory:\n" .
                                        "$working_path_l\n" .
                                        "while attemptig to create new " . 
                                            "post:\n" .
                                        "$ffp_to_added_post_s\n" .
                                        "Something -not and dir- already " .
                                            "exists at that path\n" .
                                        "The new post file can't be " .
                                            "added.\n" .
                                        "You must correct this issue " .
                                            "before add_post will " . 
                                            "succeed\n" .
                                        "System msg:\n" .
                                        "$!\n",

                                        "Unabled to create path to " .
                                            "new post. (See error log " .
                                            "for details.)\n",

                                        $warn_level_l, $resp_level_l
                                    );

                                } # End, Naked block


                                # For now we'll just note that we were not
                                # able to successfully create
                                # the path, and then deal
                                # with the resulting issues elsewhere
                                # in the routine.

                                # $problem_creating_path_or_post_l is a
                                # Boolean which starts out false
                                # and is assigned a true value only if we
                                # run into some sort of problem
                                # which prevents us from creating a
                                # new post file when asked to
                                # add a post that does not yet exist.
                                # (e.g. if we are unable to create
                                # the complete path to the post, or the
                                # post itself).

                                $problem_creating_path_or_post_l = 1;

                            } # End, else

                        } # End, if( $created_first_new_dir_l or !(-d ...


                        # If the directory already exists, we skipped
                        # the if block above.

                        # We don't need to create this part of the path
                        # leading to the new file
                        # (because it already exists).

                        # There is nothing to do but repeat the loop.


                        # If we ran into some problem on this
                        # iteration of the loop, e.g if we were unable to
                        # create to create one or another of the
                        # intermediate directories along the path to
                        # the post because of a permissions
                        # or a conflict with an already existing
                        # directory entry, the value of
                        # the variable

                        # $problem_creating_path_or_post_l
                        # will be true.

                        # In that case, because it has already determined
                        # that we will be unable to complete
                        # the path and create the new post file,
                        # there is no point in continuing
                        # with this loop.

                        # We break out of the loop with last rather than
                        # continuing on to the next iteration.

                        last if $problem_creating_path_or_post_l;


                    } # End, foreach my $component_l (@path_components_l)


                } # End, if (!$found_path_to_post_intact_l and !$problem_creating_path_or_post_l)


                if ($problem_creating_path_or_post_l)
                {

                    # In the loop above we worked through the path leading
                    # to the post to be added.

                    # This may have involved creating many
                    # directories, if the post is deeply nested
                    # and the entire path, or much of it,
                    # leading to the post did not exist before
                    # the request.

                    # Alternatively, we may have done nothing at all
                    # if the complete path the the post
                    # we are adding was already in place before
                    # we started.


                    # If we are unable to create the directory
                    # we need to
                    # deal with the issue.

                    # More specifically, there are two
                    # things we need to do.


                    # 1. We emit a notification alerting
                    # the site maintainer
                    # of the issue using Ode's
                    # handle_warning_and_response
                    # routine.


                    # 2. Because we have failed to create
                    # the full path to the
                    # new post file, we need to undo
                    # any work already done,
                    # to clean up after ourselves,
                    # by removing whatever partial path
                    # we've built out before
                    # now.


                    # The warning and response is easy enough,
                    # so let's deal with that first.


                    # $warn_level_l, and $resp_level_l are
                    # used  to name the warning level
                    # and response level values
                    # that are passed to the
                    # handle_warning_and_response()
                    # routine.

                    # The purpose is to highlight these
                    # values, and make it more
                    # obvious what's happening in the
                    # call to the routine.

                    # The values are compared to the user 
                    # configurable
                    # $config::warning_threshold.

                    # Whenever the level passed to the
                    # routine meets or exceeds
                    # the threshold value,
                    # the corresponding warning and
                    # response is generated.

                    # Typically warnings are output to
                    # the server logs and responses
                    # are included as part of the page
                    # returned to the visitor.

                    # (Refer to the
                    # handle_warning_and_response
                    # subroutine definition
                    # for more info.)

                    { # Naked block

                        my ($warn_level_l, $resp_level_l,);

                        $warn_level_l =
                            $ode::min_error_level +1;

                        $resp_level_l =
                            $ode::min_error_level +1;

                        &ode::handle_warning_and_response (
                            "Indexette : replace_discover_posts",

                            "Cannot make dir:\n" .
                            "$working_path_l\n" .
                            "while attemptig to create new " . 
                                "post:\n" .
                            "$ffp_to_added_post_s\n" .
                            "Removing any partial path " .
                                "to cleanup.\n" .
                            "The new post file can't be " .
                                "created:\n" .
                            "You must correct this issue " .
                                "before add_post will " . 
                                "succeed\n" .
                            "System msg:\n" .
                            "$!\n",

                            "Unabled to create path to " .
                                "new post. (See error log " .
                                "for details.)\n",

                            $warn_level_l, $resp_level_l
                        );

                    } # End, Naked block


                    # That takes care of alerting the user,
                    # but we still must disassemble
                    # the path we've already created,
                    # being careful to remove only directories
                    # created just now, as part of the
                    # process of attempting to create the path
                    # to the new post file.

                    # Luckily for us, we have a list of
                    # the absolute paths to directories created as
                    # part of the process of trying to
                    # construct the path to the new post file
                    # at:

                    # @ffp_to_dirs_created_l.


                    # Important:

                    # We need to remove the directories
                    # in the reverse of the
                    # order in which
                    # they were created.

                    # This is because we can only remove
                    # empty directories,
                    # and a directory is not empty
                    # even if it only contains other empty
                    # directories.


                    # Let's say that we successfully created
                    # two directories before
                    # we ran into some sort of issue.

                    # 1. '/Library/WebServer/Documents/ \ 
                    # ode_site/what/'

                    # 2. '/Library/WebServer/Documents/ \ 
                    # ode_site/what/if/'

                    # This will be the order of the strings 
                    # representing those paths
                    # in the array

                    # @ffp_to_dirs_created_l.


                    # We need to remove them in the opposite
                    # order.

                    # At first, we cannot remove '../what/'
                    # because it contains
                    # '../what/if/'.

                    # Working backward, we can remove
                    # '../if/' first,
                    # because it is empty,
                    # and then '../what/', because that
                    # directory will be empty
                    # now that 'if/' has been removed.


                    # If we couldn't create this directory,
                    # we won't be able to create
                    # a child of this directory (this
                    # directory must exist first).


                    # Note that @ffp_to_dirs_created_l may be
                    # an empty list.

                    # If the list is empty the loop will be skipped.
                    # That's perfectly OK.

                    while (@ffp_to_dirs_created_l)
                    {

                        my (
                            $directory_to_remove_l,
                        );

                        $directory_to_remove_l =
                            pop @ffp_to_dirs_created_l;

                        if ( !(rmdir $directory_to_remove_l) )
                        {

                            # $warn_level_l, and $resp_level_l
                            # are used to name the warning
                            # level and response level values
                            # that are passed to the
                            # handle_warning_and_response()
                            # routine.

                            # The purpose is to highlight
                            # these values, and make it
                            # more obvious what's happening
                            # in the call to the routine.

                            # The values are compared to the
                            # user configurable
                            # $config::warning_threshold.

                            # Whenever the level passed to the
                            # routine meets or exceeds
                            # the threshold value,
                            # the corresponding warning and
                            # response is generated.

                            # Typically warnings are output to
                            # the server logs and responses
                            # are included as part of the page
                            # returned to the visitor.

                            # (Refer to the
                            # handle_warning_and_response
                            # subroutine definition
                            # for more info.)

                            { # Naked block

                                my ($warn_level_l, 
                                    $resp_level_l,);

                                $warn_level_l =
                                    $ode::min_error_level +1;

                                $resp_level_l =
                                    $ode::min_error_level +1;

                                    &ode::handle_warning_and_response 
                                (
                                    "Indexette : replace_discover_posts",

                                    "Cannot remove " .
                                        "directory:\n" .
                                    "$directory_to_remove_l\n" .
                                    "while attempting " .
                                        "clean up " .
                                        "from failed " .
                                        "attempt to " .
                                        "add post:\n" .
                                    "$ffp_to_added_post_s\n" .
                                    "This dir and of its " . 
                                        "ancestors must be " .
                                        "removed manually\n" .
                                    "System msg:\n" .
                                    "$!\n",

                                    "Unable to clean-up " .
                                        "completely from " .
                                        "failed attempt " .
                                        "to add post. " .
                                        "(See error log " .
                                        "for details.)\n",

                                    $warn_level_l, $resp_level_l
                                );

                            } # End, Naked block


                        } # End, if ( !(rmdir $director ...


                        # As soon as we are unable to delete
                        # one of the directories we
                        # created for some reason, we know
                        # that we can't remove of its
                        # ancesters (because they will
                        # not be empty).

                        # So we cut the loop short with last.

                        last;

                    } # End, while (@ffp_to_dirs_created_l)


                } # End, if ($problem_creating_path_or_post_l)

                else
                {
                    # Assuming there hasn't some problem creating
                    # the path to the post we are adding
                    # (which is handled in the if clause above)
                    # we move turn our attention to
                    # the post file itself.

                    # Remember that we have already determined
                    # there is no file (or other filesystem entry) at
                    # path where we are attempting to create the
                    # new post file.
                    
                    # (So, we can safely open the file
                    # at this point without worrying about
                    # overwriting existing data.)

                    if ( open (NEW_POST, ">> $ffp_to_added_post_s") )
                    {

                        # We're creating a brand new post file here
                        # because we were asked to add a post
                        # with the add_post parameter and the corresponding
                        # post file did not exist.

                        # What should the contents of this file be?

                        # We could create a new empty file.

                        # One problem with that, among possibly others,
                        # is an empty post may look strange
                        # when displayed on the page returned to the
                        # visitor.

                        # Instead Indexette provides two user configurable
                        # variables, which allow the site maintainer
                        # to write their own placeholder content:
                        
                        # $new_post_file_title_f
                        # $new_post_file_body_f

                        # Obviously enough,
                        # $new_post_file_title_f will be the title
                        # of the new post
                        # and $new_post_file_body_f 
                        # the body text.


                        # The title of any post is simply the first line
                        # of the post file.

                        # The description of $new_post_file_title_f
                        # specifies that the string
                        # should not include the trailing newline
                        # character.

                        # (We'll explicitly add that as we write
                        # to the new post file.)

                        # In order to enforce that rule, we'll check for
                        # the end of line character
                        # at the end of the value of $new_post_file_title_f
                        # and remove any we find.

                        # To do this we'll use Perl's substitution operator.

                        # Refer to the Perl documentation for more
                        # information about
                        # the substitution operator (s///)

                        # http://perldoc.perl.org/ \
                        # perlop.html#Regexp-Quote-Like-Operators

                        if ($new_post_file_title_f ne '')
                        {
                            $new_post_file_title_f =~ s/\n+$//;
                        }


                        # The body of the a post is everything after the
                        # title.

                        # The description of $new_post_file_title_f
                        # specifies that the string
                        # should not include leading or trailing
                        # end of line characters at the beginning and end
                        # of the string.

                        # (We'll explicitly add that as we write
                        # to the new post file.)

                        # Of course internal newlines should be allowed
                        # because the body of the post could,
                        # and most likely will, consist of more than
                        # a single line.

                        # Just like we did with the title, we'll handle this
                        # using the substitution operator.


                        # Refer to the Perl documentation for more
                        # information about
                        # the substitution operator (s///)

                        # http://perldoc.perl.org/ \
                        # perlop.html#Regexp-Quote-Like-Operators

                        if ($new_post_file_body_f ne '')
                        {

                            # Unlike with the title, here we want to
                            # account for both leading and
                            # trailing newlines.

                            # Though this could just as easily be done
                            # with a single statement,
                            # we'll deal with it in two instead.

                            # Why?

                            # It's consistent with what we've already done
                            # and so easier for people new to
                            # Perl to follow along.

                            # Also, This may be the more efficient
                            # way to do it. Though I could be wrong about
                            # that, it's almost certainly not
                            # less efficient.

                            # Note: It's important to not that '^' and '$'
                            # anchor the pattern to the beginning
                            # and end of the entire string as a whole.

                            # Internal newlines will not be matched.

                            # If we wanted to do that, we would use the
                            # /m option like:

                            # $new_post_file_body_f =~ s/^\n+//m;

                            # The /m option puts Perl's regular expression
                            # engine in 'multiline mode',
                            # which changes the behavior so that
                            # the anchors '^' and '$'
                            # match internal newlines as well.

                            # # Refer to the Perl regex documentation
                            # for more info about '/m' and other
                            # regular expression options
                            # http://perldoc.perl.org/functions/-X.html

                            $new_post_file_body_f =~ s/^\n+//;
                            $new_post_file_body_f =~ s/\n+$//;
                        }


                        # Now that we've cleaned up the title and body
                        # strings, we just need to
                        # print them to the new post file.

                        # Notice that we add two blank lines
                        # separating the title
                        # from the body, creating a little visual
                        # separation.

                        # (This is where the tag block will go as soon
                        # as we add a first tag.)

                        print NEW_POST "$new_post_file_title_f\n\n$new_post_file_body_f\n";


                        # With that single statement we're done writing
                        # to the new post file.

                        # To be tidy we close the filehandle, and
                        # we're finished with
                        # this part of the routine.

                        close NEW_POST;

                    } # End, if ( open (NEW_POST, ">> $ffp_to_added_post_s") )

                    else
                    {
                        # If we could not successfully create the new
                        # post file at $ffp_to_added_post_s
                        # (i.e. if the attempt to open the filehandle
                        # NEW_POST in append mode associated
                        # with $ffp_to_added_post_s failed)
                        # then we have some work to do in order
                        # to take care of the issue.

                        # Actually, there isn't much to do.

                        # We can't create the post and so the post doesn't
                        # exist.

                        # Later in the routine when we check to see if
                        # the post exists (before adding an
                        # entry to the auxiliary index file etc.),
                        # it won't be there.

                        # That means that we won't act on the nonexistent
                        # file, which is good.

                        # All we need to do here then is 
                        # notify the user using
                        # Ode's handle_warning_and_response routine.


                        # $warn_level_l, and $resp_level_l are used
                        # to name the warning level and response level values
                        # that are passed to the
                        # handle_warning_and_response() routine.

                        # The purpose is to highlight these values, and
                        # make it more obvious what's happening in the call
                        # to the routine.

                        # The values are compared to the user configurable
                        # $config::warning_threshold.

                        # Whenever the level passed to the routine
                        # meets or exceeds the threshold
                        # value, the corresponding warning and response is
                        # generated.

                        # Typically warnings are output to the server logs
                        # and responses are included as part of the page
                        # returned to the visitor.

                        # (Refer to the handle_warning_and_response subroutine
                        # definition for more information.)

                        { # Naked block

                            my ($warn_level_l, $resp_level_l,);

                            $warn_level_l = $ode::min_error_level +1;
                            $resp_level_l = $ode::min_error_level +1;

                            &ode::handle_warning_and_response (
                                "Indexette : replace_discover_posts",

                                "Cannot add post.\n" .
                                "$ffp_to_added_post_s\n" .
                                "The post file does not exist and can't be " .
                                    "created:\n" .
                                "$!\n" .
                                "You must correct this issue before " .
                                    "add_post will succeed\n",

                                "Cannot add_post. Post does not exist and " .
                                    "cannot be created.\n",

                                $warn_level_l, $resp_level_l
                            );

                        } # End, Naked block

                    } # End, else

                } # End, else

            } # End, if ( !(-e (($ffp_to_added_post_s = "$config::document ...

            else
            {
                # If there is already something else at the requested
                # path, maybe the post file we have been
                # asked to add, or something else (a directory
                # for example), we do not want to attempt
                # to create a file, because we don't want to unintentionally
                # overwrite whatever that something is.

                # Most likely the something is a post file.

                # After all, we know this is: 

                # - a directory entry,

                # - under Ode's document root,

                # - ending with the user configurable
                # post file extension.


                # If this is the post we've been asked to add,
                # there is nothing else to do here.

                # (We don't want to create the file again.)

                # The file exists, and we will find
                # waiting later in the routine
                # when we add an entry to the auxiliary index file.

                # But, what if this something is _not_ a file?

                if ( !(-f _) )
                {

                    # Note the use of Perl's special _ symbol,
                    # which reuses the stat structure
                    # returned from the
                    # most recent system call.

                    # This is the more efficient thing to do, BUT
                    # we need to be sure we know what
                    # what _ is referencing.

                    # What was the most recent system call?

                    # Notice that we are just inside an else clause.
                    # How did we get here?

                    # If you look back you'll find that we
                    # are here because we failed
                    # the codition:

                    # if ( !(-e (($ffp_to_added_post_s = ...

                    # That -e file test is that last thing that would have
                    # happened whenever execution finds its
                    # way to this secruib of the code.

                    # So the stat structure we're dealing with is
                    # associated with $ffp_to_added_post_s,
                    # with is the absolute path to
                    # the post file being added (and just
                    # what we want).


                    # if (! -f _)
                    # is true

                    # and
                    
                    # if (! -e $ffp_to_added_post_s)
                    # is false,

                    # We know that something exists where we want
                    # to add the requested post,
                    # and that something is not a file,


                    # We do not want to attempt to create a post file
                    # in this case because we don't want to
                    # risk disturbing the filesytem entry at the
                    # requested path (whatever is it).


                    # Instead we simply make the user
                    # aware of the issue (which must be manually resolved
                    # before Indexette can create a
                    # new post file at specified path and
                    # add it to the index).


                    # $warn_level_l, and $resp_level_l are used
                    # to name the warning level and response level values
                    # that are passed to the
                    # handle_warning_and_response() routine.

                    # The purpose is to highlight these values, and
                    # make it more obvious what's happening in the call
                    # to the routine.

                    # The values are compared to the user configurable
                    # $config::warning_threshold.

                    # Whenever the level passed to the routine
                    # meets or exceeds the threshold
                    # value, the corresponding warning and response is
                    # generated.

                    # Typically warnings are output to the server logs
                    # and responses are included as part of the page
                    # returned to the visitor.

                    # (Refer to the handle_warning_and_response subroutine
                    # definition for more information.)

                    { # Naked block

                        my ($warn_level_l, $resp_level_l,);

                        $warn_level_l = $ode::min_error_level +1;
                        $resp_level_l = $ode::min_error_level +1;

                        &ode::handle_warning_and_response (
                            "Indexette : replace_discover_posts",

                            "Cannot add post.\n" .
                            "$ffp_to_added_post_s\n" .
                            "There is already something else (not a file) " .
                                "at the requested path\n" .
                            "You must correct this issue before " .
                                "add post will succeed\n",

                            "Cannot add post. There is already something " .
                                "else (not a file) at the path.\n",

                            $warn_level_l, $resp_level_l
                        );

                    } # End, Naked block

                } # End, if ( !(-f _) )

            } # End, else

        } # End, if( $ode::req_filename )


        else
        {
            # If $ode::req_filename is not defined
            # the new (undefined) post
            # cannot be added (because the addin has no way of knowing
            # which post to add).


            # We generate a warning and response in the usual way,
            # with ode::handle_warning_and_response
            # and Ode's replace_discover_posts routine
            # continues.


            # ( If the reindex parameter is also included, the routine will
            # go on to discover posts by traversing
            # Ode's content hierarchy starting
            # at the document root, and
            # building the primary index file.

            # If the reindex parameter is missing, the routine will
            # read the primary and auxiliary indexes
            # discovering posts that way.

            # In either case there will be no new post
            # because the user, i.e. the person
            # who submitted the request
            # did not specify what that post should be. )


            # $warn_level_l, and $resp_level_l are used
            # to name the warning level and response level values
            # that are passed to the
            # handle_warning_and_response() routine.

            # The purpose is to highlight these values, and
            # make it more obvious what's happening in the call to the
            # routine.

            # The values are compared to the user configurable
            # $config::warning_threshold.

            # Whenever the level passed to the routine
            # meets or exceeds the threshold
            # value, the corresponding warning and response is generated.

            # Typically warnings are output to the server logs
            # and responses are included as part of the page returned
            # to the visitor.

            # (Refer to the handle_warning_and_response subroutine
            # definition for more information.)

            { # Naked block

                my ($warn_level_l, $resp_level_l,);

                $warn_level_l = $ode::min_error_level +1;
                $resp_level_l = $ode::min_error_level +1;

                &ode::handle_warning_and_response (
                    "Indexette : replace_discover_posts",

                    "add_post parameter included with requested URI but\n" .
                    "cannot add post, because the URI does not " .
                        "target a post.\n" .
                    "add_post must accompany a post type request\n",

                    "add_post requested but no post specified " .
                        "(check the address).\n",

                    $warn_level_l, $resp_level_l
                );

            } # End, Naked block

        } # End, else

    } # End, if ( $ode::req_query_string_components_final{add_post} )


    # This is the end of the preparation we must do if the add_post parameter
    # is included as part of the request.

    # In summary
    
    # If the post we are adding _did not exist_,
    # we created a new post file, along with the path to the post if
    # necessary.

    # If the post _already existed_, we have essentially
    # done nothing to this point.

    # That's a lot code to do nothing. 

    # At least it won't cost us anything in terms of performance.

    # (When the post already exists, it will all be skipped.)


    # Now we work through the 4 cases which were
    # first discussed at the top of
    # the replace_discover_posts routine:

    # 1. Only the 'reindex' parameter is included with request.
    # 2. Only the 'add_post' parameter is included.
    # 3. Both parameters are included.
    # 4. Neither parameter is included.


    # Remember that we may have just created a new post file.


    # ( This happens when:

    # 1. The add_post parameter is included with the request.
    # 2. The post file did not already exist.

    # Note: This must be a request for a specific file.

    # It also assumes that we did not encounter a problem
    # preventing the file from being created. )


    # If we did add a new file,
    # we want to be sure it will be properly included with
    # each of these 4 cases.


    # First realize that only 2 of these four cases apply.

    # Case 2. Only the 'add_post' parameter is included.
    # Case 3. Both parameters are included.

    # If the add_post parameter is not included
    # as part of the request, then we could not have just added
    # a new post file.


    # Case 2. When only the add_post parameter is included
    # in the request, we'll need to add an entry for the the new post file
    # to the auxiliary index.


    # Case 3. In the case that both parameters are included
    # the behavior of the reindex
    # takes precedence over
    # the behavior of the add_post parameter.

    # _Whenever_ the reindex parameter is included
    # as part of the request, both the existing indexes are
    # discarded and a new primary index file is rebuilt
    # by looking at the post files directly.

    # Because we have already created a new post file,
    # the routine will find it,
    # and write an entry for the post being added to the primary index,
    # along with entries for
    # all of the other post files.


    # So, at this point, it looks like we're in good shape,
    # at least as far as any
    # newly created post files are
    # concerned.

    # Let's get back to the first case.


    # 1. Only the 'reindex' parameter is included with request.

    if ($ode::req_query_string_components_final{reindex})
    {

        # We start by using Ode's discover_posts routine
        # (aka discover_posts_baked_in)
        # to build up the usual hash of all posts,
        # where each _key_ in the hash is
        # the full file system path to some post,
        # and the corresponding _value_ is the post file's
        # modification timestamp.

        # For the purposes of the Indexette addin, this value is
        # considered a

        # 'preliminary' post date.

        # It will be the final post date
        # _only if_ there is no 'index-date' tag contained
        # in the post file.


        # (Note: &ode::discover_posts_baked_in's
        # return value is
        # a hash reference.)

        $ffp_to_post_unixtime_hrs = &ode::discover_posts_baked_in();


        # $ffp_to_post_unixtime_hrs will contain zero or more
        # key/value pairs.

        # What if the hash reference
        # returned from  &ode::discover_posts_baked_in
        # is empty?

        # (i.e. What if there are no posts?)


        # There are two explanations.
        
        # 1. There are no posts.

        # 2. There are posts but &ode::discover_posts_baked_in
        # was unable to
        # find them for some reason

        # Because it is valid that there may be no posts,
        # we do not consider
        # an empty hash as an error.

        # It is treated like any other request.

        # (An error in &ode::discover_posts_baked_in
        # should be handled by
        # &ode::discover_posts_baked_in
        # itself.)


        # Because we are reindexing the site, we must rebuild the
        # primary index file.

        # We must also delete the auxiliary index file - because
        # all posts will be included in the primary index
        # when we're done.


        # In this case, we don't care about the values
        # contained in the index files.

        # The goal is to recreate the index
        # based on current post dates (either index-date tag values or
        # file modification times),
        # replacing the current values,
        # whatever they may be.


        # We start by attempting to open a write mode filehandle
        # connected to the primary index file.

        # If this is successful, the existing file will be overwritten, 
        # effectively deleting the previous primary index
        # (which is what we want).


        # Keep in mind that this only affects the index file,

        # !not the posts themselves!

        # If the routine runs into some sort of snag,
        # it is possible that posts
        # might seem to disappear from the site.

        # This is only because Indexette is reading its indexes
        # to find the posts and there may not be
        # entries in the index (for one or more post files)
        # when there is a problem.

        # The posts themselves will be unaffected.


        # If we can't open the primary index file, there is nothing else
        # useful that we can do.


        # A reindex request is primarily concerned with
        # rebuilding the index. We can't do that if something is
        # preventing us from writing to
        # the index file.


        # The question is,
        
        # "What should we return to the caller?"

        # (which expecting a reference to a hash of all posts
        # with accurate post dates).


        # We could return the same
        # $ffp_to_post_unixtime_hrs returned from
        # &ode::discover_posts_baked_in.

        # The problem is that the post dates are likely to be wrong.

        # This is because Ode's discover posts routine
        # does not know about
        # Indexette's 'index-date' tags.


        # Instead, we could try to recover accurate post dates by
        # examining the post files, looking for an index-date tag and
        # updating the post dates in the hash of all posts
        # at $ffp_to_post_unixtime_hrs, the way we would normally.

        # But that's a lot of work, and for what purpose?

        # For a reindex request, it's not so much important that posts
        # are displayed on the page returned in response to the
        # request.
        
        # In this case, we're primarily concerned about
        # updating the index, so that it,
        # not the page displayed in the browser,
        # is accurate.

        # But we can't do that because we can't write to the index file.


        # So, rather than return:
        
        # A. a hash with incorrect post dates, or
        
        # B. Accurate post dates which do not reflect the content of the
        # index
        
        # we return an empty hash.


        # This way, we're not doing more work that is justifiable, and
        # we're not returning a misleading value
        # (a collection of posts with improper post dates.)


        # Keep in mind that this affects ONLY the reindex request.

        # Because all requests are independent, 
        # visitors to the site will still see the site and it's content
        # as it looked before the failed reindex
        # attempt.


        # We also generate a warning and response message,
        # alerting the user of the issue.


        if ( !(open(PRIMARY_INDEX, "> $ffp_to_pri_file_f")) )
        {

            # $warn_level_l, and $resp_level_l are used to name
            # the warning level and response level values that are passed to
            # the handle_warning_and_response() routine.

            # The purpose is to highlight these values, and
            # make it more obvious what's happening in the call to the
            # routine.

            # The values are compared to the user configurable
            # $config::warning_threshold.

            # Whenever the level passed to the routine
            # meets or exceeds the threshold
            # value, the corresponding warning and response is generated.

            # Typically warnings are output to the server logs
            # and responses are included as part of the page returned
            # to the visitor.

            # (Refer to the handle_warning_and_response subroutine
            # definition for more information.)

            { # Naked block

                my ($warn_level_l, $resp_level_l,);

                $warn_level_l = $ode::min_error_level +1;
                $resp_level_l = $ode::min_error_level +1;

                &ode::handle_warning_and_response (
                    "Indexette : replace_discover_posts",

                    "The Index has not been updated.\n" .
                    "Attempting to create primary index file " .
                        "during reindex failed.\n" .
                    "Check path and permissions.\n" .
                    "The site is exactly as it was before " . 
                        "the reindex attempt\n" .
                    "(including all posts and post dates).\n" .
                    "System error message:\n" .
                    "$!\n",

                    "The primary index file could not be created. " .
                        "(See error log for details.)",

                    $warn_level_l, $resp_level_l
                );

            } # End, Naked block


            # As already discussed, we want to return an empty hash.

            # Though there are several ways we could do this,
            # we explicitly empty the hash at
            # $ffp_to_post_unixtime_hrs,
            # and return the (now empty) hash as we usually
            # would.

            %$ffp_to_post_unixtime_hrs = ();

            return $ffp_to_post_unixtime_hrs;

        } # End, if ( !(open(PRIMARY_INDEX, "> $ffp_to_pri_file_f")) )


        # Assuming we are able to successfully open
        # the primary index file (or we would have
        # returned before now), we have the complete collection of posts
        # returned from  &ode::discover_posts_baked_in
        # in the hash at:

        # $ffp_to_post_unixtime_hrs.

        # Each _key_ in the hash is the full path to some post
        # from the root of the filesystem, and the
        # corresponding _value_ is a preliminary post date,
        # which is actually the file modification time
        # from each post file.


        # We have not yet checked the content of the file looking for a
        # 'index-date' tag.

        # (Remember that if there is an index-date tag,
        # we want to replace this
        # preliminary post date value with
        # the date value from the tag.)


        # We loop through the hash of posts.

        # Foreach entry we call the negotiate_index_dates() routine
        # passing it the full path to the post,
        # and the prelimininary date.

        # That routine is responsible for reading the post file,
        # determining if there is a index-date tag,
        # and returning the appropriate modification time,
        # which will be either the tag value or, if there is no tag,
        # the same value passed to the routine.

        # The tag value is always preferred.


        # negotiate_index_dates also performs several other related tasks:

        # - It will write the index-date tag to the post file
        # if it doesn't find one.

        # - It must parse the index-date tag and convert the human readable
        # date value to the sort of timestamp value
        # that we need to be stored in the $ffp_to_post_unixtime_hrs
        # hash.

        # - Lastly, if there is a index-date, the routine will optionally
        # attempt to sync the file modification time
        # so that it agrees with the tag value.


        # The return value from negotiate_index_dates is the finalized
        # post date, which will be either the same date
        # passed to the routine -if there is no index-date tag
        # or if the index-date tag value is
        # the same as the the date from the file modification timestamp-
        # or an updated value, if there is an index-date
        # with a different different value.


        # We save this finalized value back to the hash
        # $ffp_to_post_unixtime_hrs.


        # There are a couple of things to know about what is/what is not
        # happening here.

        # 1. We are not yet writing to the index file.

        # We want to build the index in sorted order according to post
        # dates, and at this point we don't have
        # finalized dates.

        # If we looped through the hash in sorted order here,
        # first calling negotiate_index_dates()
        # to update the post dates, and then writing an entry to the index
        # file for each post, those index entries
        # would have the correct value BUT they would not be
        # in the proper order.

        # The order would reflect only the preliminary post date
        # values.


        # We won't have all of the finalized values until after we loop
        # through the hash of all posts once.

        # So, we'll need a second loop to actually create our index.


        # 2. We do not employ a sort as part of this loop.

        # Because the collection of all posts is maintained as a hash,
        # and there is no reliable ordering of a hash,
        # we don't know in what order each pair of the hash will be
        # processed.
        
        # But that's unimportant at this point.

        # We will need to sort the posts as they are written to the index.


        # Presorting them here would accomplish nothing.
        
        # Because we write the entries back to the hash, any order
        # we attempt to impose would be lost.

        # (Even if that were not an issue a sort would be
        # unhelpful because we don't have the
        # values we would want to base the sort on.)


        # Note:
        
        # It is true that there is a 'natural' order to every hash,
        # which is whatever Perl determines to be
        # the most efficient representation.

        # But there is no way for us to know what this order is
        # ahead of time, and even if we did,
        # it's not useful to us because it's not the order we want,
        # and it's unreliable in the sense that
        # the order will change whenever Perl deems it necessary.


        # The purpose of the undef assignment is to make it clear
        # that we will be setting the value of the variable
        # for the first time now.

        # The value of the variable should not be used,
        # before this point in the execution of the script.

        $post_date_finalized_s = $post_date_prelim_s = undef;


        foreach my $ffp_to_post_l (keys %$ffp_to_post_unixtime_hrs)
        {

            # This addin includes a helper routine,

            # &negotiate_index_dates,

            # which is responsible for managing post dates.


            # More specifically:

            # The routine preserves file modification times as a tag
            # within the posts themeselves.

            # (See Ode's documentation for more info about tags.)

            # These 'index-date' tags protect against
            # post dates inadvertently changing whenever the file is modified
            # in some way. (Such changes always update
            # the modification timestamp).


            # If there _is_ a index-tag tag already associated with a given
            # post, &negotiate_index_dates
            # converts the human readable date value from the tag
            # to a unix timestamp value

            # (like the mtime values return from stat).


            # If there _is not_ an index-date tag associated with
            # current post, the routine takes care of
            # adding the tag, which involves not only writing the tag
            # line to the post, but also converting the
            # timestamp value to a more human readable format.


            # Finally, &negotiate_index_dates can be used to
            # optionally reset the timestamp on the file
            # to agree with the tag date. With this option, file
            # modification times can be kept in agreement
            # with the index-date tag values.

            # Why is this necessary?

            # The index-date value is initially set to
            # the value of a post file's original modification time.
            # However, Ode's tag values can be
            # arbitrarily changed to
            # virtually any date and time.
    
            # This means that the modification time
            # associated with the file may fall out of sync with the
            # index-date.


            # This isn't a problem as long as the Indexette addin is
            # installed and active - because the tag value
            # is always preferred to the timestamp.

            # However, if a user ever chooses to remove the addin,
            # it's likely that the post file timestamps
            # will cause posts to jump around in time, which would impact
            # not only the dates of indivdual posts,
            # but also possibly the relative order of posts
            # appearing on the site.

            # By keeping the post file timestamps continually in sync
            # with the index-tag values, users are
            # free to remove the addin,
            # either temporarily or permanently, and still maintain
            # the integrity (i.e. consistency)
            # of post dates.


            # We pass the &negotiate_index_dates a preliminary
            # post date, the timestamp value
            # returned from ode::discover_posts_baked_in
            # (called earlier).

            # This value is taken directly from the post file's
            # modification time (using stat).

            # If there is a index-date tag, this value is updated
            # so that it agrees with the index-date (converted to the same
            # timestamp format).

            # On the other hand, if there is no index-date tag,
            # the value returned is the
            # same timestamp passed to the routine.


            # Either way, the return from &negotiate_index_dates
            # is a (possibly updated) timestamp value
            # representing the current post date associated
            # with a given post.


            $post_date_prelim_s = $$ffp_to_post_unixtime_hrs{$ffp_to_post_l};


            # As has already been discussed, we pass &negotiate_index_dates
            # the preliminary post date, and it returns
            # the finalized value.

            $post_date_finalized_s = &negotiate_index_dates($ffp_to_post_l, $post_date_prelim_s);


            # We replace the original value in $ffp_to_post_unixtime_hrs
            # finalized value (which may or
            # may not have been updated), at the key representing
            # the current post in the hash.

            # The post date will reflect the index-date in the hash
            # %$ffp_to_post_unixtime_hrs
            # when it is eventually returned from
            # replace_discover_posts.

            $$ffp_to_post_unixtime_hrs{$ffp_to_post_l} = $post_date_finalized_s;

        } # End, foreach my $ffp_to_post_l (%$ffp_to_post_unixtime_hrs)


        # After the loop above the value in the hash at
        # $ffp_to_post_unixtime_hrs
        # represent the finalized post dates
        # we want.

        # So we loop through the through the hash again,
        # this time in sorted order,
        # converting (i.e. formatting) each element of the hash into
        # an entry in the index.


        # (If it's not clear to you why we need to handle this
        # separately in a second loop, see the
        # the comments preceding the loop just above.)


        # We want to write the posts to the index in
        # descending order by post dates.

        # (Note that this agree with the default order of
        # the posts_sort routine in ode.cgi.
        # Keep in mind that the built-in posts_sort subroutine
        # can be overridden by defining
        # a replace_posts_sort routine in any addin.)

        # This is done to primarily to make it easier to
        # locate entries in the index
        # (using a text editor for example).


        # The index is nothing more than a plain-text file in which 
        # each line corresponds to an entry
        # representing a single post, and includes
        # the full path to a post and a post date in Unix timestamp
        # format.


        # When the reindex parameter is not used, the
        # entries are read back from the index
        # and used to populate the hash of
        # all posts that will be returned from
        # replace_discover_posts().


        # The ordering of entries in the index _is not preserved_
        # after the entries are read by the script. The
        # entries must be sorted (again) after they are collected from
        # the index.

        # This is important for at least a couple of reasons:

        # 1. If you never inspect/edit the index outside of Ode
        # (using a text editor for example)
        # the sort here is unnecessary overhead.

        # You can safely get rid of it.


        # 2. The ordering of posts in the index does not
        # necessarily have to agree with the
        # ordering of the posts on the web page
        # generated in reponse to the request
        # (i.e. posts_sort order).

        # If you choose to use some other sort order here,
        # then the order of the posts in the hash
        # will be different than the order of the posts
        # on the page.


        # You can write any sort you like and
        # entries in the index will
        # reflect your preferred sort order.

        foreach my $ffp_to_post_l (sort {$ffp_to_post_unixtime_hrs->{$b} <=> $ffp_to_post_unixtime_hrs->{$a} } keys %$ffp_to_post_unixtime_hrs)
        {

            # Now that we have the finalized post dates, we can write
            # an entry for each post
            # to the primary index file.


            # The format of the file is very simple.

            # (This is intended to
            # make the file easy to work with in a plain text
            # editor)

            # The format is:

            # - Complete filesystem path to a single post,
            # - ' : '
            # - Post date in unix timestamp format.

            # $ffp_to_post_l : $post_date_finalized_s

            # The separater is

            # space, a colon ':', and a space


            # Note that each entry in the index
            # mirrors the key/value pairs in the hash of all posts
            # at %$ffp_to_post_unixtime_hrs.

            print PRIMARY_INDEX
                "$ffp_to_post_l : $$ffp_to_post_unixtime_hrs{$ffp_to_post_l}";

            print PRIMARY_INDEX "\n";

        } # End, foreach $ffp_to_post_l (&$ode::posts_sort($ffp_to_post ...


        # After exiting through from the foreach loop,
        # we have finished working through all of the posts on the site.
        # An entry for each has been added to the
        # primary index file.


        # We're done writing the index, and so we close the filehandle.

        close PRIMARY_INDEX;


        # If the primary index _was not_ rebuilt successfully,
        # execution would have returned
        # from replace_discover_posts before this point.

        # So, we can safely notify the user that the index has been
        # created.


        # Note the naked block here, which is used to limit the scope of
        # the $warn_level_l, and $resp_level_l variables.

        # (These variables fall out of scope at the end of the naked
        # block.)


        # $warn_level_l, and $resp_level_l are used to name
        # the warning level and response level values that are passed to
        # the handle_warning_and_response() routine.

        # The purpose is to highlight these values, and
        # make it more obvious what's happening in the call to the
        # routine.

        # The values are compared to the user configurable
        # $config::warning_threshold.

        # Whenever the level passed to the routine
        # meets or exceeds the threshold
        # value, the corresponding warning and response is generated.

        # Typically warnings are output to the server logs
        # and responses are included as part of the page returned
        # to the visitor.

        # (Refer to the handle_warning_and_response subroutine
        # definition for more information.)

        { # Naked block

            my ($warn_level_l, $resp_level_l,);

            $warn_level_l = $ode::min_error_level +1;
            $resp_level_l = $ode::min_error_level +1;

            &ode::handle_warning_and_response (
                "Indexette : replace_discover_posts",

                "Primary index rebuilt\n",

                "Primary index rebuilt.\n",

                $warn_level_l, $resp_level_l
            );

        } # End, Naked block


        # As discussed above, when the addin rebuilds
        # the primary index, the auxiliary file can simply be deleted
        # because all of the entries that were
        # represented in the aux index before, are now
        # included in the primary index.

        if (unlink $ffp_to_aux_file_f)
        {

            # Note the naked block here, which is used to limit the scope of
            # the $warn_level_l, and $resp_level_l variables.

            # (These variables fall out of scope at the end of the naked
            # block.)


            # $warn_level_l, and $resp_level_l are used to name
            # the warning level and response level values that are passed to
            # the handle_warning_and_response() routine.

            # The purpose is to highlight these values, and
            # make it more obvious what's happening in the call to the
            # routine.

            # The values are compared to the user configurable
            # $config::warning_threshold.

            # Whenever the level passed to the routine
            # meets or exceeds the threshold
            # value, the corresponding warning and response is generated.

            # Typically warnings are output to the server logs
            # and responses are included as part of the page returned
            # to the visitor.

            # (Refer to the handle_warning_and_response subroutine
            # definition for more information.)

            { # Naked block

                my ($warn_level_l, $resp_level_l,);

                $warn_level_l = $ode::min_error_level +1;
                $resp_level_l = $ode::min_error_level +1;

                &ode::handle_warning_and_response (
                    "Indexette : replace_discover_posts",

                    "Successfully deleted aux index file after reindexing.\n",

                    "Auxiliary index file removed.\n",

                    $warn_level_l, $resp_level_l
                );

            } # End, Naked block


            # Having just deleted the existing auxiliary index file,
            # we create a new empty file.

            # Though not technically necessary,

            # we could instead wait to create the file until the first time
            # we need to add an entry,

            # creating the file now will allow us to
            # alert users of any problem which will occur when
            # writing to the file as soon as possible.
            
            # This gives the user the opportunity to fix the problem
            # _before_ they need to
            # make use of the aux index.

            if ( open (CREATE_AUX_INDEX, "> $ffp_to_aux_file_f") )
            {

                # Note the naked block here, which is used to limit
                # the scope of the variables:

                # $warn_level_l, and $resp_level_l

                # (These variables fall out of scope at the end of the naked
                # block.)


                # $warn_level_l, and $resp_level_l are used
                # to name the warning level and response level values
                # that are passed to the
                # handle_warning_and_response() routine.

                # The purpose is to highlight these values, and
                # make it more obvious what's happening in the call to the
                # routine.

                # The values are compared to the user configurable
                # $config::warning_threshold.

                # Whenever the level passed to the routine
                # meets or exceeds the threshold
                # value, the corresponding warning and response is generated.

                # Typically warnings are output to the server logs
                # and responses are included as part of the page returned
                # to the visitor.

                # (Refer to the handle_warning_and_response subroutine
                # definition for more information.)

                { # Naked block

                    my ($warn_level_l, $resp_level_l,);

                    $warn_level_l = $ode::min_error_level +1;
                    $resp_level_l = $ode::max_error_level -1;

                    &ode::handle_warning_and_response (
                        "Indexette : replace_discover_posts",

                        "Aux index file missing.\n" .
                        "Creating new (empty) aux index file:\n" .
                        "$ffp_to_aux_file_f\n" .
                        "Add posts to the aux index with the " .
                        "add_post parameter.\n",

                        "Created new (empty) aux index file.\n",

                        $warn_level_l, $resp_level_l
                    );

                } # End, Naked block


                # After creating the empty file,
                # we're finished with the auxiliary index
                # (for now), so we close
                # the associated filehandle.

                close CREATE_AUX_INDEX;

            } # End, if ( open (CREATE_AUX_INDEX, "> $ffp_to_aux_file_f") )


            # If we are unable to create the auxiliary index file
            # are successfully deleting it,
            # there isn't much we can do about it, other than
            # report the issue to the user.

            # Note that this isn't a big problem, at least not immediately.

            # The routine has already populated the primary
            # index file, and the aux file, if it had been created,
            # would have been empty.

            # However, the site maintainer will need to
            # correct the underlying issue
            # before they will be able to successfully add a new post
            # using the add_post parameter.

            else
            {
                # Note the naked block here, which is used to limit
                # the scope of the variables:

                # $warn_level_l, and $resp_level_l

                # (These variables fall out of scope at the end of the naked
                # block.)


                # $warn_level_l, and $resp_level_l are used
                # to name the warning level and response level values
                # that are passed to the
                # handle_warning_and_response() routine.

                # The purpose is to highlight these values, and
                # make it more obvious what's happening in the call to the
                # routine.

                # The values are compared to the user configurable
                # $config::warning_threshold.

                # Whenever the level passed to the routine
                # meets or exceeds the threshold
                # value, the corresponding warning and response is generated.

                # Typically warnings are output to the server logs
                # and responses are included as part of the page returned
                # to the visitor.

                # (Refer to the handle_warning_and_response subroutine
                # definition for more information.)

                { # Naked block

                    my ($warn_level_l, $resp_level_l,);

                    $warn_level_l = $ode::min_error_level +1;
                    $resp_level_l = $ode::min_error_level +1;

                    &ode::handle_warning_and_response (
                        "Indexette : replace_discover_posts",

                        "Aux index deleted after reindexing, but " .
                            "ran into trouble creating a new (empty) file\n" .
                        "to replace it at:\n" .
                        "$ffp_to_aux_file_f\n" .
                        "$!",

                        "Aux index file deleted but cannot be recreated.\n",

                        $warn_level_l, $resp_level_l
                    );

                } # End, Naked block

            } # End, else

        } # End, if (unlink $ffp_to_aux_file_f) 


        # There are two reasons why we might not be able to delete the
        # auxiliary index file:

        # 1. It doesn't exist.

        # 2. The file exists but something is preventing the script
        # from removing it
        # (most likely a permissions issue).


        # In the first case, we don't need to do anything.

        # This does not indicate a problem.

        # There are any number of reasons why the file may not exist.
        # (The user may have manually deleted it
        # for example.)

        # The second case however most likely does signal some sort of
        # problem.


        # We notify the user,
        # using the standard warning and response mechanism,
        # only if the file exists.

        elsif (-e $ffp_to_aux_file_f)
        {

            # Note the naked block here, which is used to limit
            # the scope of the variables:

            # $warn_level_l, and $resp_level_l

            # (These variables fall out of scope at the end of the naked
            # block.)


            # $warn_level_l, and $resp_level_l are used
            # to name the warning level and response level values
            # that are passed to the
            # handle_warning_and_response() routine.

            # The purpose is to highlight these values, and
            # make it more obvious what's happening in the call to the
            # routine.

            # The values are compared to the user configurable
            # $config::warning_threshold.

            # Whenever the level passed to the routine
            # meets or exceeds the threshold
            # value, the corresponding warning and response is generated.

            # Typically warnings are output to the server logs
            # and responses are included as part of the page returned
            # to the visitor.

            # (Refer to the handle_warning_and_response subroutine
            # definition for more information.)

            { # Naked block

                my ($warn_level_l, $resp_level_l,);

                $warn_level_l = $ode::min_error_level +1;
                $resp_level_l = $ode::min_error_level +1;

                &ode::handle_warning_and_response (
                    "Indexette : replace_discover_posts",

                    "Unable to remove aux index file " .
                        "after successfully reindexing:\n" .
                    "$ffp_to_aux_file_f\n" .
                    "Check path and permissions.\n",

                    "Unable to remove auxiliary index file.\n",

                    $warn_level_l, $resp_level_l
                );

            } # End, Naked block

        } # End, elsif (-e $ffp_to_aux_file_f)


        # Having dealt with the reindex request,
        # which may have included updating the values in the hash at
        # $ffp_to_post_unixtime_hrs,

        # we exit from Indexette's replace_discover_posts routine
        # by returning the hash reference. 

        # Note: This is the only 1 of the 4 cases that includes an early
        # return from the replace_discover_posts routine.

        # All of the other cases continue through
        # all the way to
        # the end of the routine.
        
         return $ffp_to_post_unixtime_hrs;

    } # End, if ($ode::req_query_string_components_final{reindex})


    # Remember that we said that there were 4 cases to consider:


    # 1. Only the 'reindex' parameter is included with request.
    # 2. Only the 'add_post' parameter is included.
    # 3. Both parameters are included.
    # 4. Neither parameter is included.


    # We've just dealt with case 1.

    # If only the reindex parameter is included, we would have already
    # returned from Indexette's
    # replace_discover_posts routine.


    # In terms of the behavior of the routine,
    # cases 1 and 3
    # are actually the same case.

    # That is, when both parameters are included, the addin
    # effectively ignores the add_post parameter
    # and behaves the same way it does when only the reindex parameter
    # is included.

    # Note
    
    # Except for the initial prep work that is done when the add_post
    # parameter is included and not otherwise
    # (before we started to deal with case 1 above).

    # That work involved actually creating a new file
    # for the post being added.

    # (See the comments associated with that code for the complete details.)


    # As written, this is exactly what happens.

    # The conditional expression that takes execution into the if block
    # above:
    
    # if ($ode::req_query_string_components_final{reindex}) 

    # evaluates as true whenever the reindex parameter is included
    # as part of the request.

    # We do not make any qualifications about the add_post parameter,
    # which means that the expression will be
    # determined to be true or false
    # regardless of the presence or absence of add_post.


    # It should make sense to you that if the add_post parameter is
    # irrelevant when the reindex parameter is
    # included as part of the request, then the cases:

    # 1. The 'reindex' parameter is included with the request.
    # 3. Both parameters are included with the request.

    # Are the same case.


    # Hopefully the reason for this is also fairly obvious.

    # When reindexing, we must rebuild the primary index by traversing
    # the filesystem looking for post files directly.

    # Any added post will be picked up and included in the index
    # along with all of the other content,
    # so adding a post, or otherwise treating the post
    # as a special case is not necessary.


    # So if we are here, we are dealing with either case 2 or 4.

    # 2. Only the 'add_post' parameter is included with the request.
    # 4. Neither parameter is included.


    # If we are dealing with case 2,
    # i.e. if the add_post parameter is included as part of the request,
    # we have already created a new post file
    # if necessary.

    # What's left to do?

    # We must still add an entry for the post to the auxiliary index file.


    # After that, we can treat cases 2 and 4 identically.

    # So, what does that mean specifically?

    # We want to read the primary _and_ auxiliary index files
    # to build the hash of all posts.

    # This saves us the work of going through the
    # file system entries to build the same hash - which is critical
    # in terms of performance.

    # Note that this is especially true now that we've added the
    # requirement of negotiating the 'index-date',
    # because rebuiding from the post files directly now would require
    # that we open and inspect each post
    # looking for an index-date tag (a slow process).


    # Let's take care of what we need to do that is specific to case 2:

    # Adding an entry for the post to the auxiliary index file.


    # The conditions that must be satisfied:
    
    # 1. The add_post parameter must be included with the request.
    # If this is not an add_post request then this
    # part of the routine is irrelevant.

    # 2. The file corresponding to the post we are adding to the index
    # must exist.

    # If the file did not exist before the call to Indexette's
    # replace_discover_posts routine, we have
    # already taken care of creating it. So, the only reason
    # the post will not exist at this point is:

    # a. The request was invalid in some way, e.g. the add_post request
    #    did not specify the post to be added.

    # b. The post file could not created.
    #    In this case we don't want to add an entry to the index
    #    for a non-existent post.

    #    (Note: In this situation we will have already reported the
    #    the problem to the user. So it's enough for
    #    us to simply do nothing here.)


    # The compound conditional expression checks both of these conditions.

    if ($ode::req_query_string_components_final{add_post} and -f $ffp_to_added_post_s)
    {

        # If either or both are not true.
        # We know the file exists, though it may be a new, empty post.

        # (Even if it's not an empty post, it may not
        # include an index-date tag.)

        # Regardless, if the post file exists at all,
        # we should be able to get the modification timestamp
        # from the file with a call to stat.

        # We'll start with this value,
        # which we'll call
        # a 'preliminary' post date.


        # The purpose of the undef assignment is to make it clear
        # that we will be setting the value of the variable
        # for the first time now.

        # The value of the variable should not be used,
        # before this point in the execution of the script.

        $post_date_prelim_s = undef;


        if( $post_date_prelim_s = (stat _)[9])
        {

            # Note the use of Perl's special _ symbol, which
            # reuses the stat structure
            # returned from the most recent system call
            # (-f just above).


            # Having determined that the add_post request
            # can be matched to a file, we call negotiate_index_dates()
            # passing in the preliminary post date.
            # (i.e. the modification time just retrieved from
            # the post file.

            # The return value from negotiate_index_dates is the finalized
            # post date, which will be either the same date
            # passed to the routine -if there is no index-date tag
            # or if the index-date tag value is
            # the same as the the date from the file modification timestamp-
            # or an updated value, if there is an index-date
            # with a different different value.


            # The purpose of the undef assignment is to make it clear
            # that we will be setting the value of the variable
            # for the first time now.

            # The value of the variable should not be used,
            # before this point in the execution of the script.

            $post_date_finalized_s = undef;

            $post_date_finalized_s = &negotiate_index_dates($ffp_to_added_post_s, $post_date_prelim_s);


            # Next, with the finalized post date timestamp returned
            # from negotiate_index_dates(),
            # we open the auxiliary index file so that we can
            # add an entry to the index
            # for the new (or newly modified) post.


            # Note that while the primary index is kept in sorted order
            # (so that it is easier to locate entries
            # outside of ode among the possible large collection
            # of entries), new entries are always placed at the bottom of
            # the auxiliary index file
            # (i.e. new entries are appended).

            # This is because we want new changes (updates)
            # to override older entries,
            # and the index is read from top to bottom.


            # For example, let's say that an author decides to update the
            # modification time on existing post.

            # Because this is an existing post, there is
            # already be an entry
            # for the post in the primary index.

            # Now we are adding an entry to the auxiliary index file.

            # Because the auxiliary file is read after the primary index,
            # the update will
            # override the original entry.

            # OK?

            # Now let's say that the author realizes
            # (s)he has specified an incorrect modification time, and so
            # would like to update the entry again.

            # When add_post is run a second time for the same post,
            # another (newer) entry is appended
            # to the bottom of the auxiliary index file.

            # This new entry overrides the previous one,
            # and the post is displayed with the correct modification
            # time.

            # If this sounds like the aux index file
            # may contain a lot of redundant information,
            # keep in mind:

            # 1. The aux index file is cleared completely
            # when the index is rebuilt.

            # 2. posts are only added to the aux index when:

            # a) they are first created, at which point
            # there is only a single entry in the index corresponding
            # to the file and

            # b) when the modification date/time
            # is manually updated.

            # Changes requiring that a post be re-added to the index
            # should not happen frequently.

            # (In fact the reason for tracking these
            # modification times so carefully is to prevent them from
            # changing frequently.)


            # Redundant entries in the aux index file
            # (which are actually updated entries,
            # not redundant entries)
            # are not something to be concerned about.


            # Next, we attempt to open the aux
            # index file attached to the filehandle
            # AUX_FILE.

            # Note that the file is opened in
            # append mode '>>', so new lines are added to the end 
            # of the file -
            
            # Just what we want.

            if (open (AUX_FILE, ">> $ffp_to_aux_file_f"))
            {

                # If successful opening the auxiliary index,
                # we create the entry
                # for the file being added.

                # Again, there may already be an entry for this post
                # in the index (in the primary index, 
                # the auxiliary file, or both).
                # That's ok.

                # New entries, i.e. lines read later,
                # overwrite earlier ones.


                # Now that we have the finalized post date,
                # we can write an entry
                # for the post being added to the
                # aux index file.


                # We use the same simple format for the auxiliary
                # index as we do the primary file.


                # The format of the file is very simple.

                # (This is intended to
                # make the file easy to work with in a plain text
                # editor)

                # The format is:

                # - Complete filesystem path to a single post,
                # - ' : '
                # - Post date in unix timestamp format.

                # $ffp_to_post_l : $post_date_finalized_s

                # The separater is

                # space, a colon ':', and a space


                # Note that each entry in the index
                # mirrors the key/value pairs in the hash of all posts
                # at %$ffp_to_post_unixtime_hrs.

                print AUX_FILE
                    "$ffp_to_added_post_s : $post_date_finalized_s\n";


                # After we append the entry for the
                # post being added, we're finished with the auxiliary 
                # index file, so we close
                # the associated filehandle.

                close AUX_FILE;


                # We notify the user that the post was successfully added
                # to the auxiliary index by
                # issuing a warning and response.


                # $warn_level_l, and $resp_level_l are used
                # to name the warning level and response level values
                # that are passed to the
                # handle_warning_and_response() routine.

                # The purpose is to highlight these values, and
                # make it more obvious what's happening in the call
                # to the routine.

                # The values are compared to the user configurable
                # $config::warning_threshold.

                # Whenever the level passed to the routine
                # meets or exceeds the threshold
                # value, the corresponding warning and response is
                # generated.

                # Typically warnings are output to the server logs
                # and responses are included as part of the page
                # returned to the visitor.

                # (Refer to the handle_warning_and_response subroutine
                # definition for more information.)

                { # Naked block

                    my ($warn_level_l, $resp_level_l,);

                    $warn_level_l = $ode::min_error_level +1;
                    $resp_level_l = $ode::min_error_level +1;

                    &ode::handle_warning_and_response (
                        "Indexette : replace_discover_posts",

                        "Aux index file updated with entry for\n" .
                        "post file:\n" .
                        "$ffp_to_added_post_s\n",

                        "New entry added to (aux) index.",

                        $warn_level_l, $resp_level_l
                    );

                } # End, Naked block

            } # End, if (open (AUX_FILE, ">> $ffp_to_aux_file_f"))

            else
            {
                # If we were not able to successfully open the
                # auxiliary file to update the
                # aux index with an entry for the post we've
                # attempted to add, then we need to
                # report the error.


                # $warn_level_l, and $resp_level_l are used
                # to name the warning level and response level values
                # that are passed to the
                # handle_warning_and_response() routine.

                # The purpose is to highlight these values, and
                # make it more obvious what's happening in the call
                # to the routine.

                # The values are compared to the user configurable
                # $config::warning_threshold.

                # Whenever the level passed to the routine
                # meets or exceeds the threshold
                # value, the corresponding warning and response is
                # generated.

                # Typically warnings are output to the server logs
                # and responses are included as part of the page
                # returned to the visitor.

                # (Refer to the handle_warning_and_response subroutine
                # definition for more information.)

                { # Naked block

                    my ($warn_level_l, $resp_level_l,);

                    $warn_level_l = $ode::min_error_level +1;
                    $resp_level_l = $ode::min_error_level +1;

                    &ode::handle_warning_and_response (
                        "Indexette : replace_discover_posts",

                        "Attempting to write new post to aux index " . 
                            "file failed while attempting to add:\n" .
                        "$ffp_to_added_post_s\n" .
                        "Check path and permissions." .
                        "The post will not appear " .
                        "until you correct this problem (or try " .
                        "reindexing).\n",

                        "The entry cannot be added to the (aux) index.\n",

                        $warn_level_l, $resp_level_l
                    );

                } # End, Naked block

            } # End, else

        } # End, if( $post_date_prelim_s = (stat $ffp_to_added_post_s) ...

        else
        {
            # If the stat request fails for some reason,
            # we cannot get the modification time
            # for the post file we want to add to the auxiliary index
            # file.

            # We need this info to call the
            # negotiate_index_dates() routine in order to determine the
            # the correct post date.

            # The post cannot be added the auxiliary index,
            # because we can't determine the date to
            # save to the index along with the path the file.

            # Instead, we generate a warning and response
            # and continue without adding the post.

            # Note that if the post is already represented in the index
            # (either the primary or auxiliary files)
            # it will still appear on the site,
            # but with it's previously saved index date.

            # On the other hand, if the post does not already appear
            # in either index, it will be missing from
            # the site though the post file itself may exist.

            # Of course, this is because Indexette's
            # replace_discover_posts routine works by reading
            # the index files, and not looking at the
            # post files directly.


           # $warn_level_l, and $resp_level_l are used
           # to name the warning level and response level values
           # that are passed to the
           # handle_warning_and_response() routine.

           # The purpose is to highlight these values, and
           # make it more obvious what's happening in the call
           # to the routine.

           # The values are compared to the user configurable
           # $config::warning_threshold.

           # Whenever the level passed to the routine
           # meets or exceeds the threshold
           # value, the corresponding warning and response is
           # generated.

           # Typically warnings are output to the server logs
           # and responses are included as part of the page
           # returned to the visitor.

           # (Refer to the handle_warning_and_response subroutine
           # definition for more information.)

           { # Naked block

               my ($warn_level_l, $resp_level_l,);

               $warn_level_l = $ode::min_error_level +1;
               $resp_level_l = $ode::min_error_level +1;

               &ode::handle_warning_and_response (
                   "Indexette : replace_discover_posts",

                   "Cannot get the file mod timestamp for.\n" .
                   "$ffp_to_added_post_s\n" .
                   "So this post cannot be added to the index.\n" .
                   "$!\n" .
                   "This issue must be address before " .
                    "add post will succeed\n",

                "Attempt to add post failed. Cannot get file mtime " .
                        "timestamp\n",

                   $warn_level_l, $resp_level_l
               );

           } # End, Naked block

       } # End, else

    } # End, if ( $ode::req_query_string_components_final{add_post} and -f ...



    # That ends the case 2 (i.e. dd_post) specific behavior.

    # The rest of the routine applies equally to both
    # cases 2 and 4. (We would have returned from cases 1 and 3
    # before now.)

    # 2. The 'add_post' parameter is included as part of the request.
    # 4. Neither parameter is included.


    # This part of the routine is fairly straightforward.

    # We simply read the primary and auxiliary index files
    # and populate our hash of all posts with
    # the entries from those files.


    # Note: The order in which the indexes are read is important.

    # The auxiliary index file is read after the primary index.

    # When read in this order, posts with updated modification times will
    # display with the correct date and time
    # without requiring that the entire index be rebuilt.

    # Why?

    # The keys in the %ffp_to_post_unixtime_hs hash are filenames,
    # and the values corresponding modification times.

    # Posts with updated modification times, will first be pulled
    # from the primary index
    # # (along with the incorrect/old timestamp).

    # These (possibly incorrect) values will be replaced if the same key is
    # encountered in the aux_index_file.


    # The hash of all posts at %ffp_to_post_unixtime_hs starts out empty.


    # The purpose of the empty assignment is to
    # make it clear that we will be setting the value of the variable
    # for the first time now.

    # The value of the variable should not be used,
    # before this point in
    # the execution of the script.

    %ffp_to_post_unixtime_hs = ();


    # First we try to read from the primary index file, opening the file in
    # read only mode (<)
    # at the filehandle PRIMARY_INDEX.

    if (open (PRIMARY_INDEX, "< $ffp_to_pri_file_f"))
    {

        my (
            $line_number_l, $ffp_to_post_l,
            $timestamp_l,
        );

        # $line_number_l is just a counter used to keep track of our
        # position in the primary index file
        # so that we can include the line number in
        # notifications, should we run into some sort of problem
        # when processing the index file.

        $line_number_l = 0;


        # We loop through the primary index file
        # one line at a time. Each line consists of a single entry
        # corresponding to a post file.

        # The format of each line is:

        # Full filesystem path to post : post date

        # (Note that post dates are recorded in unix timestamp format
        # like the mtime values returned from stat.)

        while (my $line_l = <PRIMARY_INDEX>)
        {

            # We start by incrementing the line number.
            # So though $line_number_l is
            # initially 0, the first line in the primary index file is
            # identified as line 1.

            $line_number_l++;


            # We explicitly reset these variables to undef
            # each time through the loop so that
            # it is impossible for values from one line to carry
            # through to the next.

            # (As the loop is written, it's not possible
            # even without this assignment.

            # But the assignment makes this obvious.)

            $ffp_to_post_l = $timestamp_l = undef;


            # Using a pattern match, we split the line at the colon
            # which separates the path to the post from the
            # timestamp.

            # The pattern used is:
            
            # ^\s*(\S[^:]*)\s*:\s*(\d+)\s*$

            # which matches:

            # ^         - The start of the line

            # \s*       - Any number of whitespace characters including 0

            # (\S[^:]*) - Next, we expect to find the path to the post.
            #             This portion of the pattern matches a non
            #             whitespace character followed by
            #             any number of any character except for a colon
            #             (which is reserved and must only be used
            #             as a separator between the two elements of the
            #             entry.

            # \s*       - Then we have any number of whitespace characters
            #             which may appear as padding between the
            #             path and the colon which acts as a separator
            #             between the two halves of the line.

            # :         - A literal colon, which separates the two 
            #             element of each entry.

            # \s*       - Again, there can be any amount of whitespace
            #             as padding separating the colon
            #             from the timestamp (just as we allowed for optional
            #             whitespace between the path and the colon).

            # (\d+)     - This portion of the pattern matches the timestamp
            #             corresponding to the post specified by the
            #             portion of the string that preceded the separator.
            #             Note that the timestamp is recorded in unix
            #             timestamp format (a integer value representing
            #             roughly the number of seconds since the system's
            #             understanding of epoch). Because this is
            #             nothing but a positive integer value \d+ is a
            #             suitable pattern to use.

            # \s*      - As we did at the start of the line, we allow for any
            #            number of trailing whitespace characters
            #            after the timestamp value and before the end of the
            #            line.

            # $        - Finally, we come to the portion of the pattern
            #            matching the end of the line.


            # Note that the two portions we're interested in:

            # (\S[^:]*)
            # (\d+)

            # are surrounded by matching parens.

            # The substrings of each line matching this portion of
            # the pattern are assigned to
            # the variables:
            
            # $ffp_to_post_l,
            # $timestamp_l

            if ( ($ffp_to_post_l, $timestamp_l) =
                $line_l =~ m/^\s*(\S[^:]*)\s*:\s*(\d+)\s*$/ )
            {

                # Assuming that pattern match was successful
                # (otherwise we would not have satisfied the condition
                # leading to this statement), we use the substrings
                # matching the portion of the pattern
                # selected with the match variables to add a new pair to
                # the hash of all posts.

                # The key for the new pair is the aboslute path
                # to the post file ($ffp_to_post_l),
                # and the value is the timestamp for the post
                # ($timestamp_l).

                $ffp_to_post_unixtime_hs{$ffp_to_post_l} = $timestamp_l;
            }

            else
            {
                # If the pattern match specified in the
                # conditional expression fails
                # there must be something not right about the format
                # of this line.

                # We generate a warning and response message
                # notifying the user of the issue
                # before the loop is repeated with the next
                # line of the primary index file.

                # Note that we do not add an entry to the hash for this
                # line, and the post corresponding to
                # this entry will be absent from the hash of all
                # posts returned from Indexette's
                # replace_discover_posts routine.
                
                # As a result the post will not appear on the site.

                # (unless at least one properly formatted entry
                # for the post appears in the auxiliary index which is
                # processed next.)


                # We do not assume that a single malformed line,
                # or even 99 out of 100 non matching
                # lines indicates a problem with the entire
                # index. Instead, the loop keeps chugging away, trying
                # each line in succession.

                # If all of the lines are malformed, that will be
                # discovered, and the entries skipped,
                # one line at a time.


                # $warn_level_l, and $resp_level_l are used
                # to name the warning level and response level values
                # that are passed to the
                # handle_warning_and_response() routine.

                # The purpose is to highlight these values, and
                # make it more obvious what's happening in the call
                # to the routine.

                # The values are compared to the user configurable
                # $config::warning_threshold.

                # Whenever the level passed to the routine
                # meets or exceeds the threshold
                # value, the corresponding warning and response is
                # generated.

                # Typically warnings are output to the server logs
                # and responses are included as part of the page
                # returned to the visitor.

                # (Refer to the handle_warning_and_response subroutine
                # definition for more information.)

                { # Naked block

                    my ($warn_level_l, $resp_level_l,);

                    $warn_level_l = $ode::min_error_level +1;
                    $resp_level_l = $ode::max_error_level;

                    &ode::handle_warning_and_response (
                        "Indexette : replace_discover_posts",

                        "Problem reading from primary index file\n" .
                        "Invalid format at line number:\n" .
                        "$line_number_l\n" .
                        "Skipping line. (Corresponding post will not " .
                            "appear in the site.)\n".
                        "Try reindexing or editing the file manually\n",

                        "Problem reading entry in primary index file. " . 
                            "Skipping entry and continuing.\n",

                        $warn_level_l, $resp_level_l
                    );

                } # End, Naked block

            } # End, else

        } # End, while (my $line = <PRIMARY_INDEX>)


        # We exit form the loop only after running out of lines
        # in the primary index file.

        # At this point there is (hopefully)
        # a key/value pair in the hash for each line in the index file
        # (i.e. a pair for each post on the site).

        # We're finished with the primary index file, and so we
        # close the associated filehandle.

        close PRIMARY_INDEX;

    } # End, if (open (PRIMARY_INDEX, "< $ffp_to_pri_file_f"))

    else
    {
        # If the script can't open the primary index file there's
        # not much we can do.

        # Broadly speaking, there are
        # two reasons why we might not be able to
        # read the index:

        # 1. The file doesn't exist.
        # 2. The file exists but is not readable.

        # We test to determine if there is a file at $ffp_to_pri_file_f
 
        # (i.e. If there is a file at the path specified
        # for the index in the configuration section at the top
        # of this file).


        if (-f $ffp_to_pri_file_f)
        {
            # If there is a file at the specified path,
            # we generate an appropriate
            # warning and response in the usual way, with Ode's
            # handle_warning_and_response routine.

            # The file exists so there must be some problem preventing
            # us from reading the file
            # (most likely a permissions issue).


            # $warn_level_l, and $resp_level_l are used
            # to name the warning level and response level values
            # that are passed to the
            # handle_warning_and_response() routine.

            # The purpose is to highlight these values, and
            # make it more obvious what's happening in the call
            # to the routine.

            # The values are compared to the user configurable
            # $config::warning_threshold.

            # Whenever the level passed to the routine
            # meets or exceeds the threshold
            # value, the corresponding warning and response is
            # generated.

            # Typically warnings are output to the server logs
            # and responses are included as part of the page
            # returned to the visitor.

            # (Refer to the handle_warning_and_response subroutine
            # definition for more information.)

            { # Naked block

                my ($warn_level_l, $resp_level_l,);

                $warn_level_l = $ode::min_error_level +1;
                $resp_level_l = $ode::min_error_level +1;

                &ode::handle_warning_and_response (
                    "Indexette : replace_discover_posts",

                    "Cannot read primary index file at:\n" .
                    "$ffp_to_pri_file_f\n" .
                    "Check the path and permissions, " .
                        "or try rebuilding the index (param('reindex')).\n" .
                    "No posts can be read from main index " .
                        "until this is fixed.\n" .
                    "You may still see posts from the aux index.\n",

                    "Cannot read primary index file. " . 
                        "Check path and permissions or rebuild the index.\n",

                    $warn_level_l, $resp_level_l
                );

            } # End, Naked block

        } # End, if (-f $ffp_to_pri_file_f)

        else
        {
            # If the primary index file is missing, we attempt to
            # create a new (empty) file,
            # and notify the user.

            if ( open (CREATE_PRIMARY_INDEX, "> $ffp_to_pri_file_f") )
            {

                # $warn_level_l, and $resp_level_l are used
                # to name the warning level and response level values
                # that are passed to the
                # handle_warning_and_response() routine.

                # The purpose is to highlight these values, and
                # make it more obvious what's happening in the call
                # to the routine.

                # The values are compared to the user configurable
                # $config::warning_threshold.

                # Whenever the level passed to the routine
                # meets or exceeds the threshold
                # value, the corresponding warning and response is
                # generated.

                # Typically warnings are output to the server logs
                # and responses are included as part of the page
                # returned to the visitor.

                # (Refer to the handle_warning_and_response subroutine
                # definition for more information.)

                { # Naked block

                    my ($warn_level_l, $resp_level_l,);

                    $warn_level_l = $ode::min_error_level +1;
                    $resp_level_l = $ode::min_error_level +1;

                    &ode::handle_warning_and_response (
                        "Indexette : replace_discover_posts",

                        "Primary index file missing.\n" .
                        "Creating new (empty) primary index file at:\n" .
                        "$ffp_to_pri_file_f\n" .
                        "You must reindex to populate the index.\n",

                        "Primary index file missing. " .
                            "Reindex to populate the new index.\n",

                        $warn_level_l, $resp_level_l
                    );

                } # End, Naked block


                # We're finshed with our new (empty)
                # primary index file, so we
                # close the associated filehandle.

                close CREATE_PRIMARY_INDEX;

            } # End, if ( open (CREATE_PRIMARY_INDEX, "> $ffp_to_pri_ ...

            else
            {
                # If we cannot create a new (empty) primary index file
                # for some reason, all we can do is
                # notify the user, and ask them to resolve the
                # issue to get things back to normal.


                # $warn_level_l, and $resp_level_l are used
                # to name the warning level and response level values
                # that are passed to the
                # handle_warning_and_response() routine.

                # The purpose is to highlight these values, and
                # make it more obvious what's happening in the call
                # to the routine.

                # The values are compared to the user configurable
                # $config::warning_threshold.

                # Whenever the level passed to the routine
                # meets or exceeds the threshold
                # value, the corresponding warning and response is
                # generated.

                # Typically warnings are output to the server logs
                # and responses are included as part of the page
                # returned to the visitor.

                # (Refer to the handle_warning_and_response subroutine
                # definition for more information.)

                { # Naked block

                    my ($warn_level_l, $resp_level_l,);

                    $warn_level_l = $ode::min_error_level +1;
                    $resp_level_l = $ode::min_error_level +1;

                    &ode::handle_warning_and_response (
                        "Indexette : replace_discover_posts",

                        "Primary index file missing and " .
                            "cannot be created at:\n" .
                        "$ffp_to_pri_file_f\n" .
                        "$!",

                        "Primary index file missing and cannot be " .
                        "recreated.\n",

                        $warn_level_l, $resp_level_l
                    );

                } # End, Naked block

            } # End, else

        } # End, else

    } # End, else


    # It's time to move on the auxiliary index file.

    # This is handled the same way we dealt with the primary index.


    # We attempt to open the file, and
    # if we're successful:
    
    # A. Read the lines in the file, one at a time,

    # B. Perform a pattern match on each in order to pick out the
    # path to the post file and post date,

    # C. Add a pair in the hash of all posts for each entry in the file.


    # Because the auxiliary index file is processed
    # _after_ the primary file entries in the aux index will
    # replace entries for the same post file
    # encountered in the primary index.

    # Also, because new entries in the auxiliary index are
    # always appended to the end of the file, and
    # the file is read from top to bottom, later entries
    # (i.e. lines closer to the bottom)
    # in the aux index will supersede entries for the same post
    # encountered earier in the auxiliary index.


    # First we try to read from the auxiliary index file,
    # opening the file in
    # read only mode (<)
    # at the filehandle AUX_INDEX.

    if (open (AUX_INDEX, "< $ffp_to_aux_file_f"))
    {

        my (
            $line_number_l, $ffp_to_post_l,
            $timestamp_l,
        );


        # $line_number_l is a counter used to keep track of our
        # position in the primary index file
        # so that we can include the line number in
        # notifications should we run into some sort of problem
        # when processing the index file.

        $line_number_l = 0;


        # We loop through the auxiliary index file
        # one line at a time. Each line consists of a single entry
        # corresponding to a post file.

        # The format of each line is:

        # Full filesystem path to post : post date

        # (Note that post dates are recorded in unix timestamp format
        # like the mtime values returned from stat.)

        while (my $line_l = <AUX_INDEX>)
        {

            # We start by incrementing the line number.
            # So though $line_number_l is
            # initially 0, the first line in the primary index file is
            # identified as line 1.

            $line_number_l++;


            # We explicitly reset these variables to undef
            # each time through the loop so that
            # it is impossible for values from one line to carry
            # through to the next.

            # (As the loop is written, it's not possible even without
            # this assignment. But the assignment
            # makes this obvious.)

            $ffp_to_post_l = $timestamp_l = undef;


            # Using a pattern match, we split the line at the colon
            # which separates the path to the post from the
            # timestamp.

            # The pattern used is:

            # ^\s*(\S[^:]*)\s*:\s*(\d+)\s*$

            # which matches:

            # ^         - The start of the line

            # \s*       - Any number of whitespace characters including 0

            # (\S[^:]*) - Next, we expect to find the path to the post.
            #             This portion of the pattern matches a non
            #             whitespace character followed by
            #             any number of any character except for a colon
            #             (which is reserved and must only be used
            #             as a separator between the two elements of the
            #             entry.

            # \s*       - Then we have any number of whitespace characters
            #             which may appear as padding between the
            #             path and the colon which acts as a separator
            #             between the two halves of the line.

            # :         - A literal colon, which separates the two 
            #             element of each entry.

            # \s*       - Again, there can be any amount of whitespace
            #             as padding separating the colon
            #             from the timestamp (just as we allowed for optional
            #             whitespace between the path and the colon).

            # (\d+)     - This portion of the pattern matches the timestamp
            #             corresponding to the post specified by the
            #             portion of the string that preceded the separator.
            #             Note that the timestamp is recorded in unix
            #             timestamp format (a integer value representing
            #             roughly the number of seconds since the system's
            #             understanding of epoch). Because this is
            #             nothing but a positive integer value \d+ is a
            #             suitable pattern to use.

            # \s*      - As we did at the start of the line, we allow for any
            #            number of trailing whitespace characters
            #            after the timestamp value and before the end of the
            #            line.

            # $        - Finally, we come to the portion of the pattern
            #            matching the end of the line.


            # Note that the two portions we're interested in:

            # (\S[^:]*)
            # (\d+)

            # are surrounded by matching parens.

            # The substrings of each line matching this portion of
            # the pattern are assigned to
            # the variables:

            # $ffp_to_post_l,
            # $timestamp_l

            if ( ($ffp_to_post_l, $timestamp_l) =
                $line_l =~ m/^\s*(\S[^:]*)\s*:\s*(\d+)\s*$/ )
            {
                # Assuming that pattern match was successful
                # (otherwise we would not have satisfied the condition
                # leading to this statement), we use the substrings
                # matching the portion of the pattern
                # selected with the match variables to add a new pair to
                # the hash of all posts.

                # The key for the new pair is the aboslute path
                # to the post file ($ffp_to_post_l),
                # and the value is the timestamp for the post
                # ($timestamp_l).

                $ffp_to_post_unixtime_hs{$ffp_to_post_l} = $timestamp_l;
            }

            else
            {
                # If the pattern match specified in the
                # conditional expression fails,
                # there must be something not right about the format
                # of this line.

                # We generate a warning and response message
                # notifying the user of the issue
                # before the loop is repeated with the next
                # line of the auxiliary index file.

                # Note that we do not add an entry to the hash for this
                # line and the post corresponding to
                # this entry will be absent from the hash of all
                # posts returned from Indexette's
                # replace_discover_posts routine. As a result
                # the post will not appear on the site.
                # (unless at least one properly formatted entry
                # for the post appears in the auxiliary index which is
                # processed next.)

                # We do not assume that a single malformed line,
                # or even 99 out of 100 non matching
                # lines indicates a problem with the entire
                # index. Instead, the loop keeps chugging away, trying
                # each line in succession.

                # If all of the lines are malformed, that will be
                # discovered, and the entries skipped,
                # one line at a time.


                # $warn_level_l, and $resp_level_l are used
                # to name the warning level and response level values
                # that are passed to the
                # handle_warning_and_response() routine.

                # The purpose is to highlight these values, and
                # make it more obvious what's happening in the call
                # to the routine.

                # The values are compared to the user configurable
                # $config::warning_threshold.

                # Whenever the level passed to the routine
                # meets or exceeds the threshold
                # value, the corresponding warning and response is
                # generated.

                # Typically warnings are output to the server logs
                # and responses are included as part of the page
                # returned to the visitor.

                # (Refer to the handle_warning_and_response subroutine
                # definition for more information.)

                { # Naked block

                    my ($warn_level_l, $resp_level_l,);

                    $warn_level_l = $ode::min_error_level +1;
                    $resp_level_l = $ode::max_error_level;

                    &ode::handle_warning_and_response (
                        "Indexette : replace_discover_posts",

                        "Problem reading from auxiliary index file\n" .
                        "Invalid format at line number:\n" .
                        "$line_number_l\n" .
                        "Skipping line. (Corresponding post will not " .
                            "appear in the site.)\n".
                        "Try reindexing or editing the file manually\n",

                        "Problem reading entry in primary index file. " . 
                            "Skipping entry and continuing.\n",

                        $warn_level_l, $resp_level_l
                    );

                } # End, Naked block

            } # End, else

        } # End, while (my $line = <AUX_INDEX>)


        # We exit form the loop only after running out of lines
        # in the aux index file.

        # At this point there is (hopefully)
        # a key/value pair in the hash for each line in the index file
        # (i.e. a pair for each post on the site).

        # We're finished with the auxiliary index file,
        # and so we close
        # the associated filehandle.

        close AUX_INDEX;

    } # End, if (open (AUX_INDEX, "< $ffp_to_aux_file_f"))

    else
    {
        # If the script can't open the auxiliary index file there's not
        # much we can do with it.

        # Broadly speaking, there are two reasons why we might not be
        # able to read the index:

        # 1. The file doesn't exist.
        # 2. The file exists but is not readable.

        # We test to determine if there is a file at $ffp_to_aux_file_f
        # (if there is a file at the path specified
        # for the index in the configuration section at the top
        # of this file).

        if (-f $ffp_to_aux_file_f)
        {

            # If there is a file at the specified path,
            # we generate an appropriate
            # warning and response in the usual way, with Ode's
            # handle_warning_and_response routine.

            # The file exists so there must be some problem preventing
            # us from reading the file
            # (most likely a permissions issue).


            # $warn_level_l, and $resp_level_l are used
            # to name the warning level and response level values
            # that are passed to the
            # handle_warning_and_response() routine.

            # The purpose is to highlight these values, and
            # make it more obvious what's happening in the call
            # to the routine.

            # The values are compared to the user configurable
            # $config::warning_threshold.

            # Whenever the level passed to the routine
            # meets or exceeds the threshold
            # value, the corresponding warning and response is
            # generated.

            # Typically warnings are output to the server logs
            # and responses are included as part of the page
            # returned to the visitor.

            # (Refer to the handle_warning_and_response subroutine
            # definition for more information.)

            { # Naked block

                my ($warn_level_l, $resp_level_l,);

                $warn_level_l = $ode::min_error_level +1;
                $resp_level_l = $ode::min_error_level +1;

                &ode::handle_warning_and_response (
                    "Indexette : replace_discover_posts",

                    "Cannot read auxiliary index file at:\n" .
                    "$ffp_to_aux_file_f\n" .
                    "Check the path and permissions, " .
                        "or try rebuilding the index (param('reindex')).\n" .
                    "No posts can be read from aux index " .
                        "until this is fixed.\n" .
                    "You may still see posts from the primary index.\n",

                    "Cannot read auxiliary index file. " . 
                        "Check path and permissions or rebuild the index.\n",

                    $warn_level_l, $resp_level_l
                );

            } # End, Naked block

        } # End, if (-f $ffp_to_aux_file_f)

        else
        {
            # If the auxiliary index file is missing,
            # we attempt to create a new
            # (empty) file, and notify the user.

            if ( open (CREATE_AUX_INDEX, "> $ffp_to_aux_file_f") )
            {

                # $warn_level_l, and $resp_level_l are used
                # to name the warning level and response level values
                # that are passed to the
                # handle_warning_and_response() routine.

                # The purpose is to highlight these values, and
                # make it more obvious what's happening in the call
                # to the routine.

                # The values are compared to the user configurable
                # $config::warning_threshold.

                # Whenever the level passed to the routine
                # meets or exceeds the threshold
                # value, the corresponding warning and response is
                # generated.

                # Typically warnings are output to the server logs
                # and responses are included as part of the page
                # returned to the visitor.

                # (Refer to the handle_warning_and_response subroutine
                # definition for more information.)

                { # Naked block

                    my ($warn_level_l, $resp_level_l,);

                    $warn_level_l = $ode::min_error_level +1;
                    $resp_level_l = $ode::min_error_level +1;

                    &ode::handle_warning_and_response (
                        "Indexette : replace_discover_posts",

                        "Auxiliary index file missing.\n" .
                        "Creating new (empty) aux index file at:\n" .
                        "$ffp_to_aux_file_f\n",

                        "Aux index file missing. A new empty aux index " .
                            "has been created.\n",

                        $warn_level_l, $resp_level_l
                    );

                } # End, Naked block


                # We're finshed with our new (empty) auxiliary index file
                # so we close the associated filehandle.

                close CREATE_AUX_INDEX;

            } # End, if ( open (CREATE_AUX_INDEX, "> $ffp_to_aux_file_f") )

            else
            {
                # If we cannot create a new (empty) auxiliary index file
                # for some reason, all we can do is
                # notify the user, and ask them to resolve the
                # issue to get things back to normal.


                # $warn_level_l, and $resp_level_l are used
                # to name the warning level and response level values
                # that are passed to the
                # handle_warning_and_response() routine.

                # The purpose is to highlight these values, and
                # make it more obvious what's happening in the call
                # to the routine.

                # The values are compared to the user configurable
                # $config::warning_threshold.

                # Whenever the level passed to the routine
                # meets or exceeds the threshold
                # value, the corresponding warning and response is
                # generated.

                # Typically warnings are output to the server logs
                # and responses are included as part of the page
                # returned to the visitor.

                # (Refer to the handle_warning_and_response subroutine
                # definition for more information.)

                { # Naked block

                    my ($warn_level_l, $resp_level_l,);

                    $warn_level_l = $ode::min_error_level +1;
                    $resp_level_l = $ode::min_error_level +1;

                    &ode::handle_warning_and_response (
                        "Indexette : replace_discover_posts",

                        "Auxiliary index file missing and " .
                            "cannot be created at:\n" .
                        "$ffp_to_aux_file_f\n" .
                        "$!",

                        "Auxiliary index file missing and cannot be " .
                        "recreated.\n",

                        $warn_level_l, $resp_level_l
                    );

                } # End, Naked block

            } # End, else

        } # End, else

    } # End, else


    # Having worked through both the primary
    # and auxiliary indexes, the hash at %ffp_to_post_unixtime_hs
    # should contain a single
    # entry for each post on the site.


    # Remember that because of how we processed both
    # primary and auxiliary indexes,
    # and because the entries in the aux index are ordered
    # from oldest to newest, the timestamps which are
    # the values of the pairs in the hash,
    # will accurately report the correct post dates,
    # even if there are multiple entries for a post between the two hashes.

    # We return a reference to this hash.

    # (A hash reference is the expected return value
    # from any discover_posts
    # and replace_discover_posts routine.)

    return \%ffp_to_post_unixtime_hs;

} # End, sub replace_discover_posts



# negotiate_index_dates() is a 'helper' called by replace_discover_posts().

# It expects to be passed the location of a post file and a
# modification time (presumably a file modification time pulled from the post
# file).

# The routine checks the post for an 'index-date' tag.

# If it finds such a tag it:

# It converts the human readable post date to an mtime value, and
# returns the 'timestamp' to the caller.


# If it does not find the tag:

# It converts the supplied mtime value to a more
# human readable representation and writes a new tag to the file,
# using the index-date tag format:

# tag literal prefix : Addin name : Tag name : Tag value


# Indexette's index-date tag has the following form:

# 'tag : Indexette : index-date : tag value'

# In this case it returns the same mtime value that was passed to it by the
# caller.

sub negotiate_index_dates
{

    my (
        $ffp_to_post_s, $post_file_mtime_s, $year_s, $month_s, $day_s,
        $hour_s, $min_s, $sec_s, $mtime_s, $index_date_tag_found_s,
        $index_date_value_from_post_s,
    );

    ($ffp_to_post_s, $post_file_mtime_s) =  @_;


    # $index_date_tag_found_s is a Boolean variable,
    # the value of which is true
    # if the routine is able to find an index-date tag in the current post,
    # and false otherwise.

    # The value starts out false.
    
    # (We can't have found the tag before we start looking.)

    $index_date_tag_found_s = 0;


    # ode.cgi includes a routine, get_tag_value(),
    # that does the work of retrieving
    # a tag value for us when provided all of the info necessary
    # to uniquely identify any single tag:
    
    # 1. The name of the addin
    # 2. The tag name
    # 3. The full path to the post file.

    # If the tag is found the return value
    # will be the value of the tag (which in this case is a
    # human readable index-date).

    # If the tag can not be found, get_tag_value
    # returns undef.

    $index_date_value_from_post_s = &ode::get_tag_value (
        'Indexette',
        'index-date',
        $ffp_to_post_s
    );


    # If $index_date_value_from_post_s is some defined value
    # (i.e. the return from get_tag_value
    # is not undef) ...


    # The purpose of the undef assignment is to
    # make it clear that we will be setting the values of
    # these variables for the first time now.

    # The value of the variable should not be used,
    # before this point in the execution of the script.

    $year_s = $month_s = $day_s = $hour_s = $min_s = $sec_s = undef;


    if ( $index_date_value_from_post_s )
    {

        # We attempt to use a pattern match to split the human
        # readable index date value into a list
        # of it's component parts:
        
        # year, month, day, hour, min, second.

        # For reference, an index-date tag will look something like:

        # tag : Indexette : index-date : 2010 05 14 12:21:05


        # 'tag' literal                 Tag name
        #   |                              |
        #  tag      :  Indexette :    index-date :     2010 05 14 12:21:05
        #                  |                                  |
        #             Addin name                           tag value


        # Let's take a closer look at that tag value:

        # 2010 05 14 12:21:05

        # 4 digit year  2 digit day   2 digit min 
        # |                 |                |
        # 2010  05         14    12    :    21   :      05   
        #       |                 |                     |
        #  2 digit month   2 digit hour            2 digit sec

        # Note that the hour, minute, and second values are separated
        # by a colon, and the rest of the values
        # are separated by one or more whitespace characters.

        if( ($year_s, $month_s, $day_s, $hour_s, $min_s, $sec_s)
            =  $index_date_value_from_post_s =~ /(\d{4})\s+(\d{1,2})\s+(\d{1,2})\s+(\d{1,2}):(\d{2}):(\d{2})\s*?$/)

        {

            # If the the pattern match succeeds we will have a value
            # for each of the variables:

            # $year_s,
            # $month_s,
            # $day_s,
            # $hour_s,
            # $min_s,
            # $sec_s

            # We explicitly assign a true value to
            # $index_date_tag_found_s

            # $index_date_tag_found_s is a Boolean variable, the value
            # of which is true if the routine is
            # able to find an index-date tag
            # in the current post, and false otherwise.

            $index_date_tag_found_s = 1 ;
        }

        else
        {
            # When $index_date_value_from_post_s has some defined
            # value but the pattern match included
            # in the conditional expression above is false
            # it means that the index-date tag
            # was found by ode::get_tag_value, and there is some value,
            # but that value is not what's expected.

            # The most likely explaination is that an author has manually
            # edited thed tag and changed the value to
            # something unrecognizable.

            # In this case, the tag value is unusable.

            # We do not set the value of $index_date_tag_found_s
            # to true, so the rest of the routine
            # will behave as if the tag was not found.

            # We also should notify the user of the issue, which we
            # do using the handle_warning_and_response
            # mechanism.


            # $warn_level_l, and $resp_level_l are used
            # to name the warning level and response level values
            # that are passed to the
            # handle_warning_and_response() routine.

            # The purpose is to highlight these values, and
            # make it more obvious what's happening in the call
            # to the routine.

            # The values are compared to the user configurable
            # $config::warning_threshold.

            # Whenever the level passed to the routine
            # meets or exceeds the threshold
            # value, the corresponding warning and response is
            # generated.

            # Typically warnings are output to the server logs
            # and responses are included as part of the page
            # returned to the visitor.

            # (Refer to the handle_warning_and_response subroutine
            # definition for more information.)

            { # Naked block

                my ($warn_level_l, $resp_level_l,);

                $warn_level_l = $ode::min_error_level +1;
                $resp_level_l = $ode::max_error_level -1;

                &ode::handle_warning_and_response (
                    "Indexette : negotiate_index_dates",

                    "Tag found: index-date " .
                        "but the value is not what is expected\n" .
                    "(and cannot be used):\n" .
                    "$index_date_value_from_post_s\n" .
                    "For post file:\n" .
                    "$ffp_to_post_s" .
                    "Correct the tag-value to fix this issue\n",

                    "index-date tag found w/ unexpected value. " .
                        "(See error log for details.)\n",

                    $warn_level_l, $resp_level_l
                );

            } # End, Naked block

        } # End, else

    } # End, if ( $index_date_value_from_post_s )


    # One of the parameters passed to negotiate_index_dates()
    # is $post_file_mtime_s which, as the name suggests, is the modification
    # timestamp associated with the post.

    # With the Indexette addin installed, this is only a preliminary
    # value. The value of the index-date tag is
    # always preferred to the file modification time.

    # If we're able to find an index-date tag, we'll substitute
    # the post date specified in the tag
    # for the file modification time, and use the tag value
    # as the post date.

    # (On the other hand, if we can't find the tag, then we will use
    # the file modification time as the post date,
    # and write a new index-date tag to the file based on
    # this value.)


    # At this point we may or may not have found the index-date tag.

    # If we did, then the value of
    # the Boolean $index_date_tag_found_s, is true,
    # and we have the components of the human readable date string from
    # the index-date tag at:

    # $year_s, $month_s, $day_s, $hour_s, $min_s, $sec_s

    # Otherwise $index_date_tag_found_s,
    # is false and (one of more of) the date component variables are all
    # undefined.

    if($index_date_tag_found_s)
    {
        # If it is determined that we have found
        # the index-date tag, we should have defined values for
        # all of index-date's components.

        # That being the case, the following condition
        # should be entirely unnecessary.

        # The value of $index_date_tag_found_s
        # cannot be true unless we have values for these variables
        # (and $hour_s, $min_s, $sec_s too).

        # It's here simply as a sanity check, because we are about
        # to use these values for the first time.

        # (Still, it's hard to justify.)

        if ($year_s and $month_s and $day_s)
        {

            # We're about to make a call to the timelocal function,
            # which returns an mtime value,
            # like the modification timestamps returned
            # from a call to stat, when we pass it
            # a list of values like:

            # $sec_s, $min_s, $hour_s, $day_s, $month_s, $year_s

            # Before we do, we need to decrement the value
            # of month_s by 1.
            
            # Why?

            # Because the value of the month in the human readable
            # format for index-date will be one of 01 - 12,
            # where January is month 1.
            
            # But timelocal considers month an offset from January,
            # so to timelocal Jan should be month 0.
    
            # The value of the month component of
            # value written to (and read from) the index-date tag
            # will always be 1 number too high.

            # Another example:

            #  An index-date value which includes 11 as the month
            # would be reported by timelocal as 'Dec'.

            # The script must decrement $month then
            # before passing it off to timelocal or else the resulting
            # timestamp will be at +1 the desired month.

            $month_s--;


            $mtime_s = timelocal($sec_s, $min_s, $hour_s, $day_s, $month_s, $year_s);


            # The $sync_mtime_with_tag_f option allows the site maintainer
            # to instruct Indexette to keep
            # modification times of post files in sync
            # with index-date tag values.

            # So, if the modification time of the file is updated,
            # but the tag value is not,
            # the modifictaion time of the file will be reset
            # to agree with the tag.

            # Why is this useful?
            
            # It means that if something happens to the tag (for example,
            # if the tag is accidentally deleted),
            # or if the site maintainer opts not to continue using the
            # Indexette addin, the script will continue to
            # report consistent post dates.

            # Important
            
            # The CGI user must actually
            # own the post files in order to be able to change the file
            # modification times.

            # Otherwise the request to modify the modification time
            # with utime will fail.

            if ($sync_mtime_with_tag_f)
            {

                # When the value of $sync_mtime_with_tag_f is true,
                # we attempt to set the post file
                # modification time to agree with the mtime value
                # based on the index-date tag.

                # If that attempt fails, we
                # report the problem using Ode's built-in
                # warning and response mechanism.



                # --------------------
                # | From the documentation for utime
                # --------------------
                # | utime LIST
                # |
                # | Changes the access and modification times
                # | on each file of a list of files.
                # |
                # | The first two elements of the list must be the NUMERICAL
                # | access and modification times, in that order.
                # |
                # | Returns the number of files
                # | successfully changed.
                # --------------------

                # Refer to the Perl documentation for more info about
                # 'utime'
                # http://perldoc.perl.org/functions/utime.html

                if( !(utime(time, $mtime_s, $ffp_to_post_s)) )
                {

                    # $warn_level_l, and $resp_level_l are used to name
                    # the warning level and response level values
                    # that are passed to the handle_warning_and_response()
                    # routine.

                    # The purpose is to highlight these values, and
                    # make it more obvious what's happening in the call to
                    # the routine.

                    # The values are compared to the user configurable
                    # $config::warning_threshold.

                    # Whenever the level passed to the routine
                    # meets or exceeds the threshold
                    # value, the corresponding warning and response is
                    # generated.

                    # Typically warnings are output to the server logs
                    # and responses are included as part of the page returned
                    # to the visitor.

                    # (Refer to the handle_warning_and_response subroutine
                    # definition for more information.)

                    { # Naked block

                        my ($warn_level_l, $resp_level_l,);

                        $warn_level_l = $ode::min_error_level +1;
                        $resp_level_l = $ode::max_error_level;

                        &ode::handle_warning_and_response (
                            "Indexette : negotiate_index_dates",

                            "Couldn't set modification time for file:\n" .
                            "$ffp_to_post_s\n" .
                            "$!\n",

                            "Attempt to set mod time of post file failed.\n",

                            $warn_level_l, $resp_level_l
                        );

                    } # End, Naked block

                } # End, if( !(utime(time, $mtime_s, $ffp_to_post_s)) )

            } # End, if ($sync_mtime_with_tag_f)


            # If we make it here, we have found the index-date tag
            # thatwe were looking for, and successfully
            # converted the human readable tag value to the sort of
            # timestamp that is the expected value
            # for all of the pairs in the hash of all posts
            # assembled by the discover_posts routine.

            # This is the same sort of value originally passed into the
            # negotiate_index_dates routine.

            # We return this converted index-date tag value.

            return $mtime_s;

        } # End, if ($year and $month and $day)

        else
        {
            # As already stated in the comments
            # preceding the if clause above, this else should be entirely
            # unnecessary.

            # We execute this block only when the conditional expression:

            # ($year_s and $month_s and $day_s)

            # is not true, but $index_date_tag_found_s is true.

            # The value of $index_date_tag_found_s
            # cannot be true unless we have some defined value
            # for these variables
            # (and $hour_s, $min_s, $sec_s too).

            # This is here for the sake of completeness only.

            # (Still, it's hard to justify.)


            # $warn_level_l, and $resp_level_l are used to name
            # the warning level and response level values
            # that are passed to the handle_warning_and_response()
            # routine.

            # The purpose is to highlight these values, and
            # make it more obvious what's happening in the call to
            # the routine.

            # The values are compared to the user configurable
            # $config::warning_threshold.

            # Whenever the level passed to the routine
            # meets or exceeds the threshold
            # value, the corresponding warning and response is
            # generated.

            # Typically warnings are output to the server logs
            # and responses are included as part of the page returned
            # to the visitor.

            # (Refer to the handle_warning_and_response subroutine
            # definition for more information.)

            { # Naked block

                my ($warn_level_l, $resp_level_l,);

                $warn_level_l = $ode::min_error_level +1;
                $resp_level_l = $ode::max_error_level;

                &ode::handle_warning_and_response (
                    "Indexette : negotiate_index_dates",

                    "index-date tag found but appears to be incomplete " .
                        "or not properly formatted in file:\n" .
                    "$ffp_to_post_s\n" .
                    "Using post file modification time instead.\n",

                    "Attempt to read index-date tag failed. " .
                        "Tag appears to be malformed.\n",

                    $warn_level_l, $resp_level_l
                );

            } # End, Naked block

            # Because the index-date tag was malformed, it is not possible
            # to use the value of the tag.

            # So we resort to returning the same timestamp that was
            # originally passed into the routine.

            # (Remember that this is the post file modification time.)

            return $post_file_mtime_s;

        } # End, else

    } # End, if($index_date_tag_found_s)

    else
    {

        # If we did not find the index-date tag.

        my (
            $index_date_value_l,
        );


        # If there is no index-date tag, then
        # we'll want to use the post file modification time
        # as the post date.

        # This is easy enough to get, because this value
        # was passed into the
        # negotiate_index_dates() routine as
        # $post_file_mtime_s.

        # But before we simply return the value,
        # we need to add the missing
        # index-date tag to the post, using the provided timestamp
        # as the index-date value.


        # We need to create the tag.

        # We already know what most of the tag will look like.

        # Every index-date tag created by Indexette has
        # the form:

        # 'tag : Indexette : index-date : tag value'

        # We need to work on the tag value (the only part of the
        # tag that is not boilerplate).

        # More specifically, we need to construct a
        # human readable date (consistent with the expected format
        # of Indexette's index-date tag values)
        # from the modification timestamp that we have now.

        # Because there was no timestamp included in the original
        # post file, this is the mtime value that was
        # passed into negotiate_index_dates().
 
        # Perl's localtime fuction converts a timestamp value
        # to a 9 element list of values:

        # 0. $sec,
        # 1. $min,
        # 2. $hour,
        # 3. $mday,
        # 4. $mon,
        # 5. $year,
        # 6. $wday,
        # 7. $yday,
        # 8. $isdst

        # Note that these values _do_ treflect the local time zone.


        # We don't need all of these, so we use an array _slice_ 
        # to pick out of the list returned from localtime
        # only those values we need,
        # and then assign just those to $year_s, month_s, ...

        # Using the slice we pick out just 6 of the 9 values
        # from localtime,

        # We also use the slice to change the order of
        # the assignments, so that the order of variables being
        # assigned to runs from most general (year)
        # to more specific (sec).

        (
            $year_s,          # 5
            $month_s,         # 4
            $day_s,           # 3
            $hour_s,          # 2
            $min_s,           # 1
            $sec_s,           # 0

        ) = (localtime($post_file_mtime_s))[5,4,3,2,1,0];


        # The values returned from localtime are not quite what we want.

        # Some of these values need to be tweaked
        # to agree with expected values

        # For example

        # The value of $year_s as returned from localtime is
        # the number of years since 1900.

        # $year - the number of years since 1900, not just the last two digits
        # of the year.

        # The proper way to get a complete 4-digit year is simply:
        # $year += 1900;


        # We also pad the values at: day_s, hour_s, min_s, and sec_s

        # (So that we have nice consistent two digit values.

        # Ode's motto is 'simple means you know how it works',
        # but simple also means consistency and
        # predictability.

        # We could allow for both single
        # and double digit values here but there is no advantage
        # in doing so, and it adds an element of
        # unnecessary variability.)

        $year_s   += 1900;
        $month_s  = sprintf("%02d", ++$month_s);
        $day_s    = sprintf("%02d", $day_s);
        $hour_s   = sprintf("%02d", $hour_s);
        $min_s    = sprintf("%02d", $min_s);
        $sec_s    = sprintf("%02d", $sec_s);


        # Now that we have all of the components of our index-date tag
        # value, let's build the tag value,
        # and then assemble the entire index-date tag.


        # 'index-date' is the name of the tag Indexette uses to
        # record and maintain dates for post files.


        # The recommended standard format for tags is:

        # tag : Addin name : tag name : tag value


        # This includes:

        # The 3 character literal string 'tag'

        # The name of the addin

        # The tag name - An individual addin may support more than one tag)

        # The actual tag value - In the case of Indexette's
        #                        index-date tag, this is a human readable
        #                        post date.)


        # Each of these components of the tag are
        # separated by a single colon (:)
        # and any number of whitespace characters (0 or more).


        # Note that the index-date tag _does_ stick to this standard format.

        # tag : Indexette : index-date : [tag_value]"

        # 'tag' - The 3 character literal string 'tag'

        # 'Indexette' - The name of the addin

        # 'index-date' - The tag name

        # [tag_value] - The actual tag value


        # [tag_value] is just a placeholder. It will be replaced by
        # the actual tag value in the string
        # before the tag is written to each post.

        # Otherwise the index-date tag will appear in post files exactly
        # as written above.


        # The format of the value is:

        # Year Month Day Hour:Minute:Sec

        # For example:

        # '2010 04 28 16:43:09'

        # Substituting our variable names and continuing with the example
        # from above gives us:

        #   2010              28             43
        #    |                |              |
        # $year_s $month_s $day_s $hour_s:$min_s:$sec_s
        #            |              |               |
        #           04             16              09

        $index_date_value_l = "$year_s $month_s $day_s $hour_s:$min_s:$sec_s";


        # Now that we have the tag value, we're ready to construct
        # the complete tag and add it to the post.


        # ode.cgi includes a routine, add_tag(), that does the work of
        # forming the tag and adding it to the post
        # for us, when provided with all of the elements of tag.

        # 1. The name of the addin
        # 2. The tag name
        # 3. The tag value
        # 4. The full path to the post file.

        # The routine returns a true value when the tag is added
        # successfully, and undef when it is
        # unable to add the tag for some reason.

        if ( &ode::add_tag (
            'Indexette',
            'index-date',
            $index_date_value_l,
            $ffp_to_post_s) )
        {

            # Note: If add_tag reports that it was unsuccessful,
            # we skip this block,
            # and we're essentially finished.

            # We do not attempt to sync the modification time
            # of the post file with the
            # tag value we were unable to add
            # to the post.

            # (It doesn't make sense to keep the file modification
            # time in sync with a tag that does not exist.)

            # Also notice that we do not produce an error or otherwise
            # notify the user. The add_tag routine
            # takes care of those warnings and messages.

            # (It knows more about the problem than our simple
            # true/false return value is capable
            # of communicating.)


            # Finally, we've almost come to the end of this helper routine.
            # There is just one more thing to take care of.

            # If $sync_mtime_with_tag_f is true,
            # we need to attempt to update the modification time
            # on the post file to agree with
            # the index-date tag just added to the post file.

            # Is this necessary? After all the index-date value
            # is based on the modification time
            # of the post file.

            # Yes it is necessary.

            # To understand why, remember that the post file we have
            # now is actually the new file we created.

            # It only appears to be an updated version
            # of the original because it has the same name and is found at the
            # same path.

            # The index-date tag is based on the modification time of the
            # original post file before the changes we just made.
            # The modification time on the new file (masquerading as the
            # original post) is now (the current date/time).

            # We just edited this file, in fact we
            # just created it, and the modification time of the file
            # will reflect that activity.

            # If we want the modification time of the post file
            # to agree with the index-date tag value,
            # we must restore the original file's timestamp value,
            # which we have at $post_file_mtime_s.

            if ($sync_mtime_with_tag_f)
            {

                # IMPORTANT

                # The CGI user must actually own the post files in order to
                # be able to change the file modification times.

                # !Make sure you understand this point!

                # (Because of this restriction, the default value is
                # for $sync_mtime_with_tag_f is false.)

                # If we cannot change the file modification time,
                # we report it with
                # &ode::handle_warning_and_response().

                if ( !(utime(time, $post_file_mtime_s, $ffp_to_post_s)) )
                {

                    # $warn_level_l, and $resp_level_l are used to name
                    # the warning level and response level values
                    # that are passed to the handle_warning_and_response()
                    # routine.

                    # The purpose is to highlight these values, and
                    # make it more obvious what's happening in the call to
                    # the routine.

                    # The values are compared to the user configurable
                    # $config::warning_threshold.

                    # Whenever the level passed to the routine
                    # meets or exceeds the threshold
                    # value, the corresponding warning and response is
                    # generated.

                    # Typically warnings are output to the server logs
                    # and responses are included as part of the page returned
                    # to the visitor.

                    # (Refer to the handle_warning_and_response subroutine
                    # definition for more information.)

                    { # Naked block

                        my ($warn_level_l, $resp_level_l,);

                        $warn_level_l = $ode::min_error_level +1;
                        $resp_level_l = $ode::max_error_level;

                        &ode::handle_warning_and_response (
                           "Indexette : negotiate_index_dates",

                           "Couldn't set modification time for file:\n" .
                           "$ffp_to_post_s\n" .
                           "$!\n",

                           "Attempt to set mod time of post file failed.\n",

                           $warn_level_l, $resp_level_l
                        );

                    } # End, Naked block

                } # End, if ( !(utime(time, $post_file_mtime_s, ...

            } # End, if ($sync_mtime_with_tag_f)

        } # End, if ( ($add_tag_result = &ode::add_tag ...


        # Finally if we did not find the index-date tag in the post
        # originally, though we may have added it,
        # the return value is the same mtime value that was passed
        # to negotiate_index_dates() initially.

        return $post_file_mtime_s;

    } # End, else

} # End, sub negotiate_index_dates

1;
