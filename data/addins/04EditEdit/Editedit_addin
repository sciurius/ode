# ----------
# Editedit (Edited it) addin
# ----------

# + ---------------------------------------------- +
# | Author: Rob Reed                               |
# | ---------------------------------------------- |
# | Contact Info: rob at ode-is-simple.com         |
# | ---------------------------------------------- |
# | Project: Ode (pronounced oh-dee)               |
# | ---------------------------------------------- |
# | Website: ode-is-simple.com/                    |
# | ---------------------------------------------- |
# | Weblog: news.ode-is-simple.com/weblog          |
# | ---------------------------------------------- |
# | Forum: ode-is-simple.com/vanilla2_forum/       |
# + ---------------------------------------------- +

# If you have any questions about this addin please don't hesitate
# to ask.

# Either contact me directly or better yet bring your questions and 
# feedback to the form and discuss discuss them with me
# and the rest of the community of Ode users and developers.

# (But if you'd rather email, that's ok too! :)



# ----------
# License
# ----------

# Creative Commons Attribution-Share Alike 3.0 United States

# For more information refer to:
# http://creativecommons.org/licenses/by-sa/3.0/us/



# ----------
# Version Information
# ----------

# Current version
# ---
# Version: 1.0.0
# build: 2010_0927_00_00_01

# About this version:
# -----

# -


# Previous Version
# ---
# Version: pre 1.0.0
# build: 2009_1201_00_00_01
# About previous version: unreleased



# ----------
# Welcome Message
# ----------

# Welcome to Editedit version 1.0.0

# This is the first released version of the editedit addin, as such
# you should understand that there may be some issues.
# Having said that, I've been using editedit in one form or another
# for about a year now. (So it's not garbage either.)

# Please be aware that this addin is expressly intended to modify
# your post files.

# !As always, use Editedit (and Ode itself) at your own risk!


# Back up your site before installing the Editedit addin for the first time.

# I recommend that you backup your sites content directory
# before even installing Editedit to avoid
# the possibility of causing some harm which can't
# immediately be undone.

# Luckly backing up your content under Ode is as simple as
# creating a copy of your Ode site's content directory (which is specified
# in the config file as $document_root).


# Think about installing the Indexette addin (or something similar)
# before Editedit.

# You may also want to consider installing the Indexette addin which
# among other things adds a index-date tag to every
# post in order to preserve post dates.

# Otherwise post dates are determined from the post files
# modification timestamp and this value
# may be updated when you modify an existing post
# with the editedit addin.



# ----------
# Installation instructions
# ----------

# Installing Editedit should be relatively straight-forward.

# 1. Copy the addin itself to your Ode's addins directory

# 2. Copy the included '.edit' theme to one or more of your sites themes
# directories.

# 3. Make sure that the CGI user has both read AND write permissions to
# your post files.

# The CGI user is typically either the web server (i.e. the account
# that owns the web server process),
# or your user account (common with shared hosting).

# If the server does not have write permissions to your post files,
# Editedit will fail.

# (This should make sense to you.
# When you use editedit to modify your posts it is the webserver itself
# that's actually writing the changes.)

# If you run into any trouble, first ask yourself if it could be
# a permissions issue.

# 4. Finally, If you are installing or upgrading
# this addin you should take the time to read through the options in the
# configuration section below.



# ----------
# Upgrade info
# ----------


# General instructions
# --------------------

# Updating should be as straight forward as replacing
# this file with the updated version from the new release and setting
# the few options in the configuration section (below)
# to values appropriate for your installation.

# (Note that the is no separate configuration file.)

# Please make note of any configuration setting before deleting the current
# version of the addin.


# Version specific update instructions:
# --------------------

# You should not need to make any changes to the edit theme files
# when upgrading the Editedit addin.

# Of course you're welcome to do so, but it should not normally be required.

# (It is possible, even likely, that future updates will include
# modifications to the default edit theme.)

# If updating the theme is ever REQUIRED it will be clearly indicated in
# the included documentation.

# If you are installing or upgrading
# this addin you should take the time to read through the options in the
# configuration section below.



# ----------
# Usage instructions
# ----------

# Note: Though the following usage instructions refer to
# Markdown and the Javascript port of Markdown called Showdown, Editedit as 
# distributed actually includes support for 'Sh_wd_wn'
# which is a variation of the original Showdown code and uses a
# slightly different syntax.

# Sh_wd_wn is the Javascript version M_rkd_wn which is an altered
# version of the original markdown script
# (John Gruber's markdown.pl).

# M_rkd_wn (and Sh_wd_wn) differs from Markdown (and Showdown) in only
# three very specific ways:

# 1. M_rkd_wn changes the way underscores are interpreted for
# emphasis (both em and strong).

# 2. M_rkd_wn Expands the syntax for images under Markdown, adding the
# ability to specify height and width attributes.

# 3. M_rkd_wn allows for markdown-like conversion
# within block type elements by including the attribute/value pair
# markdown="1" in the opening tag.

# For more information read the weblog post introducing M_rkd_wn at:
# http://news.ode-is-simple.com/weblog/addins/m_rkd_wn/introducing_m_rkd_wn2010_0924

# What does this mean?

# Two things really:

# 1. You should expect the live previews generated by Editedit to behave
# in accordance with the M_rkd_wn syntax which differs from
# Markdown as described above.

# 2. If you want exactly match the apperance of
# the content on your site to the live previews that will get using Editedit
# you should use Ode's M_rkd_wn addin rather than
# the Markdown addin.

# If you would rather stick to the original Markdown syntax with previews
# to match you will need to replace substute the original
# showdown.js file for sh_wd_wn.js which is used by Editedit
# as distributed.

# To do that you will need to modify the 'page.edit' and 'page_no_posts.edit'
# file of the 'edit' theme included with the addin.

# Look for the script tag:

# <script
#  type="text/javascript"
#  src="sh_wd_wn.js">
# </script>

# IN BOTH FILES

# Change the value of the src attribute to 'showdown.js', like:

# <script
#  type="text/javascript"
#  src="showdown.js">
# </script>

# For your convenience I have included both
# sh_wd_wn.js and showdown.js files in the edit theme folder.
# All you need to do is point the script tag to
# whichever you prefer to use.


# Using Editedit is very 'Ode-esque' which I intend to mean simple and 
# straight-forward.

# The addin is actually two things:

# 1. The addin itself
# 2. A special theme

# The theme provides the interface (a form) which allows you to edit posts
# in a browser.

# The default theme is a little fancier than a basic form might be
# in that it supports previews of your posts.
# The previews are based on a Javascript port of markdown
# called Showdown created by John Fraser (http://attacklab.net/showdown/).

# Used together in this way Editedit and Showdown provide, in my opinion,
# a really nice way to edit and create posts in a browser
# that is at the same time as straight-forward and text-editor-like
# as possible, and also unqiuelu useful.

# As you type markdown formatting will be converted on the fly (by default)
# and you will see the rendered HTML in the preview pane
# complete with links, images, videos, etc that simply pop into place
# as soon as you finish typing the underlying markup.

# There is also an HTML preview so that you can see how the markdown is
# converted to HTML.

# Of course, the preview like markdown itself supports the use of HTML
# direcly. So if you'd rather write with HTML, and even if you don't install
# the markdown addin, you'll still benefit from the previews.

# OK, I'm getting a head of myself.

# Now that we know a little about what Editedit does, let's get back to
# talking about how to use it.

# As already mentioned, the addin includes a default theme called 'edit',
# which includes the form that you will use to create and modify
# posts.

# This means that the edit theme is the interface you will use to interact
# with the Editedit addin.

# You should also be aware that Editedit supports a number of configurable
# settings that affect the addin's behavior.

# Please familiarize yourself with these options!

# For example, the addin will not function until you specify a password
# (or turn off the password requirement).

# (You will find them in the configuration section below.)

# Because these options are described in detail in the configuration section
# I will not go over them here.

# I've already mentioned that the edit theme included with the addin the form
# used to edit and add posts via a browser.

# Otherwise it is similar to any other theme you might be using.

# To load the site using the theme simply append the theme name to the
# end of a file name in a URL that targets your Ode site.

# For example:

# http://sample.net/cgi-bin/ode.cgi/some_category/some_post.edit

# To view the same post before or after editing using the default theme you
# would just remove the theme name, like:

# http://sample.net/cgi-bin/ode.cgi/some_category/some_post

# To view the same page using some other theme, append the name of
# some other theme you have installed on your site:

# http://sample.net/cgi-bin/ode.cgi/some_category/some_post.some_other_theme

# Of course you're welcome to customize the edit theme however you see fit.
# The default theme is somewhat special in that it includes
# support for markdown enabled previews.

# If you take a look at the theme you will see that the edit theme folder
# includes a couple of additional components:

# showdown.js
# showdown-gui.js

# The edit theme files already include the necessary references for these
# Javascript files. You should not need to make any changes
# but you should be aware that they exist.

# (You can also rename it as you would any other theme - by
# changing the name of the theme directory and the file extension used
# on the theme files.

# Since using Editedit is all about the the edit theme. Let's look talk
# about the interface provided by the theme.


# Editing an existing post
# -----

# If you install the addin and theme and navigate to a page for an existing
# post using the edit theme:

# For example:

# http://sample.net/cgi-bin/ode.cgi/some_category/some_post.edit

# You will notice that the page is divided into two major sections.

# On the left you will see:

# 'Edit Post'

# On the right you have:

# Preview

# Under the Edit Post heading you have the following things (all of which
# are fairly self-evident):

# Title field
# Body field
# Password field
# A checkbox labeled: 'Add post'
# Another checkbox labeled: 'Set post date and time to now'

# I'm sure you can guess what the title, body, and password fields are for,
# so I'll keep my comments about these to a minimum.

# Keep in mind that an Ode post is a single text file which you can think
# of as containing 3 sections:

# The title
# An optional 'tags' block
# The body

# (These are logical sections. There is in fact no obvious separation
# between sections in the post file)

# Something like this:

# Title

# A tag line
# Maybe another tag line
# A 3rd tag line
# More tags

# Body

# Editedit splits the post and presents the title and body as separate
# fields.

# When the content is written back to the post file, everything in the title
# field will be the first line of the post, followed by
# everything in the body field.

# What about the tag lines?

# The tags will appear in the body field.

# Note: You may be aware that Ode's config provides a setting called
# 'show_tags' which allows you to specify whether
# tags should included on the page returned to the browser
# with post content.

# The default setting is false.

# This is because the tags are not content.

# They are bits of information and
# instruction useful to Ode or an addin, but not
# generally speaking, your visitors.

# However when using Editedit to edit the content of the post,
# these tags _are displayed_ regardless of
# the value of the show_tags setting. This is so you can edit the tag values
# along in a browser  also.

# (A convenient thing to be able to do.)

# The password field is just that. The value entered must agree with the
# value of the 'edit password' you specify in the
# configuration section below.

# A few important things to keep in mind about this password:

# Like all passwords used on the web, the password you provide here will
# be sent in plain text and openly visible to anyone
# monitoring the network, unless you encrypt it somehow.

# The usual way to do this is to configure your site (sensitive pages on your 
# site) to use SSL/TLS in combination with the normally
# insecure (i.e. unencrypted) HTTP protocol.

# This is referred to as the HTTPS protocol which you've probably
# seen in your browser's address bar.

# Compare:

# http://sample.net/cgi-bin/ode.cgi/some_category/some_post.edit

# https://sample.net/cgi-bin/ode.cgi/some_category/some_post.edit

# Setting up HTTPS on your site is beyond the scope of these instructions.
# It isn't extremely difficult to do but it can be challenging
# (translation: You can do it - if you really want to).

# You can read more about HTTPS on wikipedia.

# Here is the link to the wikipedia page for HTTP_Secure
# (2010/0928 5:56 PM EDT)

# http://en.wikipedia.org/wiki/HTTP_Secure

# This is really the best way to secure communications on the web.
# This issue is not specific to Ode and Editedit,
# but the same solution will work for us.

# What if you can't/don't want to deal with HTTPS?

# I'd argue that you can still use Editedit if you follow some guidelines:

# Guideline #1: Your editedit password should not be the same as any other
# password on your system - and ideally it should not be the same as any
# other password you use.

# I'll repeat that for emphasis:

# Your editedit password should not be the same as any other
# password on your system.

# The most you are risking if Editedit's password is exposed is the content
# of your website.

# Someone could edit your posts or create one or more new posts.

# That's not such a big deal (see guideline #2).

# But if the password you use is the same as your account password well
# then they could potentially do much more harm.
# If the password used is the same as an admin password on the system
# where Ode is installed, a bad guy might be able to:

# delete your entire operating system

# access files any other data on the system even data outside of your 
# webserver's document root (some of
# which may be personal or confidential)

# install malicious software

# To avoid this and limit the damage that could be done if someone intercepts
# your editedit password all you have to do is choose
# a password that is different from every other password you use.

# (It's really not that hard.)

# Guideline #2: Regularly backup your site.

# With a backup safely tucked away you can quickly restore your site should
# someone get a hold of your password.

# Fortunately, backing up your Ode site could not be any simpler.
# Make a copy of your entire site through your file manager, an SFTP client
# using a terminal based SSH connection, etc.

# (You can even automate the process to make regular backups using
# any number of utilities.)

# Moving on...

# That brings us to a couple of less obvious elements.

# The 'Add post' checkbox

# The 'Add post' checkbox has to do with the Indexette addin.

# If you are unfamiliar with Indexette, you may want to
# read more about it.

# There is a nice introduction on Ode's blog at:

# Quickly, Indexette does 2 things:

# 1. It's help to preserve post dates by breaking severing the connection
# between file modification timestamps and post dates.
# It does this by writing a tag to post file with the original file
# modification time and then referring to the tag line
# rather than the posat file modification timestamp going forward.

# 2. It maintains a simple index of all posts on the site
# and then reads the index to discover posts rather than traversing the
# filesystem directly.

# Whenever a new post is created it must be added to the index - otherwise
# the addin would have to scour the filesystem looking
# for posts not already in the index (thus defeating the purpose).

# A new post can be added to the index by
# loading the page corresponding
# to the new post and including the add_post parameter
# with the request, for example:

# http://sample.net/cgi-bin/ode.cgi/some_category/new_post?add_post=y

# Or alternatively using including the reindex parameter with any request:

# http://sample.net/cgi-bin/ode.cgi/?reindex=y

# The reindex parameter causes the entire index to be rebuilt so it is
# not necessary to target the new post explicitly.

# Checking the 'Add post' box causes the addin to
# include the add_post parameter to the URL when the Save edit button is 
# clicked.

# This in turn causes the page to be added to the index.

# To be clear, it's not necessary to select the 'Add post'
# box when editing an existing post (although
# doing so won't cause any harm).

# If you are not using the Indexette addin you can
# ignore the check box altogether or edit the theme to remove it entirely.

# The 'Set post date and time to now' checkbox

# I've already mentioned that Ode uses post file modification times as
# for post dates in the absence of the Indexette addin
# (or something similar).

# This is convenient and probably what you want when you first create a
# post at which time the file modification time
# would be the same as the file creation time which is what we
# normally consider to be the post date (i.e. the date the post was created).

# But whenever the post is edited the file modification time changes
# and so does the post date,
# which is probably not what you want.

# Editedit includes a configuration option titled: $restore_file_mtime.
# When true the addin will store the original
# modification time before editing a file, and then restore that time
# afterward. Because the file modification time effectively
# remains the same, the post date will also remain the same. This sidesteps
# the issue when using Editedit to modify your posts.

# When $restore_file_mtime is true, checking the 'Set post date and time to 
# now' box will cause the file modification time to
# be set to the current date (as would happen if $restore_file_mtime
# were false).

# This allows you to update the post date should you want to do that.

# When $restore_file_mtime is already false the checkbox does nothing.
# Also, if using the Indexette addin, or something similar,
# the checkbox and also the $restore_file_mtime option itself are
# irrelevant and will not have any impact on the post date
# because Indexette causes Ode to use an index-date tag stored in the post
# itself rather than the file modification times.

# (This checkbox too can be removed by editing the theme the edit theme.)

# After you have edited your posts, clicking
# the 'Save edit' button will submit the changes to Ode which will attempt to
# update the  corresponding post file and
# reload the page.

# Editing a new post
# -----

# Creating a new post is exactly like editing an existing post.

# Rather than targeting the address of a post that already exists,
# like:

# http://sample.net/cgi-bin/ode.cgi/some_category/an_existing_post.edit

# Simply navigate to a page corresponding to a post
# which does not exist.

# For example:

# http://sample.net/cgi-bin/ode.cgi/a_new_category/some_new_post.edit

# The page will load and you'll be presented with an empty form.
# At that point you can type the title and body of
# the new post.

# If you're using the Indexette addin you will want to
# check the 'Add post' box to add the new post to the index (as already
# discussed).

# The addin will create the new post.

# It will also create the path to the post if some portion of the path
# does not already exist.

# That covers the 'Edit Post' portion of the theme.

# The other major section of the page is titled 'Preview'. Let's look at
# that next.

# The 'Edit Post' section includes the following elements:

# A drop-down list
# A non-editable text field
# A second drop-down list
# A 'Convert text' button

# Here the text-field displays the preview of the editable content in
# the body field under the 'Edit Post' heading.

# Yes this means that the title line is not included in the preview.
# I would advise you to keep titles as straight-forward
# as possible to avoid the kind of strange formatting issues that can
# arise when the content of your site appears in feed readers
# and in other web services which may not support
# fancy formatting, links etc.

# The title is not included in the preview to emphasis that the title
# should not need to be converted.

# In other words, with the title it's what you see is what you get, and
# so there is no need for a preview.

# You will see three options in the drop-down list:

# 1. Markdown
# 2. HTML
# 3. Last Revision

# These are all fairly self-explanatory.

# 1. Markdown

# When Markdown is selected you will see a rendered version of the body
# complete with the conversion of Markdown formatted content.

# For example if you typed an link in the body field like:

# [an example](http://example.com/ "Title")

# You would see the clickable link in the Preview pane in place of the
# markdown code.

# 2. HTML

# Selecting HTML will cause the preview pane to display the raw HTML
# corresponding to the content of the body field.

# For example if you typed an link in the body field like:

# [an example](http://example.com/ "Title")

# Selecting HTML in the drop-down list will display:

# <a href="http://example.com/" title="Title">an example</a>

# 3. Last Revision

# Selecting Last Revision will cause the preview pane to display the
# version of the body as it was before the changes
# made in the body field. In other words it will show you what the
# saved post looks like (before any changes you may have
# just made.)


# I've already said that the non-editable text field displays the content
# of the body field in the Edit Post section of the page.

# This provides a live preview of the post as it is being edited.

# You have to choice of seeing the rendered content, the raw HTML source,
# or the last revision of the post before any changes
# you may have just made.

# The drop-down list below the preview pane includes the following options:

# in the background
# every keystroke
# manually

# The selection here determines how the conversion in the preview pan happens.

# Though they are different:

# 'in the background' and 'every keystroke'

# both effectively mean automatic or live. As you type
# in the body field of the Edit Post section of the page, the preview is kept
# up to date with the changes as you are making them.

# I'd guess that this is usually what you want but it can be annoying esp
# if you are modifying images, video, or other large
# (in terms of dimensions) elements of the content of the post.

# In such cases the content in the preview may seem to jump around wildly.

# Switching to 'manually' disables the 'live' part of live previews.

# The content of the preview pane will not update automatically as you type.
# Rather it will remain static until you click
# the 'Convert text' button which will cause the preview to update
# to reflect recent changes.

# (The Convert text button is only meaningless when 'manually' is selected
# in the drop-down list.)

# That should pretty describe how to use Editedit.

# Don't hesistate to contact me if you have any questions or feedback.



# ----------
# Additional Information
# ----------


# Though Editedit does include some nifty features, it is intended to be a
# relatively limited interface.

# Why? 

# There are two primary reasons

# 1. Editedit is best used for quick posts and edits, and uncomplicated
# interface means a minimum about of fuss.
# Working with Editedit should be as straight-forward and involve as few
# steps as possible.

# Honestly, I'd like to interacting with Editedit as minimal as possible.

# Ideally it would be just a textfield for editing and a preview.

# I don't believe it can actually be quite that simple.

# It needs to allow for passwords,
# a couple of options, and maybe should a very small number of
# other niceties.

# The goal is not to make Editedit a feature rich editor!

# 2. Even if I spent the rest of my life building features into Editedit,
# or if I could hire a team of developers,
# all of them better than me, and have them work on it for years,
# and we still wouldn't come close the functionality
# of even a middling text editor.

# Key to Ode's 'simple is best' philosophy is taking advantage of all
# of the other software and services available to us.

# In this way we can keep Ode itself understandable,
# while also keeping in step with you might want to do with Ode today,
# tomorrow and beyond.

# My advice is that you continue to some other editor to write
# long or complicated posts and
# use Editedit for short posts and minor edits.

# Think of Editedit as Ode's version of
# Twitter - great for approx 140 character (well maybe 1 - 500 characters)
# posts but probably not ideal
# for anything considerably longer.



# ----------
# Requirements and Other Important Info
# ----------

# 1. As always, use Ode and Editedit at your own risk!

# ---

# 2. This version of Editedit requires version 1.2.3 of Ode (or later).

# ---

# 3. Before you attempt to use Editedit, read through the installation
# instructions, and any other information
# included with the addin.

# It's author (me) spent considerably more time writing it than
# you will spend reading it,
# and probably for good reason.

# Sure it may take a moment or two to read through
# the included documentation,
# but you may actually save more time than you spend by avoiding
# time-consuming mistakes.

# ---

# 4. Be aware that the purpose of Editedit
# is to allow you to create and edit the content of your site
# using a form in a web browser.

# There is some amount of risk involved in that of course.

# For one thing, it requires that the web server have write permissions
# to your post files.

# The reason for this requirement should be intuitively obvious.

# (The server must be able to modify your post files
# on your behalf in order for you to be able to edit posts in a browser based
# form.)

# How dangerous is it?

# Honestly, as long as you're backing up your site, I wouldn't worry too much
# about it.

# If something goes terribly wrong, you can always delete the entire
# document directory and restore (i.e. copy) it
# from backup.

# If you're not backing up your site I wouldn't recommending using editedit,
# but then again I don't advise using Ode at all
# unless you are making regular backups of your site's content.

# Another advantage of Ode's 'simple is best' design philosophy is that
# backing couldn't be any more straight-forward.

# Simply make a copy of your site's document directory
# (i.e. the directory containing your post files). Preferably save the copy
# to a machine other than your web server.


# More about backup (because it's that important)

# Always keep in mind that you should backup ALL of your files
# - whatever they might be
# whether on a web server, laptop hard drive,
# optical disc, etc.

# Backup is the single most important
# computer related task you can do today (and that's
# true every day).

# Using Ode and Editedit doesn't mean an additional
# requirement that you backup your site, because you should be doing that
# already!

# Ode does make it is simple as possible to backup, and that's a very
# good thing.

# You should make routine backups of your Ode site.

# Ideally you should automate the process
# so that it will happen without you having to remember to do it,
# or taking any special action
# after the backup process is put in place.

# As long as your web server is not your only computer
# (which is not a good idea),
# you can always backup to your local computer.

# If your local computer is running a routine backup,
# which it should be, your site's content will be included as part of that
# backup.

# If you follow this advice, backing up
# your Ode site is no different than backing up any of
# your other files.

# This has the added advantage that it makes migrating to a new hosting
# provider or reinstalling Ode a trivial matter.
# Simply 'restore' (i.e. copy) the site to it's new home
# and you're done.

# Simple really is best.

# ---

# 5. - 

# ----------



# ^ Info
# --------------
# v Beginning of source code



package Editedit_addin;


use strict;

use File::Spec;
use CGI qw/ :standard /;


our (
    $version, $form_password_g, $form_title_g, $form_body_g,
);

# Ignore for now. (Intentionally kept.)

# our (
#   $form_tags_g
# );


my (
  $restore_file_mtime_bf, $require_password_bf, $edit_password_f,
  $edit_theme_name_f, $tmp_file_ext_f, $post_file_extension_f, 
  $preferred_newline_f, $restrict_by_addr_bf, @allowed_addresses_f,
  $sandbox_enabled_bf, @sandboxes_f, @partial_paths_to_new_post_f,
  $last_password_f,
);


$version = "1.0.1";



# CONFIGURATION SECTION -----------------------------------------------------



# -------------
# Preserve file modification time, $restore_file_mtime_bf (Boolean)
# -------------

# Preserve file modification time before editing and restore after editing
# when true.

# This option is interpreted as a Boolean:

# 1 - (true), The modification times of post files are saved before editing
#             and restored after.

# 0 - (false), Modification times of files will be updated
#              (to the time the edit is made).

#              Note that this is the usual behavior you would expect to get
#              from the underlying OS, i.e. typically
#              editing (modifying) a file updates its modification time.


# Ode is very sensitive to file modification times.

# Left to Ode's own devices, these values
# dictate post dates and also the ordering of posts on the pages returned to 
# the client.

# For example, by default posts are displayed in
# a descending numerical order based on post file modification times
# (this is the traditional order for a weblog style site,
# with newest posts listed first.)

# It makes sense that we might want to preserve these modification times
# under Ode.

# Regardless, it is true that
# editing a post file should update its modification
# time.

# Modifying a post should update the file's modification timestamp.

# We can resolve this apparent conflict in other ways.

# For example, the Indexette addin (distributed with Ode) preserves
# the original modification time as a tag in the post itself.

# (Refer to the Indexette addin for more information.)

# It is recommended that you do not preserve modication times here.

# Why?

# For one thing, it's only an incomplete solution.

# Posts modified using an editor (rather than the web form provided by
# the Editedit addin) will have their modification times updated,
# regardless of the value of this variable (because those edits do not
# involve the Editedit addin).

# Indexette's solution is a better one.


# Recommended value:
# 0

# default value:
# 0

# Example:
# $restore_file_mtime_bf = 0;

# -------------

$restore_file_mtime_bf = 0;

# -------------


# -------------
# Require a password to edit this site, $require_password_bf (Boolean)
# -------------

# Require a password (set below) to edit posts using this addin when true.

# This option is interpreted as a Boolean:

# 1 - (true), A password is required to edit posts

# 0 - (false), No password is required.

# Your choice here is determined by the type of your site.
# Not requiring a password (and optionally
# supplying an 'Edit this post' link) allows you to create
# a simple 'wiki-style' site, where any anonymous visitor can add and edit
# content.

# On the other hand, requiring a password means that only you,
# (and of course anyone else who knows the password),
# is allowed to add and edit entries.


# Recommended value:
# 1

# Default value:
# 1

# Example:

# $require_password_bf = 1;

# -------------

$require_password_bf = 1;

# -------------


# -------------
# Password, $edit_password_f
# -------------

# The value of $edit_password_f is the password required to edit posts
# using a browser based form with this addin.

# It is highly recommended that your Editedit password be different than any
# other password used on your system!

# (See the usage instructions included with this addin for more info.)

# Keep in mind that this password is sent as clear text.

# This means that it is _trivially easy_ to intercept the password
# while en route from your computer to the server.

# You can dramatically improve the security of Editedit
# by setting up SSL at your server,
# which will allow you to encrypt all traffic while editing your blog
# (including your password).

# Having said that, assuming you choose a unqiue password, the most you are
# putting at risk is the content of your site.

# If you are confident in your backup strategy,
# and you are willing to accept the downtime resulting from someone
# compromising your site until you're able to restore
# (e.g. defacing your site or deleting content), you may decide that the risks
# involved are acceptable to go without SSL.

# SSL is not too terribly difficult to set up.

# Please put in the relatively small amount of time and effort required
# if you can.

# You'll only need to set it up once.


# Regardless, please be careful to choose a good password.

# Some simple guidelines:

# Your password should:

# 1. Be unique (i.e. not the same as any other password you use),
# 1. Be at least 8 characters long (preferably more),
# 2. Not be a word in any dictionary,
# 3. Use a combination of upper and lowercase alpha characters and digits,
# 4. Not be associated with you in any way,
# 5. Not be based on a visual cue related to the context in which you
# use your computer.

# Again, create a special password for editedit and do not use the
# same password for any other purpose!


# Note: Do not use the example password below as the password for your site!
# It's an easy password to guess because anyone with a copy
# of this addin has access to the same example.

# (It's the first password I'd try if attempting to compromise your site.)


# Default value:
# ''

# Example:
# $edit_password_f = 'nR83Dk11';

# -------------

$edit_password_f = 'ikke';

# -------------


# -------------
# Editedit theme, $edit_theme_name_f 
# -------------

# Specifies the theme name used in combination with this addin.

# The addin is only active when the theme specified here is requested.

# For example:

# http://sample.net/cgi-bin/ode.cgi/some/category/hierarchy/ \
# some_post.edit

# The default 'edit' is the name of the theme distributed with the addin.


# Default value:
# 'edit'

# Example:

# $edit_theme_name_f = 'edit';

# -------------

$edit_theme_name_f = 'edit';

# -------------


# -------------
# Temporary file extension, $tmp_file_ext_f
# -------------

# The editedit addin does not directly edit a post file.

# Instead it goes through the following series of steps which ensures
# that we don't lose the original before the
# edited file is successfully written.

# 1. The addin creates a new temporary file.

# 2. Next, it writes the update to the new file (leaving the original intact).

# 3. It remove the original file only after it is certain that
# the new file has been written successfully,

# 4. Finally, it gives the temporary file the name of the original.

# In the end we have a file with the same name as the original
# containing the updated content.

# It is as if we simply edited the file directly but without the risk of
# directly overwriting the file.

# This option allows you to specify the file extension that will be
# assigned to the temporary files created by Editedit.

# The option is necessary because Editedit creates
# it's temporary files in the same directory as the original and assigns
# them the same name.

# (This will come in handy if we ever need to
# manually resolve an issue related to the use of these temp files.)

# Because there cannot be two identically named files
# in the same directory we change the file extension to something other
# than the extension used with post files.

# You're free to choose any file extension you like but I recommend you stick
# to the default, or something like it.

# Notice that the default value includes the name of the addin
# that created it (editedit).

# There are two reasons for doing this.

# First, we can easily associate the files with
# the addin that created them. If these files are not being deleted for some
# reason (as they should) we know immediately
# where to look for the problem. 

# Secondly, by following this simple rule, we can avoid name conflicts among 
# any number addins, even as we create arbitrary
# files like this.

# Because there can only be one 'editedit' addin installed at a given
# time, there can be only one addin
# creating files that include the 'editedit'
# as part of the file extension.

# (Of course this assumes other addins are following the same simple rule.)


# Recommended value:
# 'editedit_tmp'

# Default value:
# 'editedit_tmp'

# Example:
# $tmp_file_ext_f = 'editedit_tmp';

# -------------

$tmp_file_ext_f = 'editedit_tmp';

# -------------


# -------------
# Post file extension, $post_file_extension_f
# -------------

# Specifies the extension Editedit appends to the name of new files.

# With Editedit it is not only possible to edit existing posts, but also
# create entirely new posts.

# For example: 
# http://sample.net/cgi-bin/ode.cgi/weblog/some/ \
# category/hierarchy/some_new_post.edit

# If some_post does not already exist, it will be created.

# Notice that the request specifies the desired name of the post but not
# the file extension.

# (Keep in mind that 'edit' isn't the file extension,
# it's the name of the requested theme.)

# It makes sense that the extension used for files created with Editedit
# should agree with the file extension that Ode recognizes as the
# post file extension.

# Otherwise, Ode will not see the new file you create as a post.

# For this reason the default value here is:
# $config::post_file_ext

# You are free to change this value, if you have some reason for doing so.


# Recommended value:
# "$config::post_file_ext"

# Default value:
# "$config::post_file_ext"

# Example:
# $post_file_extension_f = "$config::post_file_ext";

# -------------

$post_file_extension_f = "$config::post_file_ext";

# -------------


# -------------
# Preferred end of line character (newline), $preferred_newline_f
# -------------

# Dealing with the line ending differences between platforms and related
# issues can be a surprisingly sticky issue.

# At the risk of oversimplifying I'll keep this brief to avoid getting
# bogged down in a lengthy discussion.

# For more information about this issue you might want to check out:

# The Perl information and newlines and cross-platform issues related
# to newlines in the perlport documentation:

# http://perldoc.perl.org/perlport.html#Newlines

# The Wikipedia entry for 'newline' is a nice introduction to the topic
# and related issues:

# http://en.wikipedia.org/wiki/Newline

# Different platforms (Unix-like operating systems, Windows,
# Classic Mac OS, etc) do not agree on the
# on the same representation of the newline sequence.

# This does not cause problems when working on only one system,
# or even multiple systems of the same type.
# However, it can be a problem when sharing files between
# platforms.

# Perl uses '\n' to represent a logical newline in an attempt to deal with
# line endings in a portable way.

# What does that mean?

# From the perlport documentation:

# Perl uses \n to represent the "logical" newline, where what is logical may
# depend on the platform in use. In MacPerl, \n always means \015.
# In DOSish perls, \n usually means \012 , but when accessing a file
# in "text" mode, perl uses the :crlf layer that translates it to (or from)
# \015\012 , depending on whether you're reading or writing.
# Unix does the same thing on ttys in canonical mode. \015\012 is commonly
# referred to as CRLF.

# This is not a perfect solution for our purposes however.

# Why?

# Because when it comes to Ode, the platform used by
# the system running Ode is less important than the primary platform the
# author or site maintainer is using to write
# and edit posts.

# Let's say that I use Ode as a platform for my weblog.

# Further let's say I use a hosting provider and the site is running on
# some unix-like system, but I do all of my writing on a Windows 
# laptop.

# When I create a new post, the file will use Windows native
# line endings. When I edit posts from my computer via a text editor, those
# line endings will be preserved.

# However if I edit an existing post using Editedit Perl will want to update
# the line endings so that they are native to the system
# on which Ode is running. When I open those files up again in a text
# editor, I may be surprised to find that the line endings
# have all changed.

# This is also a problem when I create a new post with Editedit.

# Though many editors are capable of recognizing all common line endings,
# this can sill be a bother.

# Use the $preferred_newline_f option to get the behavior that makes sense to
# you and your situation.

# You can specify a particular line ending or '\n'.

# Use '\n' to instruct Editedit to let Perl handle newlines on its own.

# The vast majority of people will want to stick to one of these choices:

# Windows: '\015\012'
# Unix-like (MacOSX, Linux, BSD, ...): '\012'
# Default behavior: ''


# Default value:
# ""

# Example:
# $preferred_newline_f = "\n";


# -------------

$preferred_newline_f = "";

# -------------


# -------------
# Restrict editing by address, $restrict_by_addr_bf (Boolean)
# -------------

# Restrict editing to a white list of addresses (specified below) when true.

# This option is interpreted as a Boolean:

# 1 - (true), Only clients associated with one of the IP addresses
# specified in the list below are allowed to edit posts using the addin.

# 0 - (false), Clients are not restricted on the basis of IP address.

# Note: It would be nice if I could recommend using this option
# to limit editing to a small subset of IP addresses.
# Unfortunately, the reality is that it is difficult if not impossible to
# predict with any precision what IP address you might want to use
# from day to day (or even hour to hour).

# There are primarily two factors impacting the persistence of IP addressing.

# 1. Dynamic addressing using DHCP is the norm these days, which means that
# even on the same network your address may change
# from one moment to the next.

# Many DHCP servers are configured to change addresses
# only very infrequently but:

# a) this isn't dependable,
# b) even if the address changes only once a week, or once a month,
# it might still be a bother if that change happens
# at just the wrong time.

# OK so it may still work if you primarily edit posts on your home network
# where your IP address may be somewhat predictable, right?

# 2. Using a web form to edit content of your site is particularly appealing 
# when you are away from the computer
# or the network you normally use, e.g. when traveling with a laptop, at a public internet connected computer, etc.

# This means that if you restrict posting by IP address
# it's very likely that you'll prevent yourself from using this addin on just 
# those occasions when you need it.

# For these reasons, it is recommended that you leave this option off.

# As a final note, keep in mind that you need to use your public IP address
# not the private IP that you need to add to the whitelist
# to use the addin when $restrict_by_addr_bf is true - because it is
# the public address that is seen by the server.

# (Unless webserver is on your local network and then I'm sure you
# know what to do.)


# Recommended value:
# 0

# Default value:
# 0

# Example:
# $restrict_by_addr_bf = 0;

# -------------

$restrict_by_addr_bf = 0;

# -------------


# -------------
# Addresses which are permitted to edit content, @allowed_addresses_f
# -------------

# @allowed_addresses_f is a whitelist of all IP addresses
# which are allowed to edit posts using Editedit when $restrict_by_addr_bf
# is true.

# (When restrict by IP address is false the list is ignored.)


# Addresses must be numeric.

# (This is to avoid the undependable nature of name resolution
# as well as the overhead).

# Numeric addresses do not need to be specified completely.

# For example:

# The following will allow this single address on the T-Mobile network:

# 208.54.95.179

# On the other hand, the next example will effectively allow the
# entire class C block ('208.54.0.0 - 208.54.0.255'):

# 208.54.0.


# Be careful with this, classful addressing is no longer the norm.
# It is inappropriate to see the IP universe
# as divided into neatly packaged A, B, C classes.

# Again the idea is to list IP addresses which ARE allowed to edit the site
# through a web browser using the Editedit addin.

# Separate NUMERICAL addresses by whitespace - blanks, newlines, etc ONLY.

# (Do not use commas or any other delimiter.)

# 127.0.0.1 will restrict editing to the local machine only.

# This is a good choice if you are running your ode site from a personal
# computer such that the server is always local.

# Default value:
# 127.0.0.1

# Example:
# @allowed_addresses_f = qw(
#   127.0.0.1
# );

# -------------

@allowed_addresses_f = qw(

  127.0.0.1

);

# -------------


# -------------
# Enable sandbox mechanism, $sandbox_enabled_bf
# -------------

# In this context a sandbox is an area of your site
# (under Ode's document root) where visitors
# are allowed to edit existing posts or even create entirely new post files
# without entering a password.

# If you think this sounds like a bad idea well then it probably is.

# Always keep in mind that Ode is not a wiki.

# Modern wikis typically provide quite a few features which are intended to
# prevent abuse, track changes and undo (revert)
# any damage done.

# Ode and Editedit do not provide any of these features.

# You should probably leave the sandbox features disabled unless you
# have a very good reason for doing otherwise.
# (It is disabled by default.)

# The value of this setting is a boolean which enables or disables the
# sandbox feature.

# If the value is 1 sandboxing is enabled, and whe
# the value is 0 it is disabled.

# Enabling the sandbox feature is not enough to use it. You must also
# specify one or more sandboxes.

# This is done with the 'sandboxes' option below.


# To be clear, in order to create a useable sandbox you must:

# 1. Enable the feature by setting the value of $sandbox_enabled_bf to 1
# here.

# 2. Specify at least one directory in the list of sandboxes below.

# Setting up a sandbox does not mean exposing your password to visitors
# or setting up a shared
# password for visitors to use.

# When the feature is enabled and a change is submitted
# which targets a post within a directory included in the list of sandboxes, 
# Editedit simply ignores the password requirement
# altogether.


# Recommended value:
# 0

# Default value:
# 0

# Example:
# $sandbox_enabled_bf = 0;

# -------------

$sandbox_enabled_bf = 0;

# -------------


# -------------
# Sandboxes, @sandboxes_f
# -------------

# @sandboxes_f is a list of any and all directories which
# Editedit should treat as sandboxes
# whenever the sandbox feature is enabled.

# Think of each element the list as pattern which is matched against
# the a given path.

# Whenever the pattern is found along the path to a post being edited,
# the addin ignores the password requirement
# and allows the change.

# For example, let's say that the list includes a single element
# '/sandbox/'.

# The addin atttempts to match this string against the path to the post file
# whenever an edit is made.

# If the pattern is found the change is made, and if the pattern is not found
# then Editedit makes the change only if the user has demonstrated
# (s)he is authorized to do so
# (e.g. by supplying the correct password).

# Continuing with the example, let's look at a couple of requests:

# /Library/WebServer/documents/ode_site/path/to/sandbox/some_post.txt

# An attempt to edit 'some_post.txt'
# without a password would be allowed because that post file is inside a
# sandbox.


# /Library/WebServer/documents/ode_site/sandbox/with/subdirectories/ \
# some_post.txt

# Again, editing 'some_post.txt' would be allowed because it is inside
# a sandbox. It's important to note that subdirectories of a
# sandbox are also sandboxed.

# Lastly, keep in mind that only one of the sandboxes in the list
# needs to match.

# If the list included two strings 'sandbox', and 'something_else', then
# the following two directories would both qualify:

# /Library/WebServer/documents/ode_site/path/to/sandbox/some_post.txt
# /Library/WebServer/documents/ode_site/path/to/something_else/some_post.txt

# As would

# /Library/WebServer/documents/ode_site/path/to/something_else/sandbox/ \
# some_post.txt

# If you do specify one or more sandboxes I recommend that you
# list each on a separate line.

# Separate each sandbox pattern by whitespace - blanks, newlines, etc ONLY.

# (Do not use commas or any other delimiter.)

# Though not required, it's probably a good idea to list one entry per line.

# IMPORTANT

# Each sandbox entry must _begin and end_ with a path delimiter
# (a forward slash).

# This is a requirement so that we don't need to worry about matching
# partial directory names in unanticipated ways.

# The following are all _invalid_ sandbox specifications:

# 'sandbox'
# 'sandbox/'
# '/sandbox'
# '/sand/box'

# Keep in mind that the sandbox feature is disabled by default
# and should probably be left that way, unless you have a good reason for
# turning it on.


# Recommended value:
# @sandboxes_f = ();

# Default value:
# @sandboxes_f = (
#   sandbox
# );

# Example:
# @sandboxes_f = qw(
#  /sandbox/
#  /a_second_sandbox/
# );

# -------------

@sandboxes_f = qw(

  /sandbox/

);

# -------------


# END CONFIGURATION SECTION -------------------------------------------------



# The values of title and body are either supplied by the author
# via web form, or read from an existing post file
# and used to pre-populate the web form so that content of an existing post
# can be edited.

# The initial value of both variables is undefined.

$form_title_g = $form_body_g = undef;


# $last_password_f is used to preserve the most recently submitted
# (successful) password, so that posts can be
# repeatedly edited for any one session (while the browser window
# displaying the form is still open),
# without requiring the paassword to be typed repeatedly.

# The string is fed back to the edit form's
# password field with the result that the value is pre-populated
# when the page is reloaded.

# (This happens without Ode retaining the password attempts.)

# Initially $last_password_f is empty. The value is supplied
# as part of the browser form submitted by the author.

$last_password_f = '';


# ----------
# ADDIN INTERFACE: inventory_ping_response
# ----------

# Each addin file *must* include an inventory_ping_response
# routine.

# (inventory_ping_response is the only required routine.)


# Parameters: 0
# ---------

# -


# Return values: 1
# ---------

# 1. A Boolean true or false value.

# true : An addin's inventory_ping_response routine
# returns true when the addin should be
# considered active.

# !All of its other routines given the opportunity to run!


# false : A return value of false indicates that the addin should be 
# considered inactive.

# !All of its other addin routines will be skipped!


# Precisely how and for what reason it is determined that
# an addin's inventory_ping_response routine
# returns true or false is entirely dependent on the unique nature
# of the addin itself.


# An addin which should always be run whenever it is installed,
# regardless of request, may include
# a very simple inventory_ping_response routine
# which always returns true.

# For example, the following is a
# perfectly valid inventory_ping_response() routine
# for an addin which should
# always run without exception.


# sub inventory_ping_response {
#   1;
# }


# Other inventory_ping_response routines may be
# quite a bit
# more complicated.



sub inventory_ping_response
{

  my (
    $ffp_to_post_s, $ffp_to_temp_file_s, $in_sandbox_bs, 
    $matched_allowed_address_bs, @path_components_s, $fs_path_wo_file_s, 
    $ffp_to_new_post_s, $initial_mask_s, $first_new_dir_created_bs,
    $error_creating_path_to_post_bs, $file_title_s, $file_body_s, 
    $title_to_file_s, @tag_lines_to_file_s, $tags_to_file_s,
    $body_to_file_s, $post_file_exists_bs, $file_mod_time_s, $line_s,
    $file_tags_s,
  );


  # The purpose of the editedit addin is to mediate between a browser
  # based form (presented by a specially designed
  # theme intended to be used in combination with editedit)
  # and a post file.

  # What does this tell us about when the editedit addin should run?

  # Well, it means that we can return a false value from editedit's
  # inventory_ping_response routine when:

  # 1. The current request is not a post type request.

  # We aren't editing a a post
  # if this is a category request (or request for
  # the site root).

  # Given how early in the execution of the script
  # inventory_ping_response routines are run,
  # we only have access to a minimal amount of info about
  # the request to work with.

  # For example, we can only refer to request components as they are
  # submitted (which I'll refer to as '_at_sub' values),
  # not the finalized values of these variables.

  # Ode itself and or other addins may modify the initial values
  # for some reason.

  # This means that haven't done a lot of the work that will be done
  # to set up the values used
  # throughout the execution of the script.

  # So first, we have to be careful.

  # Secondly, we'll have to do more
  # work than we would if were working in one of the other
  # interface routines.

  # This is the first place we encounter this issue.

  # To determine if this is a request for a post we check both that
  # the request includes a filename (which would be
  # the name of the specific post being requested) and that the
  # name is not 'index'.

  # If $ode::req_components_at_sub{filename} is undefined then we know
  # this is a category or root type request.
  # If $ode::req_components_at_sub{filename} is defined
  # it means that this is a post type request,
  # unless the requested filename is 'index'.
  
  # Under Ode the filename 'index' is treated as special.

  # Using the filename index is an alternative way of telling the script
  # that we want a page corresponding to
  # the category requested.

  # It is NOT a request for a post file with the title
  # "index.$config::post_file_ext"
  # (e.g. index.txt).

  # Request that include the filename
  # 'index' and corresponding category requests
  # are synonymous.

  # For example, the following 2 requests are interpreted as being
  # the same request:

  # http://sample.net/cgi-bin/ode.cgi/some/nested/categories/
  # http://sample.net/cgi-bin/ode.cgi/some/nested/categories/index

  # Before these request component values are finalized, the value of
  # the filename key is undefined for index requests.

  # So, if this were not an inventory_ping_response routine
  # we would need only check that
  # req_components_final{filename} is defined
  # to determine that this is a
  # post type request, but here we need to
  # check that the value is defined AND not 'index'.

  # So this needs to be file type request. As just discussed,
  # this means checking
  # $ode::req_components_at_sub{filename}

  # Is that the only condition?

  # No, we must also be concerned about the name of
  # the requested theme.


  # I've already said that editedit's job is brokering between a browser
  # based form and a post file.

  # What's the form?
  
  # It must be included as part of Editedit's theme, which works
  # in concert with the addin.

  # (The Editedit addin is distributed with a theme titled 'edit'
  # which includes a form that will work.

  # This theme can be edited like any other,
  # but any Editedit theme
  # MUST include an equivalent form.)

  # If the theme being used with the current request is not Editedit's
  # theme (specified as the value of the
  # variable $edit_theme_name_f in the configuration section of this
  # addin -above-), then we know that there is nothing
  # for the addin to do.

  # (Without the form there is no way to edit the post.)

  # So, this is the last condition.


  # If ...{filename} is not defined, OR the value of ...{filename}
  # is 'index', OR the theme specified with the request
  # is not editedit's theme, the conditional expression evaluates as true.

  if( !(defined($ode::req_components_at_sub{filename})) or $ode::req_components_at_sub{filename} eq 'index' or $ode::req_components_at_sub{theme} ne $edit_theme_name_f )
  {

    # When the conditional expression is true, we execute the conditional
    # block, and immediately return a false value.
    # This signals to Ode that the addin is not useful
    # for this request.

    return 0;
  }

  # If the conditional expression above does not evaluate as true
  # we skip the block and do not return from
  # the subroutine.

  # (We get to this point and keep going.)

  # We've determined that this IS a post type request which uses
  # Editedit's theme. Based on this,
  # we know that someone is attempting to use Editedit
  # to create or edit a post file.

  # Let's see what happens next...


  # $ode::show_tags_g is a variable that the script looks at
  # to determine whether Ode's 'tags' should be
  # displayed on the page returned to the client or stripped away from the
  # output.

  # The initial value of show_tags_g is copied
  # from the value of the $show_tags variable set in
  # Ode's configuration file
  # ($config::show_tags).

  # Note: The default value of $config::show_tags is false.

  # Typically users will probably not want to display tags along with
  # the rest of their posts.

  # Though included in the post file, tags are actually bits of instruction
  # delivered from the user to the script,
  # and vice versa, and not actual post content.

  # However, with Editedit, the situation is a little different.

  # By exposing the tags, they can be edited
  # in the browser form,
  # just like the rest of the post.

  # It makes sense that this is something that we might want to do.

  # Why do I say that?

  # Without Editedit, we use a text editor to access the post
  # files directly.

  # When accessing the post files this way we have access to the tags as well.

  # When displaying posts in a browser we rightly hide these instructions.
  # (They're not intended for the client.)

  # However with Editedit,
  # we're not displaying posts, we're editing them, just as we do in a
  # standalone text editor.

  # So it makes sense to expose the tags in this in this case
  # as well.

  # It's possible that $ode::show_tags_g may already be true.

  # In that case we reassign the same value again, which is a little
  # redundant but harmless.

  $ode::show_tags_g = 1;


  # As has already been discussed, when a user submits a request for a
  # specific post using Editedit's theme,
  # the page returned in response to the request
  # will include a form that can be used to edit the content
  # of the requested post.

  # We need to retrieve the content from the post file to pre-populate
  # that form (or it will be empty).

  # We can't edit the content of a post file
  # with a form if we don't have
  # access to the post file's content.

  # In order to read the post file we construct a string
  # representing the absolute path to the
  # targeted post file.

  # Once we have this path, we can read the file to get at the content.


  # First, we assemble a string representing the full filesystem path
  # to the requested post file.


  # We know that this is a request for a single post,
  # (and not the site root or a subcategory) because otherwise
  # we would have already returned from this
  # routine before now.

  # The absolute path to the post is the concatenation of:

  # - The path to the document root
  # - The filesystem path to the file (not including the filename)
  # - The post filename
  # - A dot (.) which is the assumed to be the filename suffix delimiter
  # - The post file extension (set in the config file).

  $ffp_to_post_s = "$config::document_root$ode::req_components_at_sub{fs_path_wo_file}$ode::req_components_at_sub{filename}.$config::post_file_ext";


  # Now that we have the absolute path to the requested post file,
  # we can take care of one more bit of
  # important business before we move on to actually
  # accessing the post file.

  # That important business has to do with permissions.

  # Editedit allows the site maintainer to set a password to use as a
  # simple authorization check to determine
  # whether a visitor (i.e. someone attempting to write
  # to a post file via the addin and it's form.) is allowed to make such a
  # change.

  # Several of Editedit's configuration options work together
  # to dictate the exact behavior of this
  # password authorization mechanism.

  # These include:

  # $require_password_bf
  # $edit_password_f
  # $sandbox_enabled_bf
  # @sandboxes_f

  # The first two are relatively straight-forward.

  # $require_password_bf is a Boolean value.

  # When true the addin enforces password authorization. A password
  # must be submitted as part of the form data
  # along with the content of the post being edited.

  # If a password is not submitted, or an incorrect password is used,
  # the edit will be rejected.

  # $edit_password_f is the stored password itself.

  # Whenever a password is required (i.e. $require_password_bf is true)
  # the password submitted with the form
  # must match the value or $require_password_bf exactly
  # (the pattern match is case-specific), or the
  # edit will be rejected.

  # That leaves:

  # $sandbox_enabled_bf
  # @sandboxes_f

  # As the names suggest, these settings allow a site maintainer to
  # implement 'sandbox' style of functionality
  # with Editedit.

  # What does that mean? (What's a sandbox?)

  # In general terms within the the domain computing a sandbox is an
  # untrusted container where people or programs
  # can play with (i.e. test) some aspect of a system in
  # such a way that anything done (within the container) cannot impact
  # the system as whole (outside of the container).

  # Typically changes made within a sandbox are only temporary
  # and may affect a single user or session.

  # Editedit's sandboxes are something like this,
  # but perhaps a bit of a misnomer.

  # With Editedit a sandbox is a directory where password restrictions
  # are not enforced.

  # In a sandbox an edit can be submitted without a password
  # even when passwords are required
  # (i.e. $require_password_bf is true.)

  # (Any password included with the form is ignored.)

  # What is the purpose?

  # Well, it allows site maintainers to designate
  # one or more categories where
  # visitors can create and edit posts.

  # In practice this is probably not a useful thing to do.

  # I use it to demo the Editedit addin so that would-be users can
  # try out the addin before downloading and
  # installing it to their site.

  # You may or may not have some use for it.

  # I want to make a point of saying that a sandbox is not a wiki!

  # Though the feature does allow anyone to edit the content of a page
  # with a form in a web browser as wikis do
  # it does not support any of the functionality that make
  # wikis genuinely useful:

  # - Revision history,
  # - The ability to associate edits with specific users,
  # - Quick internal linking through the use of a simple link pattern
  # (CamelCase for example)
  # - Many, many more

  # Long story short, do not make the mistake of thinking that Editedit's
  # sandbox feature can be used as a wiki.

  # If you wanted to do that it would make more sense to
  # create a separate ode installation and just disable the password
  # requirement. (Don't do that either!)

  # With all of that sandbox related discussion out of the way, I'll
  # briefly discuss the two sandbox related settings:

  # $sandbox_enabled_bf 

  # $sandbox_enabled_bf is a Boolean value.

  # When true the sandbox feature is enabled and Editedit will not enforce
  # the password requirement for selected categories.

  # By default $sandbox_enabled_bf
  # is false, and passwords are enforced
  # whenever $require_password_bf
  # is true.

  # @sandboxes_f

  # @sandboxes_f is an array containing a list of
  # sandboxed categories
  # specified in the configuration section of the Editedit addin.

  # Each of the sandboxes in the list should specify
  # the complete path
  # from Ode's document root,
  
  # $config::document_root,

  # to the targeted category.

  # For example

  # Let's that we want to sandbox the category corresponding to the address
  
  # http://sample.net/cgi-bin/ode.cgi/technology/technology_sandbox/

  # If $config::document_root is:
  
  # '/Library/WebServer/Documents/ode_site'

  # @sandboxes_f will be defined as:

  # @sandboxes_f (
  #   '/technology/technology_sandbox/',
  # );

  # Important:

  # Each entry MUST start and end with a path delimiter,
  # which under is always a forward slash
  # (regardless of platform on which Ode is running).

  # You can have as many sandboxes as you like.

  # All are completely
  # independent of one another.

  # By default the list is empty and,
  # as has already been mentioned, the sandbox mechanism is
  # disabled.


  # $in_sandbox_bs is a Boolean the value of which starts out as false
  # and is set to true if it is determined
  # that the sandbox feature is enabled and the current
  # request does in fact target one of the
  # sandboxed categories.


  # The purpose of the undef assignment is
  # to make it clear that we are setting the value of
  # the variable for the first time here.

  # The value of the variable should not be used
  # before this point in the execution of the script.

  $in_sandbox_bs = undef;

  # $in_sandbox_bs is initially false.

  $in_sandbox_bs = 0;


  # Here we determine we're dealing with a sandboxed request.

  # First, we need to know if BOTH the sandbox mechanism is enabled
  # AND a password is required for editing
  # posts via Editedit.

  # If the sandbox is disabled we cannot be in a sandbox
  # (there is no such thing
  # when the feature is disabled).

  # If there is no password required to
  # edit posts for the site, the concept of a sandbox
  # is irrelevant.

  if ($sandbox_enabled_bf == 1 and $require_password_bf == 1)
  {

    # Assuming the conditional expression above is true we only know that
    # we might be dealing with a sandboxed request.

    # To determine whether we are or not, we loop through each
    # of the elements of the list at
    # @sandboxes_f (set in the configuration section).

    # One at a time each list element is assigned to the local variable
    # $sandbox_l.

    # Keep in mind that the list may be empty,
    # in which case the loop is
    # skipped (which works out just fine).

    # $in_sandbox_bs initially set to false. Because there are
    # no sandboxed categories,
    # the request cannot target a sandboxed directory.

    # Because the loop is skipped $sandbox_l is not set to true
    # (something which only happens here)
    # which is the current value.

    foreach my $sandbox_l (@sandboxes_f)
    {

      # Before we compare the sandbox to the path to the requested post
      # to determine if we're dealing with
      # a sandboxed request, we first check to make sure
      # the sandbox itself meets an important
      # requirement, namely that it starts and ends with a path delimiter.

      # This is important because each sandbox MUST
      # specify the a path
      # starting after Ode's document root.

      # The value $config::document_root does not end in a trailing
      # delimeter, so the string reprsenting the sandbox
      # must include a leading delimiter
      # to separate the end of the document root from the start of the
      # sandbox.

      # The sandbox must end in a trailing slash to enforce
      # the rule that the sandbox must
      # specify a directory. Under Ode directory specifications
      # ALWAYS end in a trailing path delimiter
      # (and file specifications never do).

      # If either of these conditions are not true, we move to the next
      # sandbox in the list, after generating a warning
      # to inform the site maintainer that
      # there is a invalid value in the list at @sandboxes_f.

      if ($sandbox_l !~ m!^/! or $sandbox_l !~ m!/$!)
      {
        &ode::handle_warning_and_response (
          "Editedit : inventory_ping_response",

          "Invalid element in sandbox list at \@sandboxes_f:\n" .
          "'$sandbox_l'\n" .
          "String must begin and end with a path delimiter.\n" .
          "Ignoring this element.\n",

          "Editedit : Ignoring invalid sandbox. " .
          "(See error log for details.)\n",

          $ode::min_error_level +1, $ode::max_error_level -1
        );


        next;

      } # End, if ($sandbox_l !~ m!^/! or $sandbox_l !~ m!/$!)


      # We compare the current sandbox to the complete path to the requested
      # post.

      # If the post is in a sandboxed directory,
      # then the string identifying the category must be part of the path
      # to the post.


      # An example will probably help make this clear.

      # Let's say that the requested address is:

      # http://sample.net/cgi-bin/ode.cgi \ 
      # /technology/technology_sandbox/some_post

      # I'll tell you that the document root for the Ode site
      # we using in this example is:

      # '/Library/WebServer/Documents/ode_site'

      # and the complete path to this post:

      # '/Library/WebServer/Documents/ode_site/ \ 
      # technology/technology_sandbox/some_post.txt'

      # For this example our sandboxes array includes just one entry

      # @sandboxes_f (
      #   '/technology/technology_sandbox/',
      # );

      # '/technology/technology_sandbox/'

      # The pattern match insists that we match:
      
      # ^ - The start of the string
      # ${config::document_root} - Followed by Ode's document root
      # $sandbox_l - Followed immediately by the sandbox.

      # Let's see if we have a match:

      # Path to post:

      # '/Library/WebServer/Documents/ode_site \ 
      # /technology/technology_sandbox/some_post.txt'

      # document_root:
      
      # '/Library/WebServer/Documents/ode_site'

      # $sandbox_l:

      # '/technology/technology_sandbox/'

      # Yep, that's a match. Given this example,
      # we ARE in a sandbox. 


      # !It's important to note that subcategories of sandboxed directories
      # are also in the sandbox!

      if ($ffp_to_post_s =~ m!^${config::document_root}$sandbox_l!)
      {
        $in_sandbox_bs = 1;
        last;
      }

    } # End, foreach my $sandbox_l (@sandboxes_f)


    # $in_sandbox_bs is a Boolean that tells us whether or not we're opeating
    # in one of the sanboxed categories.

    # Initially the value was false so by default we're not
    # in a sandbox.

    # If it is determined that the current request does target a sandbox
    # then we set the value to true (before now).

    # When we check the value in the conditional here,
    # $in_sandbox_bs will be true if we are in a sandboxed category
    # and false otherwise.

    if ($in_sandbox_bs)
    {

      # If we are working in a sandbox then Ode should not require
      # a password, so we set
      # $require_password_bf to false.

      # (The value may be false already.)

      $require_password_bf = 0;


      # In addition to setting $require_password_bf to false, we
      # output a warning and a response to
      # to make note of the event and inform the user
      # that they are in a sandboxed category.

      &ode::handle_warning_and_response (
        "Editedit : inventory_ping_response",

        "The request targets a post in the sandbox:\n" .
        "$ffp_to_post_s\n" .
        "Ignoring password requirement.\n",

        "Editedit : You're in the sandbox - No password required.\n",

        $ode::min_error_level +1, $ode::min_error_level +1
      );

    } # End, if ($in_sandbox_bs)

  } # end, if (enable_sandbox == 1 and $require_password_bf == 1)


  # The variable $post_file_exists_bs is a Boolean that tells us
  # whether the post file targeted by the request
  # already exists.

  # A post which does not already exist must be created by the addin,
  # while a post that already exists must be
  # updated.

  # Note that creating a post may involve creating
  # all or a portion of the directory structure leading the the
  # targeted post.


  # The purpose of the undef assignment is
  # to make it clear that we are setting the value of
  # the variable for the first time here.

  # The value of the variable should not be used
  # before this point in the execution of the script.

  $post_file_exists_bs = undef;

  # The initial value of the variable is false.
  # We assume for the moment that the
  # requested post file
  # does not already exist
  # (i.e. that this is a request to create a new post
  # with the editedit addin).
  
  $post_file_exists_bs = 0;


  # Next we perform a series of checks on the target post file,
  # represented by the string value at
  # $ffp_to_post_s.

  # The idea that this correspond to a file system path leading to either

  # 1. A readable post file

  # 2. Nothing, in which case we will attempt to create a new post
  # at the specified path.

  # But these are not the only two options.


  # The following are also possible:

  # 3. The file exists but is not readable.

  # 4. The directory entry exists but
  # is not a file.

  # For case 2 - 4

  # i.e. when an existing post file cannot be read,
  # the values of:

  # $form_title_g
  # $form_body_g

  # are both undefined.

  # The corresponding form fields presented in Editedit's theme
  # will be empty.


  # This is what we want if there is no directory entry at the
  # specified path (case 2 in the list above).


  # However it's something of a problem if a directory exists
  # but is not a file (case 4)
  # OR is a file but is not readable (case 3).

  # In these cases we should inform the user of the issue
  # so that he or she doesn't writing a post
  # only to find that the post file can't be written
  # successfully.

  # This will give the user the opportunity to
  # correct the problem or
  # save their post to a different location.


  # All of checks are accomplished using one or a combination
  # of Perl's file tests which include (among others):

  # -e : The target exists
  # -f : The target is a plain file
  # -r : The target is readable

  # Note that only the first test uses refers to the variable
  # $ffp_to_post_s.

  # All of the others use the special filehandle '_'
  # (a single, bare underscore).

  # When the first test is done with $ffp_to_post_s
  # Perl must make a system call requesting
  # the stat structure that contains the information about the
  # file necessary to determine the
  # result of the test.
  
  # This is a relatively slow operation.

  # When '_' is used after the first file test, Perl reuses
  # the same structure returned for the first,
  # avoiding the overhead of another system call.

  # It's important to note that '_' always refers to the most recent
  # stat structure returned, and that this might
  # not necessarily be the intended one. It's possible that
  # some other operation that results in
  # stat related system call can occur between the
  # intended stat request and the use of '_'. In that case
  # the subsequent tests would refer to something
  # other than the intended file. This of course would lead to
  # inaccurate results.

  # For this reason, always be cautious about where and under what
  # circumstances you use '_'


  # + ----------
  # | From the documentation:
  # + ----------
  # | If stat is passed the special filehandle consisting of an
  # | underline, no stat is done,
  # | but the current contents of the stat structure
  # | from the last stat, lstat, or filetest are returned.
  # + ----------

  # Refer to the Perl documentation for more information about
  # '-X' file tests
  # http://perldoc.perl.org/functions/-X.html


  # First we check that some directory exists at the specified path.

  # (Keep in mind that this may be a post file
  # or something else.)

  # If $ffp_to_post_s does not exist, then we know that there is
  # no post file and also nothing else
  # at the same path that would interfere with our
  # ability to create a new post file.

  # (There may still be a permissions issue.)

  if (-e $ffp_to_post_s)
  {

    # Having determined that there is something at $ffp_to_post_s
    # we test whether or not that something
    # is a plain file (as opposed to a directory, symbolic link
    # or some other filesystem directory entry.)

    # ( Our post files should be ordinary discrete plain text files.)

    # -f will return false is there is some directory entry at the
    # specified path, but that entry is not
    # a plain file.

    # Note: Because our posts must all end with Ode's
    # configurable post file extension ('txt') by default, it's probably
    # unlikely, though entirely possible,
    # that we will run into a name conflict where something that
    # is not a post file appears to be a post file.

    if (-f _)
    {

      # Having determined that there is an existing post file
      # at the specified path, we make note
      # of this fact in the Boolean variable $post_file_exists_bs.

      # (We'll use this variable later in the routine.)

      $post_file_exists_bs = 1;


      # Though there is a file at the specified path, it's possible
      # that the file may not be readable,
      # (which of course means that we will not be able
      # to edit the content of the file).

      # We check for this issue and issue appropriate an appropriate
      # warning and response if necessary.

      if (! -r _)
      {

        &ode::handle_warning_and_response (
          "Editedit : inventory_ping_response",

          "The requested post file exists but is not readable:\n" .
          "$ffp_to_post_s\n" .
          "It is not possible to retrieve the contents\n" .
          "of the file to include in Editedit's form.\n" .
          "Check permissions and make nec changes before trying again.\n" .
          "(You may still be able to write to the file.)\n",

          "Editedit : Post file cannot be read. " .
            "(Check permissions and try again.)\n",

          $ode::min_error_level +1, $ode::min_error_level +1
        );

      } # End, if (!-r _)


      if (! -w _)
      {

        &ode::handle_warning_and_response (
          "Editedit : inventory_ping_response",

          "The requested post file exists but is not writable:\n" .
          "$ffp_to_post_s\n" .
          "You will not be able to edit this post.\n" .
          "Check permissions and make nec changes before trying again.\n" .
          "(You may still be able to read the file.)\n",

          "Editedit : Post file cannot be written. " .
            "(Check permissions and try again.)\n",

          $ode::min_error_level +1, $ode::min_error_level +1
        );

      } # End, if (!-r _)

    } # End, if (-f _)

    else
    {

      # At this point we know that something exists at the specified
      # path (-e is true), but that something
      # is not a plain file (-f is false).

      # Whatever 'it' is, cannot be a post file.

      # We don't want to risk overwriting some other filesystem
      # entry (a directory of important documents
      # for example), and so Editedit will not attempt to
      # overwrite the whatever it is.

      # The site maintainer will need to resolve this issue before
      # creating a post file with Editedit.

      # We issue appropriate an appropriate warning and response
      # to notify the user of the problem.

      &ode::handle_warning_and_response (
        "Editedit : inventory_ping_response",

        "There is something else (not a post file) at the specified path:\n" .
        "$ffp_to_post_s\n" .
        "This issue must be resolved manually\n" .
        " before you will be able to create a new post here.\n",


        "Editedit : There is something else (not a post) " .
          "at the req path.\n",

        $ode::min_error_level +1, $ode::min_error_level +1
      );

    }

  } # End, if (-e $ffp_to_post_s)


  # The parameter Editedit will typically be included
  # with the request only if the current request resulted from someone
  # clicking the submit button associated
  # with the form that is part of editedit's theme.


  # Let's take a moment to think about how we might end up using
  # Editedit.

  # 1. First we can explicitly create a post type request
  # using Editedit's theme.

  # This would bring us to the edit theme, and Editedit's form for the
  # first time.

  # We want to prepopulate the form fields so that have
  # access to the posts content.

  # Where is this content going to come from?

  # In this case, we need to read the post file itself to fill in the
  # form.


  # There is another option.

  # 2. We reload the edit theme whenever we click the
  # 'Save edit' button, having previously
  # visited at the same a page,
  # after making whatever changes we want
  # to the post.

  # When we click that button, we need to write the changes out
  # to the post file.

  # We also need to reload the page, and Editedit's theme.
  # Again, we need to fill in the form with the content of the post
  # being edited.

  # Where is this content going to come from?

  # Before, we read the post file
  # to retrieve the post content. We don't beed to read the post file
  # in this case (in fact it
  # would be a mistake to do so).

  # We don't need to read the post file because
  # we already have the post content, including the most recent edits,
  # in the form we are submitting back to Ode,
  # and we simply reuse the content
  # from the form without rereading the post file.

  # Why is this preferable? 

  # For one thing it's more efficient. But more importantly,
  # reading the post file would be problematic.
  # Imagine that some problem prevented us from writing the changes
  # from the form to the post file.

  # (Maybe the user did not submit the correct password.)

  # If we reload the post content from the file,
  # we will lose whatever changes we made before clicking the 'Save edit'
  # button.

  # The addin would reload the post from the file,
  # and the post file does not include the most recent changes
  # (because those changes could
  # not be saved to the file).

  # If we instead reuse the content from the form,
  # then the form will always reflect the most recent changes,
  # even when some issue prevented
  # us from writing those changes back to the file.
  # Rather than rewriting the most changes
  # from memory, a user can just resubmit the request after correcting
  # the problem.

  # We check for the presence of the Editedit parameter - which is
  # included in Editedit's theme,
  # so it will be included with the request
  # whenever the page is reloaded
  # as a result of clicking the 'Save edit' button.

  # If the parameter IS included with the request,
  # we will reuse the content from the form
  # to repopulate the form itself, rather than rereading
  # the post file.

  # When the parameter is not included, the assumption is that
  # we have come to the Editedit's theme
  # in some other way (something other than clicking the 'Save edit' button), 
  # so we read the post file to populate the form
  # (because there is no form content).

  # Also, if the parameter is not included with the request
  # then we know there are no changes
  # to write back to the post file and so we can skip
  # all of the work associated with
  # writing out the post.

  # Question: What will happen if the editedit parameter is somehow
  # added to the request in some way
  # other than clicking the 'Save edit' button?

  # Answer: Nothing at all.

  # The slightly longer answer is that there are really
  # two cases to consider.

  # 1. Requests that do not specify Editedit's theme and/or are not
  # post type requests.

  # Some examples:

  # http://sample.net/cgi-bin/ode.cgi?Editedit=y
  # http://sample.net/cgi-bin/ode.cgi/index.html?Editedit=y
  # http://sample.net/cgi-bin/ode.cgi/index.edit?Editedit=y
  # http://sample.net/cgi-bin/some_category/index.html?Editedit=y
  # http://sample.net/cgi-bin/some_post.html?Editedit=y

  # In all of these cases, Editedit will not be active.
  # In these cases, Editedit's inventory_ping_response routine returns
  # a value of false (before now) and the addin
  # effectively does nothing at all.

  # 2. Requests that do specify Editedit's theme
  # AND are post type requests.

  # Example

  # http://sample.net/cgi-bin/ode.cgi/some_post.edit?Editedit=y

  # In this case Editedit is active but because the
  # form was not used,
  # the request cannot include a password.
  # If a password is required to commit the change, then the
  # the lack of a password would
  # prevent from being made.

  # Even is a password is not required (e.g. in a sandbox) the result
  # is that the page will load in Editedit's theme
  # it's form field populated with the content from the
  # post file, and with the post file
  # intact and unchanged.


  # If the parameter 'Editedit' IS NOT included with the request...

  if ( !param('Editedit') )
  {

    # Attempt to read from the post file

    if (open READ_FH, "<  $ffp_to_post_s")
    {

      # We're going to read the post file, separating the content
      # into three (3) different values:
      # title, tags, and body.

      # The title of a post is always considered to be
      # the first line of the post file.
        
      # (We check that the value is defined to account for
      # the possibility that
      # the post file may be empty.)


      # Notice the use of the chomp operator which
      # removes the newline.

      # This means that we will need to add a newline character back
      # before writing the line to
      # the new file.

      # Why remove it just to add it back?

      # The short answer is consistency.
      
      # By always removing the newline
      # I know that I'll need to add it back in every case,
      # rather than try to keep track if
      # I do or don't need to append a newline for
      # one situation or another.

      # I typically always chomp input, and always write a newline
      # character with output.

      # It may not always be the easiest thing to do,
      # but sticking to
      # a single approach is simple,
      # and it works for me.


      # I tend to always remove line endings whenever I read
      # content from a file.

      # This consistency means that I can always
      # add a newline whenever I write a line out to a file
      # without worrying about line endings
      # stacking up unexpectedly.


      # The purpose of the undef assignment is
      # to make it clear that we are setting the value of
      # the variable for the first time here.

      # The value of the variable should not be used
      # before this point in the execution of the script.

      $file_title_s = undef;

      if ( defined ($file_title_s = <READ_FH>) )
      {
        chomp $file_title_s;
      }


      # Now that we've dealt with the title, let's read the next line.
      # Again, we remove the line ending
      # as we did with the title (for the same reason).

      # (See the comments before the statement
      # with which we read the title of the post just above
      # for more info.)

      # This next line will be one of three things:

      # 1. A blank line separating the title from the tag block or body.

      # 2. A tag, if there is at least a single tag included
      # in the file, and there are no blank lines separating the title
      # from the tag block.

      # 3. The first line of the body of the post, if there are no tags
      # included in the file, and there are no blank lines
      # separating the title from the body.


      # I don't want to chomp the newline following the first line
      # of the body.

      # Why?

      # Because the first line of the body may also be the last line of
      # the body (i.e. the body of the post may consist of
      # only one line). I don't want to artifically insert a newline
      # at the end of the body of the post if there wasn't one there to
      # begin with.

      # Though we will continue to chomp and add lines through to
      # the start of the body of the post, we will
      # read and write the body as-is to make sure that we
      # don't artificially add a newline at the end.
 
      # The value at $line_s is chomped only if it is defined AND it
      # does not look like a tag or a blank line.

      if ( defined ($line_s = <READ_FH>) and $line_s =~ /^(?:\s*|\s*tag\s*:.*)$/)
      {
        chomp $line_s;
      }


      # There will not necessarily be any whitespace separating the
      # title from the tags or body of the post.

      # The loop will read through each line of the file while the
      # lines contain nothing but whitespace.

      # By doing so, and not writing the newlines
      # out to the new file we're creating,
      # we're consuming all of the blank lines
      # (whatever the number).

      # This allows us to collapse any extra
      # whitespace between the title and the tag block
      # or body of the post which may have
      # accumulated due to sloppy manual editing,
      # or maybe other addins which haven't been careful
      # about their handling of tags.

      # (Addins should use the add_tag routine to avoid such issues.)


      # If there are no blank lines, we'll just skip the while loop
      # altogether, which is OK.

      while(defined $line_s and $line_s =~ /^\s*$/)
      {
        $line_s = <READ_FH>;
      }

      # We didn't chomp the lines in the loop because we were just
      # consuming blank lines.

      # There is no point in removing the
      # newline character from the end of a blank line only to discard the
      # whole thing.

      # Now that we are past the loop,
      # we know $line_l is not blank, and we haven't
      # removed the newline.

      # So we take care of that here.


      # Note, if there were no blank lines, separating the title
      # from the rest of the post,
      # the loop will be skipped, and the value of line_l
      # will be the first line in the body of the post.

      # In that case we will have already chomped the string.

      # There is no harm in using chomp to attempt to
      # remove a newline character which isn't there.
      # When passed a string without a trailing newline character
      # chomp silently does nothing.


      # After finishing the blank line loop above,
      # I could be at the tag block here
      # or the first line of the body.

      # I don't want to chomp the newline following the first line
      # of the body.

      # Why?

      # Because the first line of the body may also be
      # the last line of the body (i.e. the body of the post may consist of
      # only one line). I don't want to artifically insert
      # a newline at the end of the body of the post
      # if there wasn't one there to begin with.

      # Though we will continue to chomp and add lines through to
      # the start of the body of the post, we will
      # read and write the body as-is to make sure that we
      # don't artificially add a newline at the end.
 
      # The value at $line_s is chomped only if it is defined AND if it
      # does not look like a tag line.

      if ( defined $line_s and $line_s =~ /^\s*tag\s*:/)
      {
        chomp $line_s;
      }


      # Assuming the post file contains more than just the title
      # (or nothing at all)
      # $line_l still has some value
      # at this point.

      # It's the last line read in the while loop used to consume
      # the blank lines following the title
      # OR the non empty line immediately following the
      # title of the post if are no blank lines
      # separating the title from the rest of the post
      # (either the body or tag block).

      # All we know about that value at this point is that
      # it's not a blank line.

      # (Otherwise we wouldn't have exited the last loop.)


      # The next line is either a tag,
      # the body of the post, or nothing (if the file contained
      # only a title or a title
      # line followed by whitespace).


      # We know that a tag line starts with
      # the literal sequence 'tag'
      # followed by some number (including zero) of
      # whitespace characters,
      # and then a colon.

      # We'll loop through all of the tag lines,
      # whatever the number, one at a time,
      # breaking out of the loop only after we have processed
      # all of the tags.

      # (If there are no tags, the loop skipped.)


      # The purpose of the undef assignment is
      # to make it clear that we are setting the value of
      # the variable for the first time here.

      # The value of the variable should not be used
      # before this point in the execution of the script.

      $file_tags_s = undef;

      while($line_s =~ /^\s*tag\s*:/)
      {

        # While the next line is a tag, we save the line
        # as part of the string that represents
        # our tag block.

        # Because we chomp lines when they are read,
        # and we want the tag block represented as a group of lines,
        # we add a newline character as a separator
        # after each tag line as it is appended to the string
        # representing the tag block.

        $file_tags_s .= "$line_s\n";


        # We read the next line from the original file
        # and repeat the loop.

        # Again, notice the use of the chomp operator, which is
        # used to strip the line ending from the
        # end of each line as it's read.

        # Because we add the newline back only as we append the line
        # to the tag block at $file_tags_s (above), we know
        # that there will not be a newline character at the end of
        # $line_s after we exit from the loop,
        # which is what we want.
        
        # That means that we will want to
        # add a newline to $file_tags_s
        # whenever we combine this with some other
        # string.

        chomp($line_s = <READ_FH>);

      } # End, while($line_s =~ /^\s*tag\s*:/)


      # Coming out of that loop, as written there will be a trailing newline
      # character at the end of the tags line, $file_tags_s.

      # (Note that I'm _not_ talking about $line_s here.)

      # we'll chomp to string to get rid of the trailing
      # newline chracter.

      if (defined $file_tags_s and $file_tags_s ne '')
      {
        chomp $file_tags_s;
      }


      # Just like there may have been blank lines between the title and
      # tags block
      
      # (or between the title and body if there are no tags),

      # there may be one or more blank lines separating
      # the tag block from the body.

      # As we did before, we'll loop through
      # any number of blank lines, consuming all of them
      # (and writing nothing to the new file),
      # in order to collapse any blank lines which may have accumulated
      # due to sloppiness.

      while(defined $line_s and $line_s =~ /^\s*$/)
      {
        $line_s = <READ_FH>;
      }

      # To summarize

      # We started at the title (the first line of the post).

      # From there we worked through one of the following:

      # title - blank line(s) - tag(s) - blank line(s) - body
      # title - blank line(s) - body
      # title - tag(s) - blank line(s) - body
      # title - tag(s) - body
      # title - blank line(s) - body
      # title - body

      # Regardless, we've ended up at the first line of the body,
      # unless there is no body, in which case we've arrived
      # at the end of the post.

      # We have not yet gotten rid of the new line at the end of the first
      # line of the body.

      # (Believe me, it's true.)

      # As has already been discussed, we're not going to chomp
      # the first line of the body. Why?

      # Because the first line of the body may also be the last line
      # (i.e. the body may consist of only one line),
      # and we don't want to artifically insert a newline
      # at the end of the body of the post if there wasn't one
      # there to begin with.

      # We want to represent the content of the post
      # as accurately as possible.

      # This means that we must be careful
      # in this case not to artificially add a newline
      # to the body.

      # We still have the last line of input read from the post file
      # in $line_s. This is the first line of the
      # body (assuming there is at least one body line).

      # This becomes the first line in
      # $file_body_s. We have not chomped the line so we
      # do not add newline character here.

      $file_body_s = $line_s;


      # Everything tha follows is the body of the post.

      # Because we want to read the rest of the file as is, we can dispense
      # with the loop and use the join operator
      # to read the rest the remainder of the file to the
      # to the string at $file_body_s.

      # join EXPR,LIST

      # join combines a LIST of strings into a single string separating
      # each by the value of EXPR.

      # Because we are treating <READ_FH> as a list of strings
      # (i.e. using the file handle in list context), we'll read all of the
      # remaining files at once.

      # Because EXPR is the empty string '', we're not introducing a
      # separator.

      # Refer to the Perl documentation for more information about:
      # join
      # http://perldoc.perl.org/functions/join.html

      $file_body_s .= join '', <READ_FH>;


      # At this point we're done
      # reading the post file,
      # so we close the associated filehandle.

      close READ_FH;


      # Set package global $form_title_g and $form_body_g*
      # variables to the value of
      # $file_title_s and $file_body_s
      # respectively.

      # These are the variables used in the default .edit theme
      # to populate the form fields.

      $form_title_g = $file_title_s;


      # * The form body is actually combines the values of $file_tags_s
      # and $file_body_s. Though we maintain these
      # as separate values throughout
      # the Editedit addin - so that we can treat them differently,
      # $form_body_g* corresponds to a single form field,
      # so we need to combine them.

      # Note: We'll also need to pull these two sections of the post
      # apart again when the form is
      # submitted - (elsewhere in the addin)


      # There is one other significant complication
      # related to the inclusion of the tags
      # in the body field of the form on the page generated by editedit's
      # theme.

      # Whenever there is more than 1 tag, the lines form a
      # continuous block, with one tag per line.

      # For example

      # tag : addin_name1 : tag_name1 : tag_value1
      # tag : addin_name1 : tag_name2 : tag_value2
      # tag : addin_name2 : tag_name1 : tag_value1
      # tag : addin_name2 : tag_name2 : tag_value2

      # These tags should display in the form exactly as the appear
      # in the file, with one tag per line.

      # The problem is that when the tags are displayed
      # in the markdown preview,
      # they will appear with run together on the same line.
      # The result will be something like:

      # tag : addin_name1 : tag_name1 : tag_value1 tag : addin_name1 :
      # tag_name2 : tag_value2 tag : addin_name2 : tag_name1 : tag_value1
      # tag : addin_name2 : tag_name2 : tag_value2

      # This doesn't cause any functional problem but it's ugly.

      # In order for the tags to appear on separate lines we need to
      # add a break at the end of each line.
      # With markdown we indicate a <br /> by ending a line
      # with two trailing spaces.

      # So to get what we want we need to change each of the tag lines
      # from this:
      
      # tag : addin_name1 : tag_name1 : tag_value1

      # to:

      #                                           space
      #                                             |
      # # tag : addin_name1 : tag_name1 : tag_value1  
      #                                              |
      #                                            space


      # (Note that we'll also want to remove these spaces when the form is
      # submitted because we don't want them written to
      # the actual post file. That's a problem that we'll need
      # to deal with elsewhere.)

      # So how to do it?

      # Within the tag string we search for all occurences of \n
      # not preceeded by two spaces
      # and replace that with a newline that is preceeded by
      # two blank spaces.


      # An important point

      # Because the string at $file_tags_s
      # will not end with a trailing newline, we will not add
      # the two spaces at the end of the last tag,
      # which is just what we want.

      # It wouldn't cause a visible problem if those
      # characters were there, but it would be less 'clean'.
      # The spaces are introduced so that tag lines in the preview each
      # appear on separate lines.

      # That means that we only need spaces between lines.

      # As written, this is exactly what we get.

      if (defined $file_tags_s and $file_tags_s ne '')
      {

        # Here we add the required two spaces to the end of
        # every tag line except the last.

        $file_tags_s =~ s/(?<!  )\n/  \n/g;

        # Now that we've add the spaces we need
        # at the end of the tag lines we combine the strings representing
        # the tags and body of the post file as a
        # single string at $form_body_g.

        # (Because the form includes a single field
        # that is intended to represent both
        # tags and body.)


        # Keep in mind:
        
        # whereas $file_tags_s represents only the tags in the post file,
        # and $file_body_s is only the body,
        # $form_body_g is the concatenation of the two!

        $form_body_g = "$file_tags_s\n\n$file_body_s";

      } # End, if (defined $file_tags_s and $file_tags_s ne '')

      else
      {

        # If the current post file does not include any tags,
        # we simply copy the value of $file_body_s
        # to $form_body_g.

        $form_body_g = $file_body_s;

      }

    } # End, if (open READ_FH, "<  $ffp_to_post_s")


    # If the post file could not be read for some reason
    # the entire if block above is skipped.


    # (Some reasons why we may not be able to read the post file
    # include the following:


    # 1. There is no directory entry at $ffp_to_post_s

    # 2. The directory entry exists but
    # is not a file.

    # 3. The file exists but is not readable.)

    # Regardless of the reason why, when the post file
    # cannot be read the values of

    # $form_title_g
    # $form_body_g

    # are both undefined.

    # The corresponding form fields presented in Editedit's theme
    # will be empty.


    # Having set the values for:
    
    # $form_title_g and $form_body_g,
    
    # which are the variables supplied to populate the form
    # (though they may be empty),
    # we've done all we need to do
    # and can return from the inventory_ping_response
    # routine.

    return 1;

  } # End, if ( !param('Editedit') )



  # To make it here, the visitor must have clicked the submit button
  # ('Save edit') on the Editedit theme's form.

  # In this case we want to set the values used
  # to fill in the form with the values passed through from
  # the form just submitted.

  # Though we don't _read_ the post file
  # in this case, we do need to _write_ the content of the form
  # out to the post file (assuming
  # the visitor is authorized to do so).


  # So we need to write the submitted changes (the edit)
  # to the post file.

  # (The post file may or may not exist at this point!)


  # The purpose of the empty assignment
  # is to make it clear that we are uninterested in any
  # previous value of these variables.
  
  # $form_title_g and $form_body_g start out empty.

  $form_title_g = '';
  $form_body_g = '';


  # We know that this request was initiated by clicking
  # the submit button on the form included
  # as part of Editedit's theme.

  # This means that the request most likely includes changes to
  # the title, or body of the post (or both).

  # Next, let's set the values of the variables of

  # $form_title_g,
  # $form_body_g

  # to the content of the Editedit theme's form fields.

  # There are clear advantages to using the form field values,
  # rather than retrieving the content
  # from post file.

  # (i.e. writing the post file first and then
  # reading the changes
  # from the updated file.)

  # Firstly, it is more efficient to use the values we already have
  # rather than reading the same content from the post file.

  # Secondly, if some problem prevents Editedit from
  # successfully updating the post file with the most recent changes
  # we can preserve the content of the form field
  # in this way.
  
  # The visitor can then try to submit
  # again, or copy and paste their changes someplace safe
  # until the issue is resolved.


  # The value of the variable $form_title_g, which is used to
  # populate the title form field,
  # is carried over from the last submission.

  # This value is available to us as: param('title')


  # $form_body_g, and $last_password_f are handled the same way
  # with the values for these available at:
  
  # param('body')
  # param('pwd')


  # Note the the last password is preserved.

  # This allows a visitor to make multiple edits and resubmit
  # the form without retyping the password,
  # and without resorting to the use of cookies here.

  $form_title_g = param('title');
  $form_body_g = param('body');





  # We capture the password submitted with the form
  # at $last_password_f, and then copy
  # the same value to the global $form_password_g.

  # Including this variable as part of the form in Editedit's page
  # theme file allows us to feed the password
  # back to the page in order to prepopulate the password
  # field again.
  
  # By doing this, the user isn't required to retype the password
  # until they navigate away from the page.


  # The purpose of the empty assignment
  # is to make it clear that we are uninterested in any
  # previous value of these variables.
  
  # $form_title_g and $form_body_g start out empty.

  $last_password_f = $form_password_g = '';


  $last_password_f = param('pwd');

  $form_password_g = $last_password_f;




  # Next we run two authorization checks before attempting to write the
  # submitted changes out to the post file.

  # These correspond to the two user-configurable
  # Boolean variables:

  # 1. $restrict_by_addr_bf
  # 2. $require_password_bf


  # If $restrict_by_addr_bf is set to true,
  # the addin checks the value of the client address (available to us as
  # part of the %ENV hash) against
  # the user-configurable list of allowed addresses in
  # @allowed_addresses_f.

  # If $ENV{'REMOTE_ADDR'} matches any of @allowed_addresses_f,
  # the addin proceeds, otherwise
  # the addin routine returns
  # without creating the new post file.

  # @allowed_addresses_f is a _whitelist_ which specifies addresses that are
  # allowed to post (NOT a blacklist).


  # If $require_password_bf is true, the addin
  # checks the provided password against the value of
  # the user-configurable variable:

  # $edit_password_f.

  # The addin routine returns, without creating the new post file,
  # when:

  # 1. No password is provided;
  # 2. The provided password is not correct.

  # Otherwise the routine continues.


  # 1. $restrict_by_addr_bf (Restrict editing by IP address)


  # The purpose of the undef assignment is
  # to make it clear that we are setting the value of
  # the variable for the first time here.

  # The value of the variable should not be used
  # before this point in the execution of the script.

  $matched_allowed_address_bs = undef;

  if ($restrict_by_addr_bf)
  {
    # The value of $matched_allowed_address_bs is a Boolean
    # which starts out false and is set to
    # true only if we successfully match the client IP address
    # to one of the values in the list at
    # @allowed_addresses_f.

    $matched_allowed_address_bs = 0;


    # Using a foreach loop we work through all of the addresses
    # in the list at @allowed_addresses_f,
    # attempting to match each address against remote
    # host address in $ENV{'REMOTE_ADDR'}.

    foreach  my $address (@allowed_addresses_f)
    {
      if ($ENV{'REMOTE_ADDR'} =~ m/$address/)
      {

        # As soon as the IP address of the host
        # matches one of the allowed addresses, the the value of the Boolean
        # $matched_allowed_address_bs
        # is true, and we exit the loop.

        $matched_allowed_address_bs = 1;

        last;

      } # End, if ($ENV{'REMOTE_ADDR'} =~ m/$address/)

    } # End, foreach  my $address (@allowed_addresses_f)


    # If, $matched_allowed_address_bs is not true,
    # after attempting to match all addresses in the list
    # at @allowed_addresses_f, (the remote host address does not
    # match any of the addresses on the whitelist),
    # the addin does not commit the edit.

    # Instead we report the issue and return immediately.

    # Keep in mind that we have already set the value of the variables
    # used to populate the Editedit theme's form fields
    # so the form will retain the edited content,
    # though the changes are not written out to the post file.

    if(!$matched_allowed_address_bs)
    {

      # Report the problem using Ode's handle_warning_and_repsonse routine.

      &ode::handle_warning_and_response (
        "Editedit : inventory_ping_response",

        "Attempt to edit the post:\n" .
        "$ffp_to_post_s\n" .
        "From unauthorized IP address: $ENV{'REMOTE_ADDR'}\n",

        "Editedit : Cannot post from this address: " .
          "$ENV{'REMOTE_ADDR'}.\n",

        $ode::min_error_level +1, $ode::min_error_level +1
      );


      # There is nothing else to do.

      # The submitted changes have not been written to the
      # post file.

      return 1;

    } # End, if(!$matched_allowed_address_bs)

  } # End, if ($restrict_by_addr_bf)


  # 2. $require_password_bf (Restrict editing by password)

  # If a password is required
  # ($require_password_bf = 1), but the password has not been set
  # ($edit_password_f = ''),
  # the edit cannot be committed.

  # It's not possible to authorize against a password if the password itself
  # that hasn't been specified.

  # (Note: To allow for editing without a password, set the
  # configuration option $require_password_bf to
  # false - $require_password_bf = 0).

  if($require_password_bf and !$edit_password_f)
  {

    # Report the problem using ode's handle_warning_and_repsonse
    # routine.

    &ode::handle_warning_and_response (
        "Editedit : inventory_ping_response",

        "Password required to edit post but the password\n" .
        "has not been set.\n" .
        "Check Editedit addin config.\n",

        "Editedit : A password is required to edit posts, but " .
            "has not been set.\n",

        $ode::min_error_level +1, $ode::min_error_level +1
    );


    # The submitted changes _have not_ been written to the post file.
    # There is nothing else to do.

    return 1;

  } # End, if($require_password_bf and !$edit_password_f)


  # At this point we know that a password is required and a password
  # has been specified in Editedit's configuration.


  # The edit is not committed if:

  # 1. No password has not been provided;

  # 2. The provided password is not correct.

  if( $require_password_bf and
    (!(param('pwd')) or (param('pwd') ne $edit_password_f)) )
  {

    # Report the problem using ode's handle_warning_and_repsonse
    # routine.

    &ode::handle_warning_and_response (
      "Editedit : inventory_ping_response",

      "Incorrect password supplied.\n" .
      "Attempting to edit post:\n" .
      "$ffp_to_post_s\n" .
      "From IP address: $ENV{'REMOTE_ADDR'}",

      "Editedit : Incorrect password.\n",

      $ode::min_error_level +1, $ode::min_error_level +1
    );


    # The submitted changes _have not_ been written to the
    # post file.

    # There is nothing else to do.

    return 1;

  } # End, if( $require_password_bf and ...


  # At this point we've cleared the authorization checks.

  # The visitor _is_ authorized to edit
  # the corresponding post file.

  # (Keep in mind that this file may or may not already exist.)


  # If the post file already exists we'll write to a temp
  # file first and overwrite the original
  # only after we know that the temp file has been created.

  # Important:
  
  # If the post file exists, we know the path
  # leading to the post file also exists. We don't need to be concerned
  # about constructing the path.

  # On the other hand if the post file does not
  # already exist, there is no point in bothering with the temp file.

  # If the post file doesn't exist, it may also be true that the
  # path leading to the post (or some portion of it)
  # does not exist. We have to check for this
  # and possibly construct the path to the post before writing
  # the post file itself.


  # We have the title of the post from the the title parameter from
  # the editedit theme's form.

  # Let's copy the value to $title_to_file_s.

  # It's this '_to_file_s' version of the title that we will eventually
  # write out to the post file.

  # (This allows to treat $form_title_g and $title_to_file_s
  # differently.)


  # We will handle the body in the same way with a separate
  # 'form body' and 'file body' variables.


  # Note this does mean that we could end up with form content that does
  # not agree with the actual content of the file
  # immediately after we submit the form.

  # So we have to be careful.
  
  # (That's the price we pay flexibility.)


  # The purpose of the undef assignment is
  # to make it clear that we are setting the value of
  # the variable for the first time here.

  # The value of the variable should not be used
  # before this point in the execution of the script.

  $title_to_file_s = undef;

  $title_to_file_s = $form_title_g;


  # We need to clean up the tags from the body field,

  # In order to do that we need to be able to separate the tags from the
  # body content in the Editedit theme's form field
  # which corresponds to the body of the post ($form_body_g).

  # There are two ways to do it:

  # 1. We can work through the string value a line at a time
  # building up tag and body strings.

  # 2. We can use a pattern match to grab just the tag lines
  # from the body.

  # Let's it the second way.


  # I currently have the full body at: $form_body_g


  # As already described, $form_body_g includes
  # both the tags and the content that comprises the proper
  # body of the post.

  # This is what we want to pass back to the form
  # (because there is only a single form field for the tags and body),
  # but we want to treat the tags and body differently
  # when we write them out to the post file.

  # To allow for this, we create a specific version of the
  # body in '$body_to_file_s', edit that
  # and then push it out to
  # the file, leaving $form_body_g as-is.

  # The purpose of the undef assignment is
  # to make it clear that we are setting the value of
  # the variable for the first time here.

  # The value of the variable should not be used
  # before this point in the execution of the script.

  $body_to_file_s = undef;

  $body_to_file_s = $form_body_g;

  # There is some clean up work we can do before splitting the tags
  # from the body.


  # 1. Removing any leading whitespace

  # Though the post file is for the most part just a free form text file,
  # we do impose a minimal amount of structure.

  # - The first line of the file is always the title of the post.
  # - Following the title we may have a block of one or
  # more tags.
  # - Everything following the tag block is considered to be part of the body

  # In order to help enforce and expose this structure,
  # the title, tags, and body sections of the
  # post are always separated from each other by a single blank line.

  # The separation is introduced elsewhere.
  # Here we take moment to eliminate any superfluous whitespace which
  # may precede the tags, which might otherwise
  # appear between the title and tags in the post file.

  # This is easy enough.

  # Using a pattern match we search for whitespace
  # at the start of the body string.
  # We replace what we find with nothing, effectively removing it
  # from the string.

  $body_to_file_s =~ s/^\s+//;


  # Next let's deal with the issue of newlines.

  # Dealing with the line ending differences between platforms and related
  # issues can be surprisingly sticky.

  # At the risk of oversimplifying I'll keep this brief to avoid getting
  # bogged down in a lengthy discussion.

  # Different platforms (Unix-like operating systems, Windows,
  # Classic Mac OS, etc) use do not agree on the
  # on the same representation of the newline sequence.

  # This does not cause problems when working on only one system,
  # or even multiple systems of the same type.
  # However, it can be a problem when sharing files between
  # platforms.

  # Perl uses '\n' to represent a logical newline in an attempt to deal with
  # line endings in a portable way.

  # What does that mean? Basically it means that Perl allows us to
  # to use '\n' to represent a newline in our programs
  # and it takes care of converting to and from the representation
  # suitable for the platform the program is running on.

  # This is not a perfect solution however.

  # Again we run into problems when sharing data between systems that
  # do not share the same representation.

  # If we read and write from a file on any one system,
  # whatever the platform might be,
  # Perl's '\n' representation abstracts away the details effectively.
  # When we read from files we get a representation of the
  # text as a string that will work with
  # the representation that Perl will write out the a file.

  # However this can get messy if we somehow acquire text without reading
  # it as input through Perl on the same platform
  # as the running Perl program.

  # It may be necessary to explicitly translate newlines if they
  # have not otherwise been converted to agree with
  # the local newline representation.

  # Though you may not understand it, you can convert all newlines using
  # the the pattern match in the statement below.


  # Refer to the Perl documentation in perlport for more information about
  # newlines
  # http://perldoc.perl.org/perlport.html#Newlines

  $body_to_file_s =~ s/\015?\012/\n/g;


  # Now that we've dealt with any extreneous whitespace that may have
  # appeared at the start of the string,
  # and normalized line endings for the local platform
  # we can split the tags from the body
  # and then continue to process the two components
  # separately.


  # The purpose of the undef assignment is
  # to make it clear that we are setting the value of
  # the variable for the first time here.

  # The value of the variable should not be used
  # before this point in the execution of the script.

  @tag_lines_to_file_s = undef;


  { # Naked block

    # Note the naked block here, which is
    # used to limit the scope of the the lexical variable(s):
    # $tag_l

    # (These fall out of scope at the end of the naked block.)

    my (
      $tag_l,
    );


    # In this loop we work through $body_to_file_s a line at a time
    # (starting with the first line in the string).


    # Keep in mind that tags always appear before the body in post files,
    # so the tag lines will be the first lines
    # in the string at $body_to_file_s.

    # As soon as we encounter a line that is not a tag, we know that
    # we're passed the tag block.

    # All tags begin with the literal substring 'tag'.

    # We allow for the presence of whitespace before tag
    # at the start of the line.
    # The whitespace shouldn't be there,
    # but it's easy enough to overlook and keep going
    # if it is there.


    # while $body_to_file_s starts with a tag line...

    while ( ($tag_l,) = $body_to_file_s =~ m/^\s*(tag.*)$/im )
    {

      # We replace the line in $body_to_file_s
      # with nothing, effectively removing the line from
      # the string that represents the body
      # of the post file.

      # This means that the next time through
      # the loop the string
      # at $body_to_file_s will start with the next line
      # which is what we want.

      # (Note that we have already saved that line to
      # the lexical variable
      # $tag_l in the conditional expression
      # controlling the loop.)

      $body_to_file_s =~ s/^\s*(tag.*)$//im;


      # Using another pattern match we search for and remove any
      # trailing newlines from the current tag.

      # Why/What are those spaces?

      # The spaces are added to the tag lines when
      # read from the post file.

      # This is done because we want the tags to appear on separate lines
      # in the Editedit theme's preview,
      # and the preview obeys the markdown syntax.

      # Under markdown 2 trailing spaces are used to
      # represent a <br />,
      # which causes the tags to appear
      # on separate lines
      # in the preview.

      # These spaces would be more or less invisible in the text file
      # itself, and more to the point,
      # they serve no useful purpose there.

      # Using the pattern match we search for
      # one or more spaces at the end of the line and
      # replace them with nothing.

      $tag_l =~ s/[ ]+$//;


      # Next we push the line onto the list of tags at
      # @tag_lines_to_file_s.

      # We'll write out these tags to the post file before the body.

      # Note that we're pushing the tags onto the list.

      # The first tag line will be at the first string in the array, i.e.
      # $tags_line_to_file_s[0],
      # the second will be $tags_line_to_file_s[1], and so on.

      # This means that when we write the tags to the post,
      # we'll maintain the same order
      # as long as we work through the array in order
      # (...[0], ...[1], ).

      push(@tag_lines_to_file_s, $tag_l);

    } # End, while ( ($tag_l,) = $body_to_file_s =~ m/^\s*(tag.*)$/im )

  }  # End, naked block


  # Now that we have all of our tag lines as a list in the array at
  # @tag_lines_to_file_s, we join them
  # together as a string at $tags_to_file_s,
  # separating each with a newline.

  # Note that because of the way join works,
  # '\n' here is a separater.

  # It will appear between the tag lines in the joined
  # string, but not before or after
  # (which is what we want).

  $tags_to_file_s = join ("\n", @tag_lines_to_file_s);


  # As we did above, before you separated the tag lines
  # from the body, we look for and
  # removee any leading whitespace from the
  # start of:

  # $body_to_file_s
  # $tags_to_file_s

  # (now that we've separated the two).

  $tags_to_file_s =~ s/^\s+//;
  $body_to_file_s =~ s/^\s+//;


  # So at this point we have values for the edited title, tags, body
  # components ready to be written
  # out to the post file. The question is
  # how precisely to handle that.

  # The answer to that question depends on whether or not the post file
  # already exists.

  # If the post exists, then we know that we'll be updating
  # the file. On other other hand, if the post file does not exist we'll
  # need to create a new post, and possibly all or a portion
  # of the directory structure leading to the post.

  # Honestly both are kind of a pain, so let's get to it.

  # We had previously set the value of the Boolean $post_file_exists_bs.
  # It is true is the post file existed before
  # this invocation of Editedit (i.e. if this is an update to
  # an existing post file) and false otherwise.

	if($post_file_exists_bs)
	{

    # We know that we will be attempting to update an existing post file.
    # The following the typical
    # recipe for safely updating a file.

    # 1. Open a new temporary file.

    # 2. Write the update to the new file (leaving the original intact).

    # 3. Remove the original file only after we are certain
    # that the new file has been written successfully,

    # 4. Rename the temporary file to the name of the original.

    # In the end we have a file with the same name as the original
    # containing the updated content.

    # It is as if we simply updated the old file
    # but without the risk of harming the original before the changes
    # are successfully written to disk.


    # OK know that we know what we need to do,
    # let's actually write out
    # the steps.


    # 1. Open a new temporary file
    # (or emit a warning, and generate a response,
    # and return).

    # There are a few ways to run into trouble
    # when attempting to update a file.

    # Of course we need to be concerned about error handling.


    # We attempt to open a file in the same directory as the post
    # file we are being edited.

    # The name of this temporary file is the same as the original
    # except for the addition to the configurable
    # temporary file extension ($tmp_file_ext_f), which is
    # set in the config section in this file.

    # For example

    # If the post file being edited is:

    # /Library/WebServer/Documents/ode_site/some_category/some_post.txt

    # and the value of $tmp_file_ext_f is:
    
    # 'editedit_tmp' (the default)

    # we create the temp file at:

    # /Library/WebServer/Documents/ode_site/some_category/ \
    # some_post.txt.editedit_tmp


    # There are a couple of important things to note about the name of
    # the temporary file and the value of
    # $tmp_file_ext_f
    # used in this example.

    # Because the name of the original file is included as
    # part of the name of the temp file,
    # we can easily associated the two files.

    # (This will come in handy if we ever need to manually recover
    # from an issue that results in the temp file
    # being left behind.)


    # The temporary file extension includes the name of the addin
    # that created it (editedit in this case).

    # There are two reasons for doing this.

    # First, we can easily associate the files with the addin that
    # created them. For example, if these files
    # are not being automatically deleted for some reason
    # (as they should) we know immediately
    # where to look for the problem. 

    # Secondly, by following this simple rule,
    # we can avoid name conflicts among any number addins,
    # even as we create arbitrary
    # files like this.

    # Because there can only be one 'editedit' addin installed at a given
    # time, there can be only one addin
    # creating files that include the 'editedit'
    # as part of the file extension.


    # The purpose of the undef assignment
    # is to make it clear that we are uninterested in any
    # previous value of this variable.

    $ffp_to_temp_file_s = undef;

    $ffp_to_temp_file_s = $ffp_to_post_s.$tmp_file_ext_f;


    # We may not be able to create the temporary file
    # which we need to save
    # the edited file before replacing
    # the original.

    # If we cannot open a write mode file handle at
    # $ffp_to_temp_file_s...

    # (Note because this is only a temp file we don't bother checking
    # to see if there is already a file by the same
    # name. However, you should be ware that if there is already a
    # directory at $ffp_to_temp_file_s
    # it will be overwritten - i.e. destroyed.)

    if ( !(open TEMP_FH, "> $ffp_to_temp_file_s") )
    {

      # If we cannot open a write mode file handle at
      # $ffp_to_temp_file_s,
      
      # we report the problem using Ode's handle_warning_and_repsonse
      # routine, and then return immediately.

      # Editedit's form will reflect the most recent edit,
      # but these changes will not be written
      # to the post file. Because the changes are still available
      # in the form, the user has the opportunity to
      # save them to post later (after the issue
      # has been resolved).

      &ode::handle_warning_and_response (
          "Editedit : inventory_ping_response",

          "Attempting to edit post. Couldn't create temp file:\n" .
          "$ffp_to_temp_file_s\n" .
          "$!\n",

          "Editedit : Unable to create temp file nec to " .
              "edit post. (See error log for details.)\n",

          $ode::min_error_level +1, $ode::min_error_level +1
      );


      return 1;

    } # End, if ( !(open TEMP_FH, "> $ffp_to_temp_file_s") )


    # If we make it past the conditional block above,
    # we know that sucessfully created the
    # temp post file at TEMP_FH, and that we can write to this file.

    # That brings us to step 2 in our recipe:

    # 2. Write the update to the new file (leaving the original intact).

    # We write out in order the strings we have that represent
    # title, tags, and body of the post.

    # Notice that we insert two newlines between each component of the
    # post.

    # Because we have taken of care of ensuring that there these components
    # do not include leading or trailing line endings,
    # this means that each component will be separated by a single
    # blank line in the updated post file.

    # This is true even if there was originally more than one line.

    # For example
    
    # A post that has the following basic structure before being
    # edited:

    # title
    #
    #
    # tags
    #
    # body

    # Will have the following, more regular structure, after:

    # title
    #
    # tags
    #
    # body

    # Minor correction to what was said above:

    # It is not quite true that all of these components have been stripped
    # of all leading and trailing newlines.

    # That is completely true of the title and tags sections,
    # but not the body. The body will not have any
    # leading newlines, trailing newlines will be left intact.

    # Unlike the title which is always only one line,
    # and the tags, which are one line each,
    # the body is a more of a free form concept.

    # We probably shouldn't modify it anymore than is absolutely
    # necessary. Presumably if there are a bunch of blank lines at the end
    # of a post, the author had some reason
    # for putting them there.


    # To this point we have dealt with line endings the usual way
    # (using Perl's '\n' mechanism). However, as
    # discussed in the comments for the $preferred_newline_f
    # option (in the configuration section at the top of this file),
    # this may not be what we want to do with Editedit.

    # Why?

    # Because when it comes to Ode, the platform used by
    # the system running Ode is less important than the primary platform the
    # author or site maintainer is using to write
    # and edit posts.

    # Let's say that I use Ode as a platform for my weblog.

    # Further let's say I use a hosting provider and the site is running on
    # some unix-like system, but I do all of my writing on a Windows 
    # laptop.

    # When I create a new post, the file will use Windows native
    # line endings. When I edit posts from my computer via a text editor,
    # those line endings will be preserved.

    # However if I edit an existing post using Editedit Perl will want to
    # update the line endings so that they are native to the system
    # on which Ode is running. When I open those files up again in a text
    # editor, I may be surprised to find that the line endings
    # have all changed.

    # This is also a problem when I create a new post with Editedit.   

    # The purpose of $preferred_newline_f is to get around this issue.
    # The option allows the user to specify their
    # preferred line ending and stick with it regardless of
    # the platform on which Ode is running.

    # At least for the time being, the way that this is enforced is simple,
    # and limited to the following short block of code.

    # We use '\n' to represent newlines when reading post files and
    # dealing with line endings internally.
    # Before we writ to a pst file, we replace all occurences of
    # '\n' with the value of $preferred_newline_f.

    # By default Editedit uses '\n' for line endings as would normally
    # happen. An empty value for $preferred_newline_f
    # is taken to mean that the default behavior should apply.

    # We use conditioals to ensure that we only perform the substitutions when
    # $preferred_newline_f != ''.

    # Writng the title out to the post file.

    if (defined $title_to_file_s and $title_to_file_s ne '')
    {

      # If the preferred newline is not empty then we append
      # $preferred_newline_f character
      # to the end of the title line before it's output.

      # Because the title always only represents a single line, we don't
      # need to worry about interneal newlines.

      if ($preferred_newline_f != '')
      {
        print TEMP_FH "$title_to_file_s$preferred_newline_f$preferred_newline_f";
      }


      # If the preferred newline is empty then we use '\n' as the end-of-line
      # character as we normally would.
      # The line ending used will be the native newline
      # for the platform on which Ode is running.

      else
      {
        print TEMP_FH "$title_to_file_s\n\n";
      }
    }

    # Writng the tag block out to the post file.

    if (defined $tags_to_file_s and $tags_to_file_s ne '')
    {


      # Because the tag block may consist of more than one line
      # we need to replace every occurrence of '\n'
      # internally with the preferred newline sequence.

      # This is easy to accomplish with a simple substitution.
  
      # If the preferred newline is not empty then we append
      # $preferred_newline_f character
      # to the end of the tag block before it's output.

      if ($preferred_newline_f != '')
      {
        $tags_to_file_s =~ s/\n/$preferred_newline_f/g;
        print TEMP_FH "$tags_to_file_s$preferred_newline_f$preferred_newline_f";
      }


      # If the preferred newline is empty then we use '\n' as the end-of-line
      # character as we normally would.
      # The line ending used will be the native newline
      # for the platform on which Ode is running.

      # Note in addition to using the usual '\n'
      # at the end of the tag block
      # we don't need to convert the internal newlines.
      # They will already be represented as '\n'.

      else
      {
        print TEMP_FH "$tags_to_file_s\n\n";
      }
    }


    # Writng the body out to the post file.

    if (defined $body_to_file_s and $body_to_file_s ne '')
    {

      # Because the tag block may consist of more than one line
      # we need to replace every occurrence of '\n'
      # internally with the preferred newline sequence.

      # This is easy to accomplish with a simple substitution.

      # With the body we don't add extra newlines at the end of string
      # as we do with the title and tag block above.
      # This is because the body go to the end of the post file
      # and so there is no need to add a separator.

      # (With title the trailing newlines are used to create a blank
      # line between the title and tag block.
      # We do the same thing with the tag block to separate
      # it from the body.)

      if ($preferred_newline_f != '')
      {
        $body_to_file_s =~ s/\n/$preferred_newline_f/g;
      }

      print TEMP_FH $body_to_file_s;
    }


    # Now that we're finished writing to the temp file, let's
    # close the filehandle.
    
    # Technically this isn't nec the filehandle
    # will eventually close on its own. If nothing else,
    # its a good way to document that
    # we're finished with it.

    close TEMP_FH;



    # Now that we have successfully created the temporary file with the
    # contents of the edited post, we've come to
    # step 3.


    # 3. Remove the original file
    # only after we are certain that the new file has been written
    # successfully.

    # Before we do that, there is another issue we need to take care of
    # related to the modification time of the original
    # post file (which explains why we need to deal with the issue
    # here and now, before we remove the file).

    # The issue can be summarized with the following question:

    # What should be the modification time associated
    # with the edited post?

    # Remember that under Ode (and not considering the influence of
    # some installed addin which may change
    # the default behavior - indexette for example),
    # the modification time associated with a file is used as
    # the post date of the file.

    # This is important to understanding how Ode works!
    # If you don't completely understand what this means, take a moment
    # to figure it out now.

    # (You could pose your questions to the Ode community
    # for one thing.)

    # When a post file is first created the modification time associated
    # with the file is the creation date and time.
    # As I've already said, this
    # is also taken to be the post date.

    # This probably seems reasonable to you - at least initially.

    # The post date is typicallu assumed to be the date and time when
    # the post was made. Under Ode, this
    # corresponds to the date and time when the post file
    # was created.

    # However, it's important to keep in mind that that we're talking about
    # a modification time and not a creation time.
    # It just so happens that when a post is created the
    # modification time (i.e. the data and time of the last modification)
    # and the creation time will be identical.

    # (The last modification was the creation of the file.)

    # However, whenever you edit a post the modification time changes.
    # The new mod time is the date and time
    # when the change was made, and not the creation time.

    # Because Ode continues to use this value, the post date
    # will change whenever you edit a post!
    # This is probably not what you want, and it is inconsistent with
    # the common understanding of what a post date is.


    # How can we address this issue?

    # We can use an addin to separate the post date from the file
    # modification time.

    # This is one of the things that the Indexette addin does
    # (and for this reason I
    # recommend everyone use Indexette -
    # or something like it)


    # But, without the addins, what can we do?

    # This issue is important to consider with the Editedit addin, because
    # the primary job of Editedit is to allow users
    # to modify post files.

    # This is where the $restore_file_mtime_bf configuration variable
    # comes into play.

    # (Set in the config section near
    # the top of this file.)


    # $restore_file_mtime_bf is a Boolean which directs Editedit to
    # preserve or not the original modification time of
    # files after the file is edited - depending on the value of the
    # variable.

    # A true value is taken to mean that the modification time should be
    # preserved, and false indicates that value
    # should be updated - as it normally would whenever a file
    # is modified.

    # How do we preserve the modification time associated with a file?

    # We save the original mod time _before_ updating the file,
    # and then restore it afterward (overwiting the new modification time
    # set by the system when the file is changed.)

    # What does this mean for us?

    # Remember that at this point we still have
    # the original post file and the new temporary file which includes the
    # recent edit.

    # (The original file has not been modified and so the associated
    # mod time is unchanged.)

    # If $restore_file_mtime_bf is true, we want to store the modification
    # time associated with the original file.
    # Eventually we will reset the mod time of the new file
    # to this value.

    # On the other hand, if the value is false,
    # we can simply not do these things and let the modification time be
    # whatever the system sets it to be.

    # A true value may be overridden on
    # a per request basis if the author selects the 'update modication
    # timestamp' checkbox on the edit form.

    # In the default edit theme, this box is labeled:

    # 'Set post date and time to now'

    # This is the label associated with a parameter
    # 'edit_mod_time_box'.

    # When that parameter is included with a request
    # then we know that the user wants to
    # update the modification timestamp
    # of the post - regardless of the value of
    # $restore_file_mtime_bf.


    # To enforce this behavior we set the value
    # of $restore_file_mtime_bf to false
    # whenever the parameter is included as part of the request.

    # (Whenever the parameter is defined.)

    $restore_file_mtime_bf = 0 if defined( param('edit_mod_time_box') );


    # As has already been discussed if the value of
    # $restore_file_mtime_bf is true,
    # we want to store the modification time
    # of the original file.

    # We use stat to get the modification time of the original file.

    # + -----
    # | From the documentation:
    # + -----
    # |
    # | Returns a 13-element list giving the status info for a file,
    # | either the file opened via FILEHANDLE or DIRHANDLE,
    # | or named by EXPR.
    # | ...
    # | Typically used as follows:
    # | ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
    # | $atime,$mtime,$ctime,$blksize,$blocks)
    # | = stat($filename);
    # + -----

    # Refer to the Perl documentation for more information about
    # stat
    # http://perldoc.perl.org/functions/stat.html

    # Notice that the tenth element (i.e. [9])
    # of the list is $mtime which the documentation tells us
    # represents:

    # 'last modify time in seconds since the epoch'

    # We use a array slice to pick out just the tenth element and
    # save that value to $file_mod_time_s.


    # The purpose of the undef assignment
    # is to make it clear that we are uninterested in any
    # previous value of these variables.

    $file_mod_time_s = undef;

    # stat will return an empty list if the system call fails
    # for any reason.

    # We check for that issue and use Ode's
    # warning and response routine to notify the user
    # as appropriate.

    # We also return immediately without overwriting continuing with the
    # edit. (At this point the
    # original post file is still in place.)

    # Why? Isn't that a bit drastic?

    # There are really two reasons.
    
    # First, if we can't retrieve the current modification time from the
    # post file, it's likely that something is amiss related
    # to permissions for the post file. If we did continue it's likely
    # the action would fail anyway.

    # Second, if we overwrite the original we will
    # forever lose the original post file
    # modification time. Because the user has indicated that he or she wants
    # to preserve the date, we
    # should not intentionally do something
    # that will destroy it.

    if($restore_file_mtime_bf)
    {
      if ( !($file_mod_time_s = (stat $ffp_to_post_s)[9]) )
      {
        &ode::handle_warning_and_response (
          "Editedit : inventory_ping_response",

          "Could not retrieve original post mod time while editing:\n" .
          "$ffp_to_post_s\n" .
          "Stopping before overwriting the post file,\n" .
          "and leaving both the original and temp files.\n" .
          "$!\n",

          "Editedit : Can't get file mod time. " .
            "Stopped w/o updating post. (See error log for details.)\n",

          $ode::min_error_level +1, $ode::min_error_level +1
        );


        return 1;

      } # End, if ( !($file_mod_time_s = (stat $ffp_to_post_s)[9]) )

    } # End, if($restore_file_mtime_bf)


    # Assuming either we were able to successfully retrieve
    # the original modification time or
    # $restore_file_mtime_bf is false (the site maintainer
    # does not want to preserve the original post file modification time),
    # we attempt to remove the original post file. 

    if ( !(unlink $ffp_to_post_s) )
    {

      # If we cannot successfully remove the original post file,
      # (i.e. if unlink fails) we call Ode's
      # handle_warning_and_response routine to generate an
      # appropriate warning and response.

      &ode::handle_warning_and_response (
          "Editedit : inventory_ping_response",

          "Attempting to save changes.\n" .
          "Couldn't unlink original file:\n" .
          "$ffp_to_post_s\n" .
           "$!",

          "Editedit : Unable to remove original post to save " .
              "changes. (See error log for details.)\n",

          $ode::min_error_level +1, $ode::min_error_level +1
      );

      # Because we can't remove the original we won't be able to
      # replace it with the temporary file
      # (which includes the edit).

      # We return immediately.


      return 1;

    } # End, if ( !(unlink $ffp_to_post_s) )


    # Assuming we are able to remove the original file, that brings us to
    # the last step.
    
    # 4. Rename the temporary file to the name of the original.

    # This is as simple as calling Per's rename function, passing it
    # the file we want to rename
    # (the temp file) and the new file name
    # (the name of the original file).

    if (! rename($ffp_to_temp_file_s, $ffp_to_post_s) )
    {

      # Report the problem using ode's handle_warning_and_repsonse
      # routine.

      &ode::handle_warning_and_response (
        "Editedit : inventory_ping_response",

        "Unable to rename temp file:\n" .
        "$ffp_to_temp_file_s\n" .
        "Couldn't unlink original file:\n" .
        "The updated post is preserved in the temp file.\n" .
        "The original post file itself is deleted\n" .
         "$!\n",

        "Editedit : Unable to move new content into post " .
          "from temp file. (See log for details.)\n",

        $ode::min_error_level +1, $ode::min_error_level +1
      );

      # Because we can't rename the original we're left with the
      # edited temporary file.
      # It's important to note that though the original
      # post has been removed,
      # we haven't lost the content of the post.

      # (The user will need to manually resolve this issue before the
      # post will appear on the site.)

      # We return immediately.


      return 1;

    } # End, if (! rename($ffp_to_temp_file_s, $ffp_to_post_s) )


    # That's it.
    
    # We've updated the post file!

    # Having made it this far, the routine appends a message
    # to the response indicating that
    # the edited page was saved successfully.

    &ode::handle_warning_and_response (
      "Editedit : inventory_ping_response",

      "Edited page saved successfully:\n" .
      "$ffp_to_post_s\n",

      "Editedit : Page saved successfully.\n",

      $ode::min_error_level +1, $ode::min_error_level +1
    );


    # With the edited content in place, the routine
    # restores the modification time
    # of the original post file if $restore_file_mtime_bf
    # is true.

    if($restore_file_mtime_bf)
    {

      # The utime function allows us to set the modification time
      # for our file.

      # + -----
      # | From the documentation:
      # + -----
      # |
      # | Changes the access and modification times on each file
      # | of a list of files.
      # |
      # | The first two elements of the list must be the NUMERICAL access
      # | and modification times, in that order.
      # |
      # | Returns the number of files successfully changed.
      # + -----

      # We use Ode's handle_warning_and_response routine
      # to notify the user whether we were
      # successfully able to restore the modification time
      # or not.


      # If the utime function is able to change the modification
      # time of the file ...
 
      if( utime($file_mod_time_s, $file_mod_time_s, $ffp_to_post_s) )
      {

         &ode::handle_warning_and_response (
          "Editedit : inventory_ping_response",

          "Reset modification timestamp for edited file:\n" .
          "$ffp_to_post_s\n",

          "Editedit : File modification timestamp preserved.\n",

          $ode::min_error_level +1, $ode::min_error_level +1
        );

      } # End, if( utime($file_mod_time_s, $file_mod_time_s, $ffp_to_post_s) )


      # If the utime function is not able to change the modification
      # time of the file ...

      else
      {

        # Report the problem using ode's handle_warning_and_repsonse
        # routine.

        &ode::handle_warning_and_response (
          "Editedit : inventory_ping_response",

          "Unable to reset timestamp for edited file:\n" .
          "$ffp_to_post_s\n" .
          "The orig modification time is: $file_mod_time_s\n" .
          "You may want to keep this info.\n",

          "Editedit : Cannot restore file " .
            "mod timestamp ($file_mod_time_s). (See log for details.)\n",

          $ode::min_error_level +1, $ode::min_error_level +1
        );

      } # End, else

    } # End, if($restore_file_mtime_bf)

  } #	End, if($post_file_exists_bs)


  # The if block above dictates the behavior of the addin
  # when the post file being edited
  # already exists.

  # As we've just seen, in that case we need to create a temp file
  # to hold the new version of the post, and then
  # replace the original post file with the modified copy - only after
  # we know that we were able to successfully save
  # the changes.

  # The good news was that we knew that the directory
  # leading up the the post file must exist (because, obviously enough,
  # a file can't exist at a nonexistent path).


  # If the post file does not exist,
  # the if block is skipped entirely and execution jumps to the start of the
  # else clause instead (just below).

  # The good news
  
  # This time is that we don't need to worry about protecting the content
  # an existing post file.

  # The bad news
  
  # If any portion of the directory leading to the post does not exist,
  # we must fill out the path
  # before we can attempt to create the post file.

  else
  {

    # If the requested file does not exist the addin will create it.

    # (This assumes the user is authorized - which has been
    # established at this point).

    # Before attempting to create the post,
    # the addin determines if the path leading up to
    # the requested file is exists.

    # If (some portion of) the path does not exist,
    # the addin must construct the missing directories before creating the
    # post file.

    # First, check if the complete path to the post:

    # -d $config::document_root$fs_path_wo_file_s.


    # If the complete path does not exist, we'll split the requested path
    # into its component parts.

    # For each level of the path, starting at the directory
    # closest to root, the routine will
    # attempt to make the directory (mkdir), building up the path from the
    # document root directory to the directory
    # containing the post.


    # The purpose of the empty assignment
    # is to make it clear that we are uninterested in any
    # previous value of this variable.

    $fs_path_wo_file_s = undef;
    
    $fs_path_wo_file_s = $ode::req_components_at_sub{fs_path_wo_file};


    # Currently some paths in Ode both begin and end with a trailing
    # path delimiter. This can cause problems with delimiters
    # stacking up, i.e. 'dir1//dir2' when we join paths informally
    # as with $config::document_root$fs_path_wo_file_s in the conditional
    # expression below.

    # This means that it's important that we know
    # whether or not strings that represent paths include these
    # delimiters.

    # $fs_path_wo_file_s both begins and ends with a path delimiter.

    # How do I know this?
  
    # $fs_path_wo_file_s nothing more than
    # a copy of the value at:
    # $ode::req_components_at_sub{fs_path_wo_file}.

    # That value comes from from the CGI library's url method,
    # via Ode's parse_the_req routine,
    # and the string returned from url() includes
    # both leading and trailing delimiter.

    # In order to create an absolute path from the root of the filesystem
    # to the post file being created,
    # we'll need to concatenate $config::document_root and
    # $fs_path_wo_file_s.

    # $config::document_root ends with a trailing path delimiter,
    # so to avoid doubling the delimiter
    # we need to either:
    
    # 1. Remove the trailing delimeter from
    # $config::document_root.

    # 2. Remove the leading delimiter from $fs_path_wo_file_s.


    # I've decided to remove the trailing delimiter from $fs_path_wo_file_s,
    # if only because as a config variable
    # that is used extensively in ode.cgi and possibly
    # by any number of addins and themes,
    # $config::document_root is _not_ a value
    # that we should change.

    # ($fs_path_wo_file_s on the other hand is limited in it's use to
    # this subroutine.)

    # We use Perl's substr function to remove the trailing path delimiter
    # from $fs_path_wo_file_s.

    # (The conditional ensures that we
    # don't remove the character unless it is in fact
    # the one we want.)

    #if (substr($fs_path_wo_file_s, 0, 1) eq '/')
    #{
    #    $fs_path_wo_file_s = substr($fs_path_wo_file_s, 1);
    #}


    # Now that we've prepped $fs_path_wo_file_s, we can add the prefix
    # $config::document_root to create the absolute path
    # we want:

    # The purpose of the empty assignment
    # is to make it clear that we are uninterested in any
    # previous value of this variable.

    $ffp_to_new_post_s = undef;

    $ffp_to_new_post_s = "$config::document_root$fs_path_wo_file_s";


    # At this point, we're ready to check to see if the path to the
    # request file already exists.

    # If the path does not exist, we'll need to attempt to construct it.
    # This case is handled in the conditional block below.

    # If the targeted directory does exist, which is the easier case,
    # the conditional block is skipped.

    # (We won't need to do anything to create it.)


    # This check is accomplished using one Perl's file tests:

    # -d : The target is a directory

    # Refer to the Perl documentation for more information about
    # '-X' file tests
    # http://perldoc.perl.org/functions/-X.html

    # You'll no doubt notice that this looks like
    # a somewhat complicated conditional
    # expression.

    # Why not the following instead?

    # if ( !(-d $ffp_to_new_post_s ) )

    # This would work just fine for this file test.

    # I want to reuse the same stat structure returned from this file
    # test with the -e test that follows,
    # and that's where the problem comes into play.

    # We know that $ffp_to_new_post_s will include a trailing path delimiter.

    # That means that the value will look something like:

    # '/Library/WebServer/ode_site/some_directory/'

    # Assuming that directory actually does exist then it would pass
    # both the -e and -d tests.

    # But let's say that I have a file called some_directory instead:
    
    # '/Library/WebServer/ode_site/some_directory'

    # (In this case, some_directory is a filename with no file extension.)

    # What will happen if the value of $ffp_to_new_post_s is:
    # '/Library/WebServer/ode_site/some_directory/'

    # Well because some_directory is not a directory
    # -d will give a false result.

    # That makes sense.

    # The trouble is that the existence test -e will also fail,
    # though there is a file at that path.

    # This would seem to be telling us that there is nothing that should
    # prevent us from creating our directory,
    # but that's not true. We don't want to risk overwriting
    # the existing file, and it's not possible to have two filesystem entries
    # in the same directory with the same name
    # (regardless of what those two entries are.)

    # However, given the same circumstances, i.e. we have a file named
    # 'some_directory' and all of the rest,
    # if we run the file tests against the string:

    # '/Library/WebServer/ode_site/some_directory'
    
    # (without the trailing path delimiter)

    # -d will still tell us that a directory exists when there is a directory
    # at titled some_directory,
    # just as it did when we included the trailing delimiter.

    # But, and here's the critical difference, if the is a file at the
    # specified path, -d will return a false result
    # (which is what we want), and -e will now return true!

    # For this reason we run the file test -d against
    # a representation of the path which does not include the trailing
    # delimiter.

    # (Using substr to drop the character from the string as
    # passed to -d.)

    # With the -e test that follows we test the special '_' which uses
    # the same stat structure retrieved here.
    # Because it is based on a representation without the trailing
    # delimiter, it will give us the result that we
    # want when there is a file or some other filesystem entry,
    # not a directory, blocking the path.

    if ( !(-d substr($ffp_to_new_post_s, 0, length($ffp_to_new_post_s ) -1)) )
    {

      my  (
          $working_path_l,
      );


      # We've established that there is not a directory at
      # $ffp_to_new_post_s, but there
      # but we haven't yet determined that there is not something else
      # at that path.

      # Because we want to be sure that we're
      # not accidentally overwriting some other sort of directory entry
      # (e.g. file, link, etc.), we perform another test
      # before continuing.


      # -e : The target exists

      # Note the use of the special filehandle '_'
      # (a single, bare underscore).

      # When the first test is done with $ffp_to_new_post_s
      # Perl must make a system call requesting
      # the stat structure that contains the information about the
      # file necessary to determine the
      # result of the test.

      # This is a relatively slow operation.

      # When '_' is used after that first file test, Perl reuses
      # the same structure returned for the first,
      # avoiding the overhead of another system call.

      # It's important to note that '_' always refers to the most recent
      # stat structure returned, and that this might
      # not necessarily be the intended one.
      
      # It's possible that some other operation that results in
      # stat related system call can occur
      # between the intended stat request and the use of '_'.
      # In that case the subsequent tests would
      # refer to something other than the intended file.

      # This of course would lead to inaccurate results.

      # For this reason, always be cautious about where and under what
      # circumstances you use '_'


      # + ----------
      # | From the documentation:
      # + ----------
      # | If stat is passed the special filehandle consisting of an
      # | underline, no stat is done,
      # | but the current contents of the stat structure
      # | from the last stat, lstat, or filetest are returned.
      # + ----------

      # Refer to the Perl documentation for more information about
      # '-X' file tests
      # http://perldoc.perl.org/functions/-X.html


      # If something exists but that something is not a directory
      # (established with the conditional above)
      # we will not be able to create the requested post.

      # (A post is a file and a file must exist in some directory.)

      # We output an appropriate warning and reponse
      # and return immediately - without making any changes to the
      # filesystem related to this request.

      if ( -e _ )
      {

        # Report the problem using ode's handle_warning_and_repsonse
        # routine.

        &ode::handle_warning_and_response (
          "Editedit : inventory_ping_response",

          "Unable to create new post file:\n" .
          "'$ffp_to_post_s'\n" .
          "Something else (not a dir) is blocking " .
            "the path at:\n" .
          "'$ffp_to_new_post_s'\n" .
          "You will need to (re)move this before continuing\n",

          "Editedit : Cannot create new post. The path is blocked. " .
            "(See log for details.)\n",

          $ode::min_error_level +1, $ode::min_error_level +1
        );


        return 1;

      } # End, if ( -e _ )


      # At this point, we've established that the directory where we have
      # been asked to create the new post file
      # does not already exist, and also there is no other
      # filesystem entry that would conflict
      # with that directory.

      # (Note that we had previously determined that the post itself
      # does not exist.)

      # Let's say that we are dealing with a request for a new post at

      #: /Library/WebServer/Documents/ \ 
      # ode_site/technology/apple/macosx/some_post

      # At this point we know that the post file 'some.post'
      # does not exist.

      # We also know that the directory:
    
      # '/Library/WebServer/Documents/ode_site/technology/apple/macosx/'

      # But just like we can't create the post some_post if
      # the directory 'macosx' doesn't exist,
      # we can't create 'macosx' unless the directory 'apple' exists,
      # and so on.

      # We need to construct the complete path to the post.

      # We use the variable $working_path_l to
      # build up the path to the post starting at Ode's document root and
      # working outward toward the post file.

      # Keep in mind, we have established that
      # the complete path does not exist. However, some portion of the path
      # may already be in place.

      # The working path starts at the document root.

      # We can be confident that the document root exists.
      # Ode takes care of checking for this itself,
      # and will not run without a value for document_root that corresponds
      # to an existing directory.

      $working_path_l = "$config::document_root/";


      # The value of $fs_path_wo_file_s, which corresponds to
      # the  requested path, is split
      # into its component parts. Each time through the loop a new element
      # from that path is appended to the
      # $working_path_l.

      # For each new path created by appending
      # the next directory from the split components of
      # $fs_path_wo_file_s, the routine determines whether the specified
      # directory already exists.

      # If the directory does not exist it must be created.

      # As soon as we find the first directory that does not exist,
      # we know we will need to create all of the
      # remaining directories as well. In other words,
      # the existing path ends at the first
      # directory which does not already exist.

      # We'll have to build up the rest of the path from there.

      @path_components_s = split(/\//, $fs_path_wo_file_s);


      # The default behavior of split is to
      # return leading empty members of the list, but
      # omit trailing empty values.

      # For example, let's say that the string
      # we're splitting is the following, which includes
      # both a leading and trailing slash.

      # Note that this is similar to what we'll have with
      # the string at:
      
      # $fs_path_wo_file_s

      # (i.e. $fs_path_wo_file_s will always start and end with
      # path delimiters.)

      # '/dir1/dir2/dir3/'

      # split(/\//, '/dir1/dir2/dir3/');

      # results in the list

      # ('', 'dir1', 'dir2', 'dir3')


      # The leading empty member of the list is not meaningful, and so
      # we should remove it from the list.
      # That's easy enough to do with the shift function
      # which removes the first item
      # the array it operates on.


      # I've added the conditional expression just
      # to be absoluely certain that we will never shift off a
      # legimitate compoment of the path.

      # The first element of the array will only be removed if it is in fact
      # empty (which it should always be).

      shift @path_components_s if $path_components_s[0] eq '';


      # The script sets the mask here in anticipation of creating one or
      # more folders along the path
      # from the document root to the new post file.

      # For more information
      # see the comments preceeding the variables
      # $set_umask_f, and $umask_f
      # in the configuration section (above). 


      # The variable $initial_mask_s is used inside the conditional block
      # below.

      # (It is not required at if we skip the block.)

      # The purpose of the undef assignment here
      # is simply to make it clear
      # that we haven't forgotten to consider the variable
      # in the case that we skip the block.

      # The purpose of the undef assignment is
      # to make it clear that we are setting the value of
      # the variable for the first time here.

      # The value of the variable should not be used
      # before this point in the execution of the script.

      $initial_mask_s = undef;


      if($config::set_umask)
      {

        # The addin preserves the initial value for the mask
        # at $initial_mask_s.

        # We'll restore the original umask value after
        # when we're finished just be be tidy
        # (in order to prevent unexpected permissions settings
        # elsewhere).

        # + -----
        # | From the documentation:
        # + -----
        # |
        # | Sets the umask for the process to EXPR and returns the
        # | previous value.
        # | If umask(2) is not implemented on your system and you are
        # | trying to restrict access for yourself
        # | (i.e., (EXPR & 0700) > 0), produces a fatal error at run time.
        # | If umask(2) is not implemented and you are not trying to
        # | restrict access for yourself, returns undef.
        # + -----

        # Refer to the Perl documentation for more information about
        # umask
        # http://perldoc.perl.org/functions/umask.html


        if ( $initial_mask_s = umask ($config::umask) )
        {
          &ode::handle_warning_and_response (
            "Editedit : inventory_ping_response",

            "Updating umask to value at \$config::umask\n" .
            "prior to creating directories leading to requested " .
              "post file\n",

            "Editedit : Updating folder permissions mask.\n",

            $ode::min_error_level +1, $ode::min_error_level -1
          );

        } # End, if ( $initial_mask_s = umask ($config::umask) )

        else
        {
          &ode::handle_warning_and_response (
            "Editedit : inventory_ping_response",

            "Could not set mask to value specified in " .
              "\$config::umask\n" .
            "$!",

            "Editedit : Could not update permissions " . 
              "mask. (See log for details.)\n",

            $ode::min_error_level +1, $ode::max_error_level -1
          );

        } # End, else

      } # End, if($config::set_umask)


      # Emit a warning and and response indicating that the addin
      # is constructing at least some portion of the path
      # to the requested post.

      # Note that there will be only one warning and one response generated
      # regardless of the number of
      # directories and subdirectories created.


      &ode::handle_warning_and_response (
        "Editedit : inventory_ping_response",

        "Attempting to create the path:\n" .
        "$ffp_to_new_post_s\n" .
        "(leading to the requested new post file)\n.",

        "Editedit : Constructing path to post.\n",

        $ode::min_error_level +1, $ode::min_error_level +1
      );


      # The following variables are used inside the else clause of the
      # conditional block
      # found within the foreach loop below.

      # $error_creating_path_to_post_bs
      # $first_new_dir_created_bs


      # (They are is not required at if we skip the block.)


      # The purpose of the referencing the variables here
      # is to make it clear that we haven't
      # forgotten to consider the variables in the case that we skip the
      # block.
  
      # The purpose of the undef assignment is
      # to make it clear that we are setting the value of
      # the variables for the first time here.

      # (We are uninterested in any previous value of these variables.)

      # The value of the variable should not be used
      # before this point in the execution of the script.

      $error_creating_path_to_post_bs = undef;

      $first_new_dir_created_bs = undef;


      # $error_creating_path_to_post_bs is a Boolean variable.
      # A true indicates that a problem prevented
      # Editedit from successfully creating the complete path the
      # the requested new post file.

      # The value is initially false,
      # and is only set to true if some sort of
      # error is encountered while attempting to create the path the
      # the post file in the foreach loop (below).

      # Later in the execution of the routine we check
      # the value of this Boolean.

      $error_creating_path_to_post_bs = 0;

      # $first_new_dir_created_bs is a Boolean variable.

      # As we assemble the path to the requested new post file in
      # the foreach loop below, we use this variable to keep track of whether
      # we have encountered the first directory (of possibly many)
      # which does not exist, and so must be created,
      # as part of of building out the path to the post file
      # in preparation for creating the file itself.

      # The value is initially false (we have not created the first
      # new directory before we even begin), and is
      # set to true after we successfully create the first
      # new directory.
      
      $first_new_dir_created_bs = 0;


      # This loop is used to build up the path to the requested new post
      # file on step at a time.

      foreach my $next_path_component_l (@path_components_s)
      {

        # Each iteration of the loop begins by appending the next
        # element of the path in the list
        # at @path_components_s to the string value of
        # $working_path_l.

        # We then check for the new path and create if nec.

        # Note that because the list at @path_components_s contains just
        # the name of individual elements,
        # there are no delimiters.

        # Of course we need path delimiters separating the invidual
        # path components in $working_path_l,
        # so we append a delimiter at the end of the string
        # each time add a new element.

        $working_path_l .= $next_path_component_l . '/';


        # If the new $working_path_l does not already exist,
        # it must be created.

        # Before blindly performing the file test -d, which requires a
        # relatively slow system call,
        # we check the value of the Boolean
        # $first_new_dir_created_bs.

        # If the value of $first_new_dir_created_bs is true,
        # we know the current directory does not exist - because it is
        # a child of a directory we have just created
        # (and that directory is empty).

        # The logical operator _and_ is true only if both of the its
        # operands evaluate as true. This means that
        # when !($first_new_dir_created_bs)
        # is false the second subexpression is not evaluated.

        # Using the Boolean like this allows us to avoid the file check.


        # If the first new directory has not yet been created
          # Check to see if the directory exists
          # If the directory exists
            # Continue to the next part of the path
          # Else if the directory does not exist
            # Try to create it.
        # Else if the first new directory has been created
          # Try to create it.

        if ( !($first_new_dir_created_bs) and (-d "$working_path_l") )
        {

          next;

        } # End, if ( !($first_new_dir_created_bs) and (-d "$working_path_l") )


        # mkdir is used to create the directory at the path
        # corresponding to the current value of
        # $working_path_l, with the permissions specified in the config
        # file ($config::folder_permissions).

        if( mkdir($working_path_l, $config::folder_permissions) )
        {

          # We have just created a directory along the path
          # to the requested new post file.
          # If it is _the first_ directory we've had to create
          # we set the value of the Boolen to true.

          # We know that we will need to create every directory of the
          # path after the first.

          # The Boolean allows us to avoid running the -d
          # file test for subsequent directories (children of this dir)
          # unnecessarily.

          $first_new_dir_created_bs = 1 if !$first_new_dir_created_bs;


          # Push the full path from the filesystem
          # root (remember that $working_path_l
          # begins with $config::document_root) onto
          # @partial_paths_to_new_post_f.

          # This array is list of the directories
          # created in the process of
          # attempting to construct the path
          # to the new post.

          # This list will be used to undo (remove) any
          # directories created by the addin,
          # if the script is ultimately unable to 
          # successfully build the
          # entire path.

          # It would be sloppy to leave these partial empty paths
          # lying about.

          push @partial_paths_to_new_post_f, 
            $working_path_l;

        } # End, ( mkdir($working_path_l, $config::folder_permissions) )

        else
        {

          # The routine is unable to create the directory at
          # the current working path
          # ($working_path_l).

          # Keep in mind that this may not be the directory containing
          # the requested post file. Rather, it may be that
          # or some directory along the path
          # leading to the requested post file.

          # For example if the full path to the post is:

          # '/Library/WebServer/Documents/ode_site/ \
          # technology/apple/macosx/some_post.txt'

          # $working_path_l here may be any of:

          # .../ode_site/technology/
          # .../ode_site/technology/apple/
          # .../ode_site/technology/apple/macosx/


          # Regardless of which directory cannot be created,
          # when we run into a problem, we end up here.

          # Next, we assign a true value for the Boolean variable
          # $error_creating_path_to_post_bs.

          # Later in the execution of the routine we'll check
          # the value of this Boolean.

          # If the value is true, i.e. if there was some
          # problem creating the path to the requested post,
          # we'll dismantle whatever partial path
          # may have been created before the error was encountered.

          $error_creating_path_to_post_bs = 1;


          # We also generate a warning and response
          # in the usual fashion with Ode's handle_warning_and_response
          # routine.

          # It's convenient to generate the warning here,
          # near the source of the issue.

          &ode::handle_warning_and_response (
            "Editedit : inventory_ping_response",

            "Problem attempting to create the path:\n" .
            "$ffp_to_new_post_s\n" .
            "(leading to the requested new post file)\n." .
            "The following directory could not be created:\n" .
            "$working_path_l\n" .
            "$!\n",

            "Editedit : Problem creating path to post. " .
              "(See error log for details.)\n",

            $ode::min_error_level +1, $ode::min_error_level +1
          );

          # Finally, we exit from the loop early.
          # If we were unable to create this directory then we will
          # also be unable to create subdirectories
          # stemming from this directory.


          # Last breaks out of the foreach loop.

          last;

        } # End, else


      } # End, foreach my $next_path_component_l (@path_components_s)


      # We have just exited form the loop in which we were building up
      # the path the requested post.

      # That could have ended in 1 of 3 ways:

      # 1. The entire path was created successfully. In this case we
      # are ready to move on to dealing with the post file
      # itself.

      # 2. The path could not be created successfully.

      # In this case there may be a partial path that
      # we need to 'unwind',
      # in addition to notifying the user
      # about the problem.

      # If there was a problem creating the path the Boolean
      # $error_creating_path_to_post_bs
      # will be true.

      # This value is initially false and is made
      # true only if there is an error which prevents us from
      # completing the path to the post file.

      if ($error_creating_path_to_post_bs)
      {

        # If there was some problem completing the path to the post we
        # call Ededit's &unwind_partial_path_to_post
        # helper subroutine, which takes care of deleting all
        # of the empty directories we created
        # along the path leading to the post before encountering
        # the problem which prevented us from finishing.

        # This very specific subroutine takes a single variable, which must
        # be an ordered list of paths. The assumption is
        # that the first element in the list,
        # $partial_paths_to_new_post_f[0] is the parent of the second
        # element, which is the parent of the third
        # and so on.

        # So given the partial path:

        # '/Library/WebServer/Documents/ode_site/ \
        # technology/apple/macosx/'

        # The elements of the path in order from [0] - [2] would be:

        # .../ode_site/technology/
        # .../ode_site/technology/apple/
        # .../ode_site/technology/apple/macosx/

        # The unwind... routine removes these directories starting with
        # the last element of the list and working bakward
        # so that each child is removed before
        # an attempt is made to remove the parent.

        # Keep in mind that the directories in @partial_paths_to_new_post_f
        # were just created earlier in the subroutine.
        # They did not exist before this call to Editedit's
        # inventory_ping_response routine.

        # Because of this we only thing contained in each should be
        # child specified later in the list.

        # (This correctly implies that
        # the last element in the list should be empty.)

        # The return value from &unwind_partial_path_to_post will be true
        # if all of the partial paths were successfully
        # removed, i.e. the partial path was 'unwound' entirely.

        if ( unwind_partial_path_to_post(@partial_paths_to_new_post_f) )
        {

          # If we are successful unwinding the partial path,
          # we report that the path has been
          # cleaned up using Ode's
          # handle_warning_and_response routine.


          # The values are compared to the user configurable
          # $config::warning_threshold.

          # Whenever the level passed to the routine meets or exceeds
          # the threshold value,
          # the corresponding warning and
          # response is generated.

          # Typically warnings are output to the server logs and responses
          # are included as part of the page
          # returned to the visitor.

          # (Refer to the
          # handle_warning_and_response
          # subroutine definition
          # for more info.)

          &ode::handle_warning_and_response (
            "Editedit : inventory_ping_response",

            "Cannot make dir:\n" .
            "$working_path_l\n" .
            "while attemptig to create new post:\n" .
            "$ffp_to_post_s\n" .
            "Successfully removed partial path to post\n" .
            "created before failure.\n" .
            "The new post file can't be created.\n" .
            "You must correct this issue before the op will succeed.\n" .
            "System msg:\n" .
            "$!\n",

            "Cannot create path to new post. Partial path removed. " .
              "(See error log.)\n",

            $ode::min_error_level +1, $ode::min_error_level +1
          );

        } # End, if ( unwind_partial_path_to_post(@partial_paths_to_new_post_f) )

        else
        {

          # If &unwind_partial_path_to_post returns a
          # false value then the subroutine
          # was _not_ able to completely remove all of the elements in the
          # list at @partial_paths_to_new_post_f.

          # In this case we inform the user that there was a problem
          # unwinding the path.

          # (This issue will need to be resolved manually.)

          # Note: &unwind_partial_path_to_post will take care of
          # reporting the first directory that
          # could not be removed and why.

          # Note: There is nothing else we can do at this point except
          # return to the caller.
  
          # Currently we fall through to the return at the end of 
          # the inventory_ping_response routine.

          # (Note: I may change how this is structured in
          # some future revision of
          # the addin.)

          # The values are compared to the user configurable
          # $config::warning_threshold.

          # Whenever the level passed to the routine meets or exceeds
          # the threshold value,
          # the corresponding warning and
          # response is generated.

          # Typically warnings are output to the
          # server logs and responses are included as part of the
          # page returned to the visitor.

          # (Refer to the
          # handle_warning_and_response
          # subroutine definition
          # for more info.)

          &ode::handle_warning_and_response (

            "Editedit : inventory_ping_response",

            "Unable to remove at least one dir in the path\n" .
            "while attempting clean up from failed attempt to add post:\n" .
            "$ffp_to_post_s\n" .
            "This will need to be cleaned up manually.\n",

            "Unable to clean up from failed attempt " .
              "to add post. (See error log.)\n",

            $ode::min_error_level +1, $ode::min_error_level +1
          );

        } # End, else

      } # End, if ($error_creating_path_to_post_bs)

    } # End, if ( !(-d substr($ffp_to_new_post_s, 0, length($ffp_to_new_post_s ) -1)) )


    # At this point, we know that that directory structure leading up to
    # the requested post is in place.

    # 1. It was in place before the request
    # (this is a request to edit an existing post or a new post
    # in an existing category)

    # 2. The path was successfully created in the block above.

    # (Otherwise we would have returned from the subroutine before now.)


    # Before move on to creating the file itself, let's finish
    # up dealing with the permissions mask,
    # which we may have changed prior to creating the
    # path leading to the new post file.

    # If we successfully set the mask to something
    # other than the original value before building the directory structure
    # leading to the requested post file above, 
    # the variable $initial_mask_s will contain the original value.

    # We'll reset the mask value here to prevent unexpected permissions
    # issues elsewhere.


    # If we were able to set the mask earlier, the original
    # value is preserved in $initial_mask_s.

    # (Otherwise, $initial_mask_s will be undefined.)

    if ($config::set_umask and $initial_mask_s)
    {

      # If we are unable to set the mask back to the initial value,
      # we report the error.

      if ( !(umask($initial_mask_s)) )
      {

        &ode::handle_warning_and_response (
          "Editedit : inventory_ping_response",

          "Could not restore original permissions mask " .
             "specified in \$initial_mask_s\n" .
          "$!",

          "Editedit : Could not restore original folder permissions " .
            "mask.\n",

          $ode::min_error_level +1, $ode::max_error_level -1
        );

      } # End, if ($config::set_umask and $initial_mask_s)

    } # End, if ($initial_mask_s)


    # Having dealt with the path, we're finally ready to deal with
    # the post file itself.

    # We attempt to open an append mode filehandle to the requested post
    # file at $ffp_to_post_s.

    # Why append mode?

    # Well my thinking is that if somehow we have made a mistake and
    # there is an existing file $ffp_to_post_s
    # then by appending we will simply tack the contents
    # on to the end of the existing file,
    # rather than overwriting it completely.

    # That might make sense but it doesn't do anything for us if the thing
    # at $ffp_to_post_s is something other than an ordinary
    # text file.

    # Note: It should be impossible for there to be a file
    # at $ffp_to_post_s given that we've already checked for this and taken
    # appropriate action earlier in the subroutine.

    # So the real answer is that it's just as easy to do it this way
    # and there is no disadvantage that I can think of.
    # When there is no file at the specified path, append mode
    # acts just like a write mode filehandle,
    # and creates the file for us.
    
    # (Apending to an empty file means exactly the same thing as writing
    # to the file starting at the beginning.)

    if (open NEW_POST_FH, ">>  $ffp_to_post_s")
    {

      # Now that we've successfully opened our append mode filehandle,
      # we can write the content of the post out
      # to the corresponding post file.

      # Remember that we have the post file content in 3 sections
      # in 3 separate scalar variables:

      # $form_title_g
      # $tags_to_file_s
      # $body_to_file_s


      # Luckily for us we've done most of the work involved in formatting
      # (and otherwise prepping) these 3 strings before now.

      # For example, we know that none of the strings will begin or
      # end with any newline characters.

      # We want each section in the post file separated
      # by a single blank line. With no leading or trailing line endings,
      # this means appending two trailing newlines
      # to the end of the title and tags sections as we write them
      # to the post file.

      # Using Perl's '\n' mechanism means that that Perl will use the
      # representation that is native to the platform
      # where the script is running - i.e. the native newline character
      # for the webserver.

      # We do not need to make any changes to the body section.
      # It's the last section and so there is nothing after it to separate
      # the body from.
      
      # (It is separated from the title or tags lines with the newlines
      # included at the end of those sections.)

      # By using a conditional that depends on the value of each section
      # being defined and not empty we prevent these
      # forced newlines from stacking up in when one of the title
      # or tags section is undefined.

      # We only write out the section and the trailing newlines when there
      # is in fact some content.

      # Think about what would happen without the conditionals.

      # Let's say we have the following title

      # "I'm the title"

      # tags

      # "I'm a single tag line"

      # and body:

      # "I'm the body."


      # Without manually inserting the newlines the resulting post file
      # would look like:

      # I'm the title
      # I'm a single tag line
      # I'm the body.

      # When we add the newlines, we get:

      # I'm the title

      # I'm a single tag line

      # I'm the body.

      # (which is just what we want).


      # But what if there were no tags?

      # In that case, without the conditional construction, the post file
      # would end up looking like:

      # I'm the title


      # I'm the body.


      # Notice that there is one too many newlines
      # separating the title from the body.
      # This is because $tags_to_file_s is empty
      # when there are no tags, but without the conditional,
      # we are still adding the newlines from:
      # "$tags_to_file_s\n\n".

      # By using the conditional blocks we avoid the problem.


      if (defined $title_to_file_s and $title_to_file_s ne '')
      {
        print NEW_POST_FH "$title_to_file_s\n\n";
      }

      if (defined $tags_to_file_s and $tags_to_file_s ne '')
      {
        print NEW_POST_FH "$tags_to_file_s\n\n";
      }

      if (defined $body_to_file_s and $body_to_file_s ne '')
      {
        print NEW_POST_FH $body_to_file_s;
      }


      # Now that we're finished writing to the post file, let's
      # close the filehandle.

      # Technically this isn't necessary. The filehandle will eventually
      # close on its own.

      # (But, if nothing else, its a good way
      # to document that we're finished with it.)

      close NEW_POST_FH;


      # We inform the user that the new post file was created successfully.

      &ode::handle_warning_and_response (
        "Editedit : inventory_ping_response",

        "Successfully created new post file at:\n" .
        "$ffp_to_post_s\n",

        "Editedit : Successfully created new post file.\n",

        $ode::min_error_level +1, $ode::min_error_level +1
      );

    } # End, if (open NEW_POST_FH, ">>  $ffp_to_post_s")

    else
    {

      # If we are unable to unable to a write mode filehandle
      # to the post file we are attempting to create,
      # we _will not_ be able to create the
      # post file successfully.

      # The best we can do is notify the user of the issue.

      &ode::handle_warning_and_response (
          "Editedit: inventory_ping_response",

          "Cannot add post:\n" .
          "$ffp_to_post_s\n" .
          "The post file does not exist and can't be " .
              "created:\n" .
          "$!\n" .
          "You must correct this issue before " .
              "add_post will succeed\n",

          "Cannot add_post. Post does not exist and " .
              "cannot be created. (See error log.)\n",

          $ode::min_error_level +1, $ode::min_error_level +1
      );

    } # End, else

  } # End, else


  # Here we are at the end of the inventory_ping_response routine.
  # We may or may not have successfully created
  # or updated a post file.

  # All of the specifics are handled before now.

  # There is nothing left for us to do at this point except return.


  return 1;

} # End, sub inventory_ping_response



# Helper routines


# ----------
# ADDIN INTERFACE: unwind_partial_path_to_post
# ----------

# If there was some problem completing the path to the post
# we call Ededit's &unwind_partial_path_to_post
# helper subroutine, which takes care of deleting all of the empty
# directories we created along the path
# leading to the post before encountering the problem
# which prevented us from finishing.

# The return value from &unwind_partial_path_to_post will be true
# if all of the partial paths were successfully
# removed, i.e. the partial path was 'unwound' entirely
# (and false otherwise).


# Parameters: 1
# ---------

# @partial_paths_to_new_post_s

# The single parameter is an ordered list of paths.

# The assumption is that the first element in the list,
# $partial_paths_to_new_post_f[0]
# is the parent of the second element, which is
# the parent of the third and so on.


# For example, teh given the partial path:

# '/Library/WebServer/Documents/ode_site/ \
# technology/apple/macosx/'

# The elements of the path in order from [0] - [2] would be:

# .../ode_site/technology/
# .../ode_site/technology/apple/
# .../ode_site/technology/apple/macosx/

# The unwind... routine removes these directories
# starting with the last element of the list and working backward,
# so that each child is removed before the attempted
# removal of the parent.

# This is just the of list Editedit's inventory_ping_response routine
# creates in @partial_paths_to_new_post_f,
# which is a list of all directories explicitly created
# by that routine while attempting to create the complete path to
# a new post file.

# If the post file cannot be created from some reason,
# inventory_ping_response passes the list of directories compiled to the
# point to &unwind_partial_path_to_post,
# which is responsible for removing the partial directory
# structure (useless without the post).


# Return values: 1
# ---------

# 1. A Boolean true or false value.

# true : Signals to the caller that
# all of the paths in @partial_paths_to_new_post_s
# were successfully removed.

# false : Informs the caller that there was a problem
# removing at least one of the directories in
# @partial_paths_to_new_post_s.

# Though the specific directory that tripped up the routine and
# caused the early false return is not named
# in the return value, &unwind_partial_path_to_post does print a message to
# the error log naming the path that
# could not be removed.


sub unwind_partial_path_to_post
{

  my @partial_paths_to_new_post_s = shift @_;


  # We must disassemble
  # the path we've already created,
  # being careful to remove only directories
  # created just now, as part of the process of attempting to
  # create the path
  # to the new post file.

  # Luckily for us, we have a list of the
  # absolute paths to directories created as part of the process of
  # trying to construct
  # the path to the new post file
  # at:

  # @partial_paths_to_new_post_s


  # Important:

  # We need to remove the directories in the reverse of the
  # order in which
  # they were created.

  # This is because we can only remove empty directories,
  # and a directory is not empty
  # even if it only contains other empty
  # directories.


  # Let's say that we successfully created
  # two directories before
  # we ran into some sort of issue.

  # 1. '/Library/WebServer/Documents/ode_site/what/'

  # 2. '/Library/WebServer/Documents/ode_site/what/if/'

  # The above will be the order of the strings 
  # representing those paths
  # in the array:

  # @partial_paths_to_new_post_s


  # We need to remove them in the opposite
  # order.

  # At first, we cannot remove '../what/'
  # because it contains
  # '../what/if/'.

  # Working backward, we can remove
  # '../if/' first, because it is empty, and then '../what/', because that
  # directory will be empty
  # now that 'if/' has been removed.


  # If we couldn't create this directory,
  # we won't be able to create
  # a child of this directory (this
  # directory must exist first).


  # Note that @partial_paths_to_new_post_s may be an empty list.
  # (If the list is empty
  # the loop will be skipped, which is
  # perfectly OK.)

  while (@partial_paths_to_new_post_s)
  {

    my (
      $directory_to_remove_l,
    );

    # We pop the first path from the array.

    # pop returns (and removes) the
    # last element of the list in the targeted
    # list.

    # That means

    # 1. We deal with children before their parents.

    # 2. Each time through the loop
    # we shorten the list by one member.

    $directory_to_remove_l = pop @partial_paths_to_new_post_s;


    # If the directory cannot be removed we use Ode's
    # handle_warning_and_response routine to print a warning to the logs
    # and generate a message which is included on the
    # page returned to the browser.

    if ( !(rmdir $directory_to_remove_l) )
    {

      &ode::handle_warning_and_response 
      (
        "Editedit : unwind_partial_path_to_post",

        "Unwinding partial path to new post which " .
          "could not be created completely.\n" .
        "Cannot remove directory:\n" .
        "$directory_to_remove_l\n" .
        "This dir and of its ancestors must be removed manually\n" .
        "System msg:\n" .
        "$!\n",

        "Editedit : Encountered dir which cannot be removed " .
          "while cleaning up. (See error log.)\n",

        $ode::min_error_level +1, $ode::min_error_level +1
      );

      # At this point all we can do is return prematurely.
      # Whatever the reason, if we are unable to remove this directory,
      # we know we can't remove the parent
      # directory because it will not be empty.

      # unwind_partial_path_to_post uses a
      # false return value to indicate that at least one of the directories
      # in @partial_paths_to_new_post_s
      # could not be removed successfully (i.e. the path was
      # not unwound completely).

      return 0;

    } # End, if ( !(rmdir $directory_to_remove_l) )

  } # End, while (@partial_paths_to_new_post_s)


  # If we successfully make it trough the entire list in 
  # @partial_paths_to_new_post_s
  # without running into a problem - which would have resulted in an
  # early return - then we know that we have successfully
  # removed all of our paths.

  # A true return value is a signal to the caller that we were able to
  # successfully remove all of the paths represented
  # by the elements in the list at @partial_paths_to_new_post_s.

  return 1;

} # End, sub unwind_partial_path_to_post


1;
